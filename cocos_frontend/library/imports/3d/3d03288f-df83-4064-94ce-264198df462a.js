"use strict";
cc._RF.push(module, '3d032iP34NAZJTOJkGY30Yq', 'dfinity-auth-client-dev');
// Script/Lib/dfinity-auth-client-dev.js

"use strict";

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var DfinityAuthClient = function () {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;

  var __esm = function __esm(fn, res) {
    return function __init() {
      return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
  };

  var __commonJS = function __commonJS(cb, mod) {
    return function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
        exports: {}
      }).exports, mod), mod.exports;
    };
  };

  var __export = function __export(target, all) {
    for (var name in all) {
      __defProp(target, name, {
        get: all[name],
        enumerable: true
      });
    }
  };

  var __copyProps = function __copyProps(to, from, except, desc) {
    if (from && typeof from === "object" || typeof from === "function") {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = _createForOfIteratorHelperLoose(__getOwnPropNames(from)), _step; !(_step = _iterator()).done;) {
        _loop();
      }
    }

    return to;
  };

  var __toCommonJS = function __toCommonJS(mod) {
    return __copyProps(__defProp({}, "__esModule", {
      value: true
    }), mod);
  }; // node_modules/base64-js/index.js


  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js": function node_modulesBase64JsIndexJs(exports) {
      "use strict";

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;

      function getLens(b64) {
        var len2 = b64.length;

        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }

        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }

      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;

        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }

        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }

        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];

        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }

        return output.join("");
      }

      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;

        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }

        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }

        return parts.join("");
      }
    }
  }); // node_modules/ieee754/index.js


  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js": function node_modulesIeee754IndexJs(exports) {
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;

        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;

        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }

        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);

          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }

          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }

          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}

        e = e << mLen | m;
        eLen += mLen;

        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
      };
    }
  }); // node_modules/buffer/index.js


  var require_buffer = __commonJS({
    "node_modules/buffer/index.js": function node_modulesBufferIndexJs(exports) {
      "use strict";

      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();

      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }

      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = {
            foo: function foo() {
              return 42;
            }
          };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }

      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });

      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }

        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }

          return allocUnsafe(arg);
        }

        return from(arg, encodingOrOffset, length);
      }

      Buffer2.poolSize = 8192;

      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }

        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }

        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }

        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }

        var valueOf = value.valueOf && value.valueOf();

        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }

        var b = fromObject(value);
        if (b) return b;

        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }

        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }

      Buffer2.from = function (value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };

      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);

      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }

      function alloc(size, fill, encoding) {
        assertSize(size);

        if (size <= 0) {
          return createBuffer(size);
        }

        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }

        return createBuffer(size);
      }

      Buffer2.alloc = function (size, fill, encoding) {
        return alloc(size, fill, encoding);
      };

      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }

      Buffer2.allocUnsafe = function (size) {
        return allocUnsafe(size);
      };

      Buffer2.allocUnsafeSlow = function (size) {
        return allocUnsafe(size);
      };

      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }

        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }

        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);

        if (actual !== length) {
          buf = buf.slice(0, actual);
        }

        return buf;
      }

      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);

        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }

        return buf;
      }

      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }

        return fromArrayLike(arrayView);
      }

      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }

        var buf;

        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }

        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);

          if (buf.length === 0) {
            return buf;
          }

          obj.copy(buf, 0, 0, len);
          return buf;
        }

        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }

          return fromArrayLike(obj);
        }

        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }

      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }

        return length | 0;
      }

      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }

        return Buffer2.alloc(+length);
      }

      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };

      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);

        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }

        if (a === b) return 0;
        var x = a.length;
        var y = b.length;

        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;

          default:
            return false;
        }
      };

      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        if (list.length === 0) {
          return Buffer2.alloc(0);
        }

        var i;

        if (length === void 0) {
          length = 0;

          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }

        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;

        for (i = 0; i < list.length; ++i) {
          var buf = list[i];

          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }

          pos += buf.length;
        }

        return buffer;
      };

      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }

        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }

        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }

        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;

            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;

            case "hex":
              return len >>> 1;

            case "base64":
              return base64ToBytes(string).length;

            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }

              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.byteLength = byteLength;

      function slowToString(encoding, start, end) {
        var loweredCase = false;

        if (start === void 0 || start < 0) {
          start = 0;
        }

        if (start > this.length) {
          return "";
        }

        if (end === void 0 || end > this.length) {
          end = this.length;
        }

        if (end <= 0) {
          return "";
        }

        end >>>= 0;
        start >>>= 0;

        if (end <= start) {
          return "";
        }

        if (!encoding) encoding = "utf8";

        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);

            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);

            case "ascii":
              return asciiSlice(this, start, end);

            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);

            case "base64":
              return base64Slice(this, start, end);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.prototype._isBuffer = true;

      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }

      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;

        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }

        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }

        return this;
      };

      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;

        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }

        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }

        return this;
      };

      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;

        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }

        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }

        return this;
      };

      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };

      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;

      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };

      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };

      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }

      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }

        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }

        if (start === void 0) {
          start = 0;
        }

        if (end === void 0) {
          end = target ? target.length : 0;
        }

        if (thisStart === void 0) {
          thisStart = 0;
        }

        if (thisEnd === void 0) {
          thisEnd = this.length;
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }

        if (thisStart >= thisEnd) {
          return -1;
        }

        if (start >= end) {
          return 1;
        }

        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);

        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;

        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }

        byteOffset = +byteOffset;

        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }

        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

        if (byteOffset >= buffer.length) {
          if (dir) return -1;else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;else return -1;
        }

        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }

        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }

          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;

          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }

          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }

        throw new TypeError("val must be string, number or Buffer");
      }

      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;

        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();

          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }

            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }

        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }

        var i;

        if (dir) {
          var foundIndex = -1;

          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

          for (i = byteOffset; i >= 0; i--) {
            var found = true;

            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }

            if (found) return i;
          }
        }

        return -1;
      }

      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };

      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };

      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };

      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;

        if (!length) {
          length = remaining;
        } else {
          length = Number(length);

          if (length > remaining) {
            length = remaining;
          }
        }

        var strLen = string.length;

        if (length > strLen / 2) {
          length = strLen / 2;
        }

        var i;

        for (i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }

        return i;
      }

      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }

      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }

      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }

      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }

      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;

          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }

        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;

        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }

        if (!encoding) encoding = "utf8";
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);

            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);

            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);

            case "base64":
              return base64Write(this, string, offset, length);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };

      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };

      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }

      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;

        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;

          if (i + bytesPerSequence <= end) {
            var secondByte = void 0,
                thirdByte = void 0,
                fourthByte = void 0,
                tempCodePoint = void 0;

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }

                break;

              case 2:
                secondByte = buf[i + 1];

                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;

                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;

                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;

                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }

            }
          }

          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }

          res.push(codePoint);
          i += bytesPerSequence;
        }

        return decodeCodePointsArray(res);
      }

      var MAX_ARGUMENTS_LENGTH = 4096;

      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;

        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }

        var res = "";
        var i = 0;

        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }

        return res;
      }

      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }

        return ret;
      }

      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }

        return ret;
      }

      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out = "";

        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }

        return out;
      }

      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";

        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }

        return res;
      }

      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;

        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }

        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }

        if (end < start) end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };

      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }

      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }

        var val = this[offset + --byteLength2];
        var mul = 1;

        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };

      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };

      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };

      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };

      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };

      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        var first = this[offset];
        var last = this[offset + 7];

        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }

        var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
        var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        var first = this[offset];
        var last = this[offset + 7];

        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }

        var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
        var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });

      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];

        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };

      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };

      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };

      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        var first = this[offset];
        var last = this[offset + 7];

        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }

        var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        var first = this[offset];
        var last = this[offset + 7];

        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }

        var val = (first << 24) + // Overflow
        this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
      });

      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };

      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };

      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };

      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };

      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }

      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var mul = 1;
        var i = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        var lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        var hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }

      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        var lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        var hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }

      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }

        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }

        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });

      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };

      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }

        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }

        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });

      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }

      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }

        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }

      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };

      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }

        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }

      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };

      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;

        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }

        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;

        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }

        var len = end - start;

        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }

        return len;
      };

      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }

          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }

          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }

          if (val.length === 1) {
            var code = val.charCodeAt(0);

            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }

        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }

        if (end <= start) {
          return this;
        }

        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;

        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          var len = bytes.length;

          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }

          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }

        return this;
      };

      var errors = {};

      function E(sym, getMessage, Base) {
        errors[sym] = /*#__PURE__*/function (_Base) {
          _inheritsLoose(NodeError, _Base);

          function NodeError() {
            var _this;

            _this = _Base.call(this) || this;
            Object.defineProperty(_assertThisInitialized(_this), "message", {
              value: getMessage.apply(_assertThisInitialized(_this), arguments),
              writable: true,
              configurable: true
            });
            _this.name = _this.name + " [" + sym + "]";
            _this.stack;
            delete _this.name;
            return _this;
          }

          var _proto = NodeError.prototype;

          _proto.toString = function toString() {
            return this.name + " [" + sym + "]: " + this.message;
          };

          _createClass(NodeError, [{
            key: "code",
            get: function get() {
              return sym;
            },
            set: function set(value) {
              Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
              });
            }
          }]);

          return NodeError;
        }(Base);
      }

      E("ERR_BUFFER_OUT_OF_BOUNDS", function (name) {
        if (name) {
          return name + " is outside of buffer bounds";
        }

        return "Attempt to access memory outside buffer bounds";
      }, RangeError);
      E("ERR_INVALID_ARG_TYPE", function (name, actual) {
        return "The \"" + name + "\" argument must be of type number. Received type " + typeof actual;
      }, TypeError);
      E("ERR_OUT_OF_RANGE", function (str, range, input) {
        var msg = "The value of \"" + str + "\" is out of range.";
        var received = input;

        if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);

          if (input > BigInt("4294967296") || input < -BigInt("4294967296")) {
            received = addNumericalSeparator(received);
          }

          received += "n";
        }

        msg += " It must be " + range + ". Received " + received;
        return msg;
      }, RangeError);

      function addNumericalSeparator(val) {
        var res = "";
        var i = val.length;
        var start = val[0] === "-" ? 1 : 0;

        for (; i >= start + 4; i -= 3) {
          res = "_" + val.slice(i - 3, i) + res;
        }

        return "" + val.slice(0, i) + res;
      }

      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");

        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }

      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          var n = typeof min === "bigint" ? "n" : "";
          var range;

          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = ">= 0" + n + " and < 2" + n + " ** " + (byteLength2 + 1) * 8 + n;
            } else {
              range = ">= -(2" + n + " ** " + ((byteLength2 + 1) * 8 - 1) + n + ") and < 2 ** " + ((byteLength2 + 1) * 8 - 1) + n;
            }
          } else {
            range = ">= " + min + n + " and <= " + max + n;
          }

          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }

        checkBounds(buf, offset, byteLength2);
      }

      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }

      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }

        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }

        throw new errors.ERR_OUT_OF_RANGE(type || "offset", ">= " + (type ? 1 : 0) + " and <= " + length, value);
      }

      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";

        while (str.length % 4 !== 0) {
          str = str + "=";
        }

        return str;
      }

      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];

        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);

          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }

              leadSurrogate = codePoint;
              continue;
            }

            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }

            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }

          leadSurrogate = null;

          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }

        return bytes;
      }

      function asciiToBytes(str) {
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }

        return byteArray;
      }

      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }

        return byteArray;
      }

      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }

      function blitBuffer(src, dst, offset, length) {
        var i;

        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }

        return i;
      }

      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }

      function numberIsNaN(obj) {
        return obj !== obj;
      }

      var hexSliceLookupTable = function () {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);

        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;

          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }

        return table;
      }();

      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }

      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/api.js


  var require_api = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/api.js": function node_modulesDfinityAgentLibCjsAgentApiJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ReplicaRejectCode = void 0;
      var ReplicaRejectCode;

      (function (ReplicaRejectCode2) {
        ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
        ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
        ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
        ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
        ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
      })(ReplicaRejectCode = exports.ReplicaRejectCode || (exports.ReplicaRejectCode = {}));
    }
  }); // node_modules/@dfinity/principal/lib/cjs/utils/base32.js


  var require_base32 = __commonJS({
    "node_modules/@dfinity/principal/lib/cjs/utils/base32.js": function node_modulesDfinityPrincipalLibCjsUtilsBase32Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decode = exports.encode = void 0;
      var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
      var lookupTable = /* @__PURE__ */Object.create(null);

      for (var i = 0; i < alphabet.length; i++) {
        lookupTable[alphabet[i]] = i;
      }

      lookupTable["0"] = lookupTable.o;
      lookupTable["1"] = lookupTable.i;

      function encode(input) {
        var skip = 0;
        var bits = 0;
        var output = "";

        function encodeByte(_byte) {
          if (skip < 0) {
            bits |= _byte >> -skip;
          } else {
            bits = _byte << skip & 248;
          }

          if (skip > 3) {
            skip -= 8;
            return 1;
          }

          if (skip < 4) {
            output += alphabet[bits >> 3];
            skip += 5;
          }

          return 0;
        }

        for (var _i = 0; _i < input.length;) {
          _i += encodeByte(input[_i]);
        }

        return output + (skip < 0 ? alphabet[bits >> 3] : "");
      }

      exports.encode = encode;

      function decode(input) {
        var skip = 0;
        var _byte2 = 0;
        var output = new Uint8Array(input.length * 4 / 3 | 0);
        var o = 0;

        function decodeChar(_char) {
          var val = lookupTable[_char.toLowerCase()];

          if (val === void 0) {
            throw new Error("Invalid character: " + JSON.stringify(_char));
          }

          val <<= 3;
          _byte2 |= val >>> skip;
          skip += 5;

          if (skip >= 8) {
            output[o++] = _byte2;
            skip -= 8;

            if (skip > 0) {
              _byte2 = val << 5 - skip & 255;
            } else {
              _byte2 = 0;
            }
          }
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(input), _step2; !(_step2 = _iterator2()).done;) {
          var c = _step2.value;
          decodeChar(c);
        }

        return output.slice(0, o);
      }

      exports.decode = decode;
    }
  }); // node_modules/@dfinity/principal/lib/cjs/utils/getCrc.js


  var require_getCrc = __commonJS({
    "node_modules/@dfinity/principal/lib/cjs/utils/getCrc.js": function node_modulesDfinityPrincipalLibCjsUtilsGetCrcJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getCrc32 = void 0;
      var lookUpTable = new Uint32Array([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]);

      function getCrc32(buf) {
        var b = new Uint8Array(buf);
        var crc = -1;

        for (var i = 0; i < b.length; i++) {
          var _byte3 = b[i];
          var t = (_byte3 ^ crc) & 255;
          crc = lookUpTable[t] ^ crc >>> 8;
        }

        return (crc ^ -1) >>> 0;
      }

      exports.getCrc32 = getCrc32;
    }
  }); // node_modules/@noble/hashes/crypto.js


  var require_crypto = __commonJS({
    "node_modules/@noble/hashes/crypto.js": function node_modulesNobleHashesCryptoJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  }); // node_modules/@noble/hashes/utils.js


  var require_utils = __commonJS({
    "node_modules/@noble/hashes/utils.js": function node_modulesNobleHashesUtilsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
      exports.isBytes = isBytes;
      exports.anumber = anumber;
      exports.abytes = abytes;
      exports.ahash = ahash;
      exports.aexists = aexists;
      exports.aoutput = aoutput;
      exports.u8 = u8;
      exports.u32 = u32;
      exports.clean = clean;
      exports.createView = createView;
      exports.rotr = rotr;
      exports.rotl = rotl;
      exports.byteSwap = byteSwap;
      exports.byteSwap32 = byteSwap32;
      exports.bytesToHex = bytesToHex;
      exports.hexToBytes = hexToBytes;
      exports.asyncLoop = asyncLoop;
      exports.utf8ToBytes = utf8ToBytes;
      exports.bytesToUtf8 = bytesToUtf8;
      exports.toBytes = toBytes;
      exports.kdfInputToBytes = kdfInputToBytes;
      exports.concatBytes = concatBytes;
      exports.checkOpts = checkOpts;
      exports.createHasher = createHasher;
      exports.createOptHasher = createOptHasher;
      exports.createXOFer = createXOFer;
      exports.randomBytes = randomBytes;
      var crypto_1 = require_crypto();

      function isBytes(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }

      function anumber(n) {
        if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
      }

      function abytes(b) {
        if (!isBytes(b)) throw new Error("Uint8Array expected");

        for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
          lengths[_key2 - 1] = arguments[_key2];
        }

        if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }

      function ahash(h) {
        if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.createHasher");
        anumber(h.outputLen);
        anumber(h.blockLen);
      }

      function aexists(instance, checkFinished) {
        if (checkFinished === void 0) {
          checkFinished = true;
        }

        if (instance.destroyed) throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
      }

      function aoutput(out, instance) {
        abytes(out);
        var min = instance.outputLen;

        if (out.length < min) {
          throw new Error("digestInto() expects output buffer of length at least " + min);
        }
      }

      function u8(arr) {
        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      }

      function u32(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      }

      function clean() {
        for (var _len2 = arguments.length, arrays = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          arrays[_key3] = arguments[_key3];
        }

        for (var i = 0; i < arrays.length; i++) {
          arrays[i].fill(0);
        }
      }

      function createView(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      }

      function rotr(word, shift) {
        return word << 32 - shift | word >>> shift;
      }

      function rotl(word, shift) {
        return word << shift | word >>> 32 - shift >>> 0;
      }

      exports.isLE = function () {
        return new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      }();

      function byteSwap(word) {
        return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      }

      exports.swap8IfBE = exports.isLE ? function (n) {
        return n;
      } : function (n) {
        return byteSwap(n);
      };
      exports.byteSwapIfBE = exports.swap8IfBE;

      function byteSwap32(arr) {
        for (var i = 0; i < arr.length; i++) {
          arr[i] = byteSwap(arr[i]);
        }

        return arr;
      }

      exports.swap32IfBE = exports.isLE ? function (u) {
        return u;
      } : byteSwap32;

      var hasHexBuiltin = /* @__PURE__ */function () {
        return (// @ts-ignore
          typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
        );
      }();

      var hexes = /* @__PURE__ */Array.from({
        length: 256
      }, function (_, i) {
        return i.toString(16).padStart(2, "0");
      });

      function bytesToHex(bytes) {
        abytes(bytes);
        if (hasHexBuiltin) return bytes.toHex();
        var hex = "";

        for (var i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }

        return hex;
      }

      var asciis = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };

      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
        return;
      }

      function hexToBytes(hex) {
        if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
        if (hasHexBuiltin) return Uint8Array.fromHex(hex);
        var hl = hex.length;
        var al = hl / 2;
        if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
        var array = new Uint8Array(al);

        for (var ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          var n1 = asciiToBase16(hex.charCodeAt(hi));
          var n2 = asciiToBase16(hex.charCodeAt(hi + 1));

          if (n1 === void 0 || n2 === void 0) {
            var _char2 = hex[hi] + hex[hi + 1];

            throw new Error('hex string expected, got non-hex character "' + _char2 + '" at index ' + hi);
          }

          array[ai] = n1 * 16 + n2;
        }

        return array;
      }

      var nextTick = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function nextTick() {
          return _ref.apply(this, arguments);
        };
      }();

      exports.nextTick = nextTick;

      function asyncLoop(_x2, _x3, _x4) {
        return _asyncLoop.apply(this, arguments);
      }

      function _asyncLoop() {
        _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {
          var ts, i, diff;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  ts = Date.now();
                  i = 0;

                case 2:
                  if (!(i < iters)) {
                    _context2.next = 13;
                    break;
                  }

                  cb(i);
                  diff = Date.now() - ts;

                  if (!(diff >= 0 && diff < tick)) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt("continue", 10);

                case 7:
                  _context2.next = 9;
                  return (0, exports.nextTick)();

                case 9:
                  ts += diff;

                case 10:
                  i++;
                  _context2.next = 2;
                  break;

                case 13:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        return _asyncLoop.apply(this, arguments);
      }

      function utf8ToBytes(str) {
        if (typeof str !== "string") throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str));
      }

      function bytesToUtf8(bytes) {
        return new TextDecoder().decode(bytes);
      }

      function toBytes(data) {
        if (typeof data === "string") data = utf8ToBytes(data);
        abytes(data);
        return data;
      }

      function kdfInputToBytes(data) {
        if (typeof data === "string") data = utf8ToBytes(data);
        abytes(data);
        return data;
      }

      function concatBytes() {
        var sum = 0;

        for (var i = 0; i < arguments.length; i++) {
          var a = i < 0 || arguments.length <= i ? undefined : arguments[i];
          abytes(a);
          sum += a.length;
        }

        var res = new Uint8Array(sum);

        for (var _i2 = 0, pad = 0; _i2 < arguments.length; _i2++) {
          var _a2 = _i2 < 0 || arguments.length <= _i2 ? undefined : arguments[_i2];

          res.set(_a2, pad);
          pad += _a2.length;
        }

        return res;
      }

      function checkOpts(defaults, opts) {
        if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]") throw new Error("options should be object or undefined");
        var merged = Object.assign(defaults, opts);
        return merged;
      }

      var Hash = function Hash() {};

      exports.Hash = Hash;

      function createHasher(hashCons) {
        var hashC = function hashC(msg) {
          return hashCons().update(toBytes(msg)).digest();
        };

        var tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;

        hashC.create = function () {
          return hashCons();
        };

        return hashC;
      }

      function createOptHasher(hashCons) {
        var hashC = function hashC(msg, opts) {
          return hashCons(opts).update(toBytes(msg)).digest();
        };

        var tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;

        hashC.create = function (opts) {
          return hashCons(opts);
        };

        return hashC;
      }

      function createXOFer(hashCons) {
        var hashC = function hashC(msg, opts) {
          return hashCons(opts).update(toBytes(msg)).digest();
        };

        var tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;

        hashC.create = function (opts) {
          return hashCons(opts);
        };

        return hashC;
      }

      exports.wrapConstructor = createHasher;
      exports.wrapConstructorWithOpts = createOptHasher;
      exports.wrapXOFConstructorWithOpts = createXOFer;

      function randomBytes(bytesLength) {
        if (bytesLength === void 0) {
          bytesLength = 32;
        }

        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }

        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
        }

        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  }); // node_modules/@noble/hashes/_md.js


  var require_md = __commonJS({
    "node_modules/@noble/hashes/_md.js": function node_modulesNobleHashes_mdJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
      exports.setBigUint64 = setBigUint64;
      exports.Chi = Chi;
      exports.Maj = Maj;
      var utils_ts_1 = require_utils();

      function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);

        var _32n = BigInt(32);

        var _u32_max = BigInt(4294967295);

        var wh = Number(value >> _32n & _u32_max);
        var wl = Number(value & _u32_max);
        var h = isLE ? 4 : 0;
        var l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }

      function Chi(a, b, c) {
        return a & b ^ ~a & c;
      }

      function Maj(a, b, c) {
        return a & b ^ a & c ^ b & c;
      }

      var HashMD = /*#__PURE__*/function (_utils_ts_1$Hash) {
        _inheritsLoose(HashMD, _utils_ts_1$Hash);

        function HashMD(blockLen, outputLen, padOffset, isLE) {
          var _this2;

          _this2 = _utils_ts_1$Hash.call(this) || this;
          _this2.finished = false;
          _this2.length = 0;
          _this2.pos = 0;
          _this2.destroyed = false;
          _this2.blockLen = blockLen;
          _this2.outputLen = outputLen;
          _this2.padOffset = padOffset;
          _this2.isLE = isLE;
          _this2.buffer = new Uint8Array(blockLen);
          _this2.view = (0, utils_ts_1.createView)(_this2.buffer);
          return _this2;
        }

        var _proto2 = HashMD.prototype;

        _proto2.update = function update(data) {
          (0, utils_ts_1.aexists)(this);
          data = (0, utils_ts_1.toBytes)(data);
          (0, utils_ts_1.abytes)(data);
          var view = this.view,
              buffer = this.buffer,
              blockLen = this.blockLen;
          var len = data.length;

          for (var pos = 0; pos < len;) {
            var take = Math.min(blockLen - this.pos, len - pos);

            if (take === blockLen) {
              var dataView = (0, utils_ts_1.createView)(data);

              for (; blockLen <= len - pos; pos += blockLen) {
                this.process(dataView, pos);
              }

              continue;
            }

            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;

            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }

          this.length += data.length;
          this.roundClean();
          return this;
        };

        _proto2.digestInto = function digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.aoutput)(out, this);
          this.finished = true;
          var buffer = this.buffer,
              view = this.view,
              blockLen = this.blockLen,
              isLE = this.isLE;
          var pos = this.pos;
          buffer[pos++] = 128;
          (0, utils_ts_1.clean)(this.buffer.subarray(pos));

          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }

          for (var i = pos; i < blockLen; i++) {
            buffer[i] = 0;
          }

          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          var oview = (0, utils_ts_1.createView)(out);
          var len = this.outputLen;
          if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
          var outLen = len / 4;
          var state = this.get();
          if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");

          for (var _i3 = 0; _i3 < outLen; _i3++) {
            oview.setUint32(4 * _i3, state[_i3], isLE);
          }
        };

        _proto2.digest = function digest() {
          var buffer = this.buffer,
              outputLen = this.outputLen;
          this.digestInto(buffer);
          var res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        };

        _proto2._cloneInto = function _cloneInto(to) {
          var _to;

          to || (to = new this.constructor());

          (_to = to).set.apply(_to, this.get());

          var blockLen = this.blockLen,
              buffer = this.buffer,
              length = this.length,
              finished = this.finished,
              destroyed = this.destroyed,
              pos = this.pos;
          to.destroyed = destroyed;
          to.finished = finished;
          to.length = length;
          to.pos = pos;
          if (length % blockLen) to.buffer.set(buffer);
          return to;
        };

        _proto2.clone = function clone() {
          return this._cloneInto();
        };

        return HashMD;
      }(utils_ts_1.Hash);

      exports.HashMD = HashMD;
      exports.SHA256_IV = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
      exports.SHA224_IV = Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
      exports.SHA384_IV = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
      exports.SHA512_IV = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
    }
  }); // node_modules/@noble/hashes/_u64.js


  var require_u64 = __commonJS({
    "node_modules/@noble/hashes/_u64.js": function node_modulesNobleHashes_u64Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
      exports.add = add;
      exports.fromBig = fromBig;
      exports.split = split;
      var U32_MASK64 = /* @__PURE__ */BigInt(Math.pow(2, 32) - 1);

      var _32n = /* @__PURE__ */BigInt(32);

      function fromBig(n, le) {
        if (le === void 0) {
          le = false;
        }

        if (le) return {
          h: Number(n & U32_MASK64),
          l: Number(n >> _32n & U32_MASK64)
        };
        return {
          h: Number(n >> _32n & U32_MASK64) | 0,
          l: Number(n & U32_MASK64) | 0
        };
      }

      function split(lst, le) {
        if (le === void 0) {
          le = false;
        }

        var len = lst.length;
        var Ah = new Uint32Array(len);
        var Al = new Uint32Array(len);

        for (var i = 0; i < len; i++) {
          var _fromBig = fromBig(lst[i], le),
              h = _fromBig.h,
              l = _fromBig.l;

          var _ref2 = [h, l];
          Ah[i] = _ref2[0];
          Al[i] = _ref2[1];
        }

        return [Ah, Al];
      }

      var toBig = function toBig(h, l) {
        return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      };

      exports.toBig = toBig;

      var shrSH = function shrSH(h, _l, s) {
        return h >>> s;
      };

      exports.shrSH = shrSH;

      var shrSL = function shrSL(h, l, s) {
        return h << 32 - s | l >>> s;
      };

      exports.shrSL = shrSL;

      var rotrSH = function rotrSH(h, l, s) {
        return h >>> s | l << 32 - s;
      };

      exports.rotrSH = rotrSH;

      var rotrSL = function rotrSL(h, l, s) {
        return h << 32 - s | l >>> s;
      };

      exports.rotrSL = rotrSL;

      var rotrBH = function rotrBH(h, l, s) {
        return h << 64 - s | l >>> s - 32;
      };

      exports.rotrBH = rotrBH;

      var rotrBL = function rotrBL(h, l, s) {
        return h >>> s - 32 | l << 64 - s;
      };

      exports.rotrBL = rotrBL;

      var rotr32H = function rotr32H(_h, l) {
        return l;
      };

      exports.rotr32H = rotr32H;

      var rotr32L = function rotr32L(h, _l) {
        return h;
      };

      exports.rotr32L = rotr32L;

      var rotlSH = function rotlSH(h, l, s) {
        return h << s | l >>> 32 - s;
      };

      exports.rotlSH = rotlSH;

      var rotlSL = function rotlSL(h, l, s) {
        return l << s | h >>> 32 - s;
      };

      exports.rotlSL = rotlSL;

      var rotlBH = function rotlBH(h, l, s) {
        return l << s - 32 | h >>> 64 - s;
      };

      exports.rotlBH = rotlBH;

      var rotlBL = function rotlBL(h, l, s) {
        return h << s - 32 | l >>> 64 - s;
      };

      exports.rotlBL = rotlBL;

      function add(Ah, Al, Bh, Bl) {
        var l = (Al >>> 0) + (Bl >>> 0);
        return {
          h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
          l: l | 0
        };
      }

      var add3L = function add3L(Al, Bl, Cl) {
        return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      };

      exports.add3L = add3L;

      var add3H = function add3H(low, Ah, Bh, Ch) {
        return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
      };

      exports.add3H = add3H;

      var add4L = function add4L(Al, Bl, Cl, Dl) {
        return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      };

      exports.add4L = add4L;

      var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
        return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
      };

      exports.add4H = add4H;

      var add5L = function add5L(Al, Bl, Cl, Dl, El) {
        return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      };

      exports.add5L = add5L;

      var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
        return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
      };

      exports.add5H = add5H;
      var u64 = {
        fromBig: fromBig,
        split: split,
        toBig: toBig,
        shrSH: shrSH,
        shrSL: shrSL,
        rotrSH: rotrSH,
        rotrSL: rotrSL,
        rotrBH: rotrBH,
        rotrBL: rotrBL,
        rotr32H: rotr32H,
        rotr32L: rotr32L,
        rotlSH: rotlSH,
        rotlSL: rotlSL,
        rotlBH: rotlBH,
        rotlBL: rotlBL,
        add: add,
        add3L: add3L,
        add3H: add3H,
        add4L: add4L,
        add4H: add4H,
        add5H: add5H,
        add5L: add5L
      };
      exports["default"] = u64;
    }
  }); // node_modules/@noble/hashes/sha2.js


  var require_sha2 = __commonJS({
    "node_modules/@noble/hashes/sha2.js": function node_modulesNobleHashesSha2Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;

      var _md_ts_1 = require_md();

      var u64 = require_u64();
      var utils_ts_1 = require_utils();
      var SHA256_K = /* @__PURE__ */Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
      var SHA256_W = /* @__PURE__ */new Uint32Array(64);

      var SHA256 = /*#__PURE__*/function (_md_ts_1$HashMD) {
        _inheritsLoose(SHA256, _md_ts_1$HashMD);

        function SHA256(outputLen) {
          var _this3;

          if (outputLen === void 0) {
            outputLen = 32;
          }

          _this3 = _md_ts_1$HashMD.call(this, 64, outputLen, 8, false) || this;
          _this3.A = _md_ts_1.SHA256_IV[0] | 0;
          _this3.B = _md_ts_1.SHA256_IV[1] | 0;
          _this3.C = _md_ts_1.SHA256_IV[2] | 0;
          _this3.D = _md_ts_1.SHA256_IV[3] | 0;
          _this3.E = _md_ts_1.SHA256_IV[4] | 0;
          _this3.F = _md_ts_1.SHA256_IV[5] | 0;
          _this3.G = _md_ts_1.SHA256_IV[6] | 0;
          _this3.H = _md_ts_1.SHA256_IV[7] | 0;
          return _this3;
        }

        var _proto3 = SHA256.prototype;

        _proto3.get = function get() {
          var A = this.A,
              B = this.B,
              C = this.C,
              D = this.D,
              E = this.E,
              F = this.F,
              G = this.G,
              H = this.H;
          return [A, B, C, D, E, F, G, H];
        } // prettier-ignore
        ;

        _proto3.set = function set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        };

        _proto3.process = function process(view, offset) {
          for (var i = 0; i < 16; i++, offset += 4) {
            SHA256_W[i] = view.getUint32(offset, false);
          }

          for (var _i4 = 16; _i4 < 64; _i4++) {
            var W15 = SHA256_W[_i4 - 15];
            var W2 = SHA256_W[_i4 - 2];
            var s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            var s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[_i4] = s1 + SHA256_W[_i4 - 7] + s0 + SHA256_W[_i4 - 16] | 0;
          }

          var A = this.A,
              B = this.B,
              C = this.C,
              D = this.D,
              E = this.E,
              F = this.F,
              G = this.G,
              H = this.H;

          for (var i = 0; i < 64; i++) {
            var sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            var T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            var sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            var T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }

          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        };

        _proto3.roundClean = function roundClean() {
          (0, utils_ts_1.clean)(SHA256_W);
        };

        _proto3.destroy = function destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          (0, utils_ts_1.clean)(this.buffer);
        };

        return SHA256;
      }(_md_ts_1.HashMD);

      exports.SHA256 = SHA256;

      var SHA224 = /*#__PURE__*/function (_SHA) {
        _inheritsLoose(SHA224, _SHA);

        function SHA224() {
          var _this4;

          _this4 = _SHA.call(this, 28) || this;
          _this4.A = _md_ts_1.SHA224_IV[0] | 0;
          _this4.B = _md_ts_1.SHA224_IV[1] | 0;
          _this4.C = _md_ts_1.SHA224_IV[2] | 0;
          _this4.D = _md_ts_1.SHA224_IV[3] | 0;
          _this4.E = _md_ts_1.SHA224_IV[4] | 0;
          _this4.F = _md_ts_1.SHA224_IV[5] | 0;
          _this4.G = _md_ts_1.SHA224_IV[6] | 0;
          _this4.H = _md_ts_1.SHA224_IV[7] | 0;
          return _this4;
        }

        return SHA224;
      }(SHA256);

      exports.SHA224 = SHA224;

      var K512 = /* @__PURE__ */function () {
        return u64.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(function (n) {
          return BigInt(n);
        }));
      }();

      var SHA512_Kh = /* @__PURE__ */function () {
        return K512[0];
      }();

      var SHA512_Kl = /* @__PURE__ */function () {
        return K512[1];
      }();

      var SHA512_W_H = /* @__PURE__ */new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */new Uint32Array(80);

      var SHA512 = /*#__PURE__*/function (_md_ts_1$HashMD2) {
        _inheritsLoose(SHA512, _md_ts_1$HashMD2);

        function SHA512(outputLen) {
          var _this5;

          if (outputLen === void 0) {
            outputLen = 64;
          }

          _this5 = _md_ts_1$HashMD2.call(this, 128, outputLen, 16, false) || this;
          _this5.Ah = _md_ts_1.SHA512_IV[0] | 0;
          _this5.Al = _md_ts_1.SHA512_IV[1] | 0;
          _this5.Bh = _md_ts_1.SHA512_IV[2] | 0;
          _this5.Bl = _md_ts_1.SHA512_IV[3] | 0;
          _this5.Ch = _md_ts_1.SHA512_IV[4] | 0;
          _this5.Cl = _md_ts_1.SHA512_IV[5] | 0;
          _this5.Dh = _md_ts_1.SHA512_IV[6] | 0;
          _this5.Dl = _md_ts_1.SHA512_IV[7] | 0;
          _this5.Eh = _md_ts_1.SHA512_IV[8] | 0;
          _this5.El = _md_ts_1.SHA512_IV[9] | 0;
          _this5.Fh = _md_ts_1.SHA512_IV[10] | 0;
          _this5.Fl = _md_ts_1.SHA512_IV[11] | 0;
          _this5.Gh = _md_ts_1.SHA512_IV[12] | 0;
          _this5.Gl = _md_ts_1.SHA512_IV[13] | 0;
          _this5.Hh = _md_ts_1.SHA512_IV[14] | 0;
          _this5.Hl = _md_ts_1.SHA512_IV[15] | 0;
          return _this5;
        } // prettier-ignore


        var _proto4 = SHA512.prototype;

        _proto4.get = function get() {
          var Ah = this.Ah,
              Al = this.Al,
              Bh = this.Bh,
              Bl = this.Bl,
              Ch = this.Ch,
              Cl = this.Cl,
              Dh = this.Dh,
              Dl = this.Dl,
              Eh = this.Eh,
              El = this.El,
              Fh = this.Fh,
              Fl = this.Fl,
              Gh = this.Gh,
              Gl = this.Gl,
              Hh = this.Hh,
              Hl = this.Hl;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        } // prettier-ignore
        ;

        _proto4.set = function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        };

        _proto4.process = function process(view, offset) {
          for (var i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }

          for (var _i5 = 16; _i5 < 80; _i5++) {
            var W15h = SHA512_W_H[_i5 - 15] | 0;
            var W15l = SHA512_W_L[_i5 - 15] | 0;
            var s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            var s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            var W2h = SHA512_W_H[_i5 - 2] | 0;
            var W2l = SHA512_W_L[_i5 - 2] | 0;
            var s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            var s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            var SUMl = u64.add4L(s0l, s1l, SHA512_W_L[_i5 - 7], SHA512_W_L[_i5 - 16]);
            var SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[_i5 - 7], SHA512_W_H[_i5 - 16]);
            SHA512_W_H[_i5] = SUMh | 0;
            SHA512_W_L[_i5] = SUMl | 0;
          }

          var Ah = this.Ah,
              Al = this.Al,
              Bh = this.Bh,
              Bl = this.Bl,
              Ch = this.Ch,
              Cl = this.Cl,
              Dh = this.Dh,
              Dl = this.Dl,
              Eh = this.Eh,
              El = this.El,
              Fh = this.Fh,
              Fl = this.Fl,
              Gh = this.Gh,
              Gl = this.Gl,
              Hh = this.Hh,
              Hl = this.Hl;

          for (var i = 0; i < 80; i++) {
            var sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            var sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            var CHIh = Eh & Fh ^ ~Eh & Gh;
            var CHIl = El & Fl ^ ~El & Gl;
            var T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            var T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            var T1l = T1ll | 0;
            var sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            var sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;

            var _u64$add = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);

            Eh = _u64$add.h;
            El = _u64$add.l;
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            var All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }

          var _u64$add2 = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);

          Ah = _u64$add2.h;
          Al = _u64$add2.l;

          var _u64$add3 = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);

          Bh = _u64$add3.h;
          Bl = _u64$add3.l;

          var _u64$add4 = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);

          Ch = _u64$add4.h;
          Cl = _u64$add4.l;

          var _u64$add5 = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);

          Dh = _u64$add5.h;
          Dl = _u64$add5.l;

          var _u64$add6 = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);

          Eh = _u64$add6.h;
          El = _u64$add6.l;

          var _u64$add7 = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);

          Fh = _u64$add7.h;
          Fl = _u64$add7.l;

          var _u64$add8 = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);

          Gh = _u64$add8.h;
          Gl = _u64$add8.l;

          var _u64$add9 = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);

          Hh = _u64$add9.h;
          Hl = _u64$add9.l;
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        };

        _proto4.roundClean = function roundClean() {
          (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
        };

        _proto4.destroy = function destroy() {
          (0, utils_ts_1.clean)(this.buffer);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        };

        return SHA512;
      }(_md_ts_1.HashMD);

      exports.SHA512 = SHA512;

      var SHA384 = /*#__PURE__*/function (_SHA2) {
        _inheritsLoose(SHA384, _SHA2);

        function SHA384() {
          var _this6;

          _this6 = _SHA2.call(this, 48) || this;
          _this6.Ah = _md_ts_1.SHA384_IV[0] | 0;
          _this6.Al = _md_ts_1.SHA384_IV[1] | 0;
          _this6.Bh = _md_ts_1.SHA384_IV[2] | 0;
          _this6.Bl = _md_ts_1.SHA384_IV[3] | 0;
          _this6.Ch = _md_ts_1.SHA384_IV[4] | 0;
          _this6.Cl = _md_ts_1.SHA384_IV[5] | 0;
          _this6.Dh = _md_ts_1.SHA384_IV[6] | 0;
          _this6.Dl = _md_ts_1.SHA384_IV[7] | 0;
          _this6.Eh = _md_ts_1.SHA384_IV[8] | 0;
          _this6.El = _md_ts_1.SHA384_IV[9] | 0;
          _this6.Fh = _md_ts_1.SHA384_IV[10] | 0;
          _this6.Fl = _md_ts_1.SHA384_IV[11] | 0;
          _this6.Gh = _md_ts_1.SHA384_IV[12] | 0;
          _this6.Gl = _md_ts_1.SHA384_IV[13] | 0;
          _this6.Hh = _md_ts_1.SHA384_IV[14] | 0;
          _this6.Hl = _md_ts_1.SHA384_IV[15] | 0;
          return _this6;
        }

        return SHA384;
      }(SHA512);

      exports.SHA384 = SHA384;
      var T224_IV = /* @__PURE__ */Uint32Array.from([2352822216, 424955298, 1944164710, 2312950998, 502970286, 855612546, 1738396948, 1479516111, 258812777, 2077511080, 2011393907, 79989058, 1067287976, 1780299464, 286451373, 2446758561]);
      var T256_IV = /* @__PURE__ */Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);

      var SHA512_224 = /*#__PURE__*/function (_SHA3) {
        _inheritsLoose(SHA512_224, _SHA3);

        function SHA512_224() {
          var _this7;

          _this7 = _SHA3.call(this, 28) || this;
          _this7.Ah = T224_IV[0] | 0;
          _this7.Al = T224_IV[1] | 0;
          _this7.Bh = T224_IV[2] | 0;
          _this7.Bl = T224_IV[3] | 0;
          _this7.Ch = T224_IV[4] | 0;
          _this7.Cl = T224_IV[5] | 0;
          _this7.Dh = T224_IV[6] | 0;
          _this7.Dl = T224_IV[7] | 0;
          _this7.Eh = T224_IV[8] | 0;
          _this7.El = T224_IV[9] | 0;
          _this7.Fh = T224_IV[10] | 0;
          _this7.Fl = T224_IV[11] | 0;
          _this7.Gh = T224_IV[12] | 0;
          _this7.Gl = T224_IV[13] | 0;
          _this7.Hh = T224_IV[14] | 0;
          _this7.Hl = T224_IV[15] | 0;
          return _this7;
        }

        return SHA512_224;
      }(SHA512);

      exports.SHA512_224 = SHA512_224;

      var SHA512_256 = /*#__PURE__*/function (_SHA4) {
        _inheritsLoose(SHA512_256, _SHA4);

        function SHA512_256() {
          var _this8;

          _this8 = _SHA4.call(this, 32) || this;
          _this8.Ah = T256_IV[0] | 0;
          _this8.Al = T256_IV[1] | 0;
          _this8.Bh = T256_IV[2] | 0;
          _this8.Bl = T256_IV[3] | 0;
          _this8.Ch = T256_IV[4] | 0;
          _this8.Cl = T256_IV[5] | 0;
          _this8.Dh = T256_IV[6] | 0;
          _this8.Dl = T256_IV[7] | 0;
          _this8.Eh = T256_IV[8] | 0;
          _this8.El = T256_IV[9] | 0;
          _this8.Fh = T256_IV[10] | 0;
          _this8.Fl = T256_IV[11] | 0;
          _this8.Gh = T256_IV[12] | 0;
          _this8.Gl = T256_IV[13] | 0;
          _this8.Hh = T256_IV[14] | 0;
          _this8.Hl = T256_IV[15] | 0;
          return _this8;
        }

        return SHA512_256;
      }(SHA512);

      exports.SHA512_256 = SHA512_256;
      exports.sha256 = (0, utils_ts_1.createHasher)(function () {
        return new SHA256();
      });
      exports.sha224 = (0, utils_ts_1.createHasher)(function () {
        return new SHA224();
      });
      exports.sha512 = (0, utils_ts_1.createHasher)(function () {
        return new SHA512();
      });
      exports.sha384 = (0, utils_ts_1.createHasher)(function () {
        return new SHA384();
      });
      exports.sha512_256 = (0, utils_ts_1.createHasher)(function () {
        return new SHA512_256();
      });
      exports.sha512_224 = (0, utils_ts_1.createHasher)(function () {
        return new SHA512_224();
      });
    }
  }); // node_modules/@noble/hashes/sha256.js


  var require_sha256 = __commonJS({
    "node_modules/@noble/hashes/sha256.js": function node_modulesNobleHashesSha256Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
      var sha2_ts_1 = require_sha2();
      exports.SHA256 = sha2_ts_1.SHA256;
      exports.sha256 = sha2_ts_1.sha256;
      exports.SHA224 = sha2_ts_1.SHA224;
      exports.sha224 = sha2_ts_1.sha224;
    }
  }); // node_modules/@dfinity/principal/lib/cjs/utils/sha224.js


  var require_sha224 = __commonJS({
    "node_modules/@dfinity/principal/lib/cjs/utils/sha224.js": function node_modulesDfinityPrincipalLibCjsUtilsSha224Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sha224 = void 0;
      var sha256_1 = require_sha256();

      function sha224(data) {
        return sha256_1.sha224.create().update(new Uint8Array(data)).digest();
      }

      exports.sha224 = sha224;
    }
  }); // node_modules/@dfinity/principal/lib/cjs/index.js


  var require_cjs = __commonJS({
    "node_modules/@dfinity/principal/lib/cjs/index.js": function node_modulesDfinityPrincipalLibCjsIndexJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Principal = exports.JSON_KEY_PRINCIPAL = void 0;
      var base32_1 = require_base32();
      var getCrc_1 = require_getCrc();
      var sha224_1 = require_sha224();
      exports.JSON_KEY_PRINCIPAL = "__principal__";
      var SELF_AUTHENTICATING_SUFFIX = 2;
      var ANONYMOUS_SUFFIX = 4;
      var MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR = "aaaaa-aa";

      var fromHexString = function fromHexString(hexString) {
        var _a;

        return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(function (_byte4) {
          return parseInt(_byte4, 16);
        }));
      };

      var toHexString = function toHexString(bytes) {
        return bytes.reduce(function (str, _byte5) {
          return str + _byte5.toString(16).padStart(2, "0");
        }, "");
      };

      var Principal = /*#__PURE__*/function () {
        function _Principal(_arr) {
          this._arr = _arr;
          this._isPrincipal = true;
        }

        _Principal.anonymous = function anonymous() {
          return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
        }
        /**
         * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`
         * @returns {Principal} principal of the management canister
         */
        ;

        _Principal.managementCanister = function managementCanister() {
          return this.fromText(MANAGEMENT_CANISTER_PRINCIPAL_TEXT_STR);
        };

        _Principal.selfAuthenticating = function selfAuthenticating(publicKey) {
          var sha = (0, sha224_1.sha224)(publicKey);
          var arr = new Uint8Array(sha.length + 1);
          arr.set(sha);
          arr.set([SELF_AUTHENTICATING_SUFFIX], sha.length);
          return new this(arr);
        };

        _Principal.from = function from(other) {
          if (typeof other === "string") {
            return _Principal.fromText(other);
          } else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {
            return new _Principal(other);
          } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
            return new _Principal(other._arr);
          }

          throw new Error("Impossible to convert " + JSON.stringify(other) + " to Principal.");
        };

        _Principal.fromHex = function fromHex(hex) {
          return new this(fromHexString(hex));
        };

        _Principal.fromText = function fromText(text) {
          var maybePrincipal = text;

          if (text.includes(exports.JSON_KEY_PRINCIPAL)) {
            var obj = JSON.parse(text);

            if (exports.JSON_KEY_PRINCIPAL in obj) {
              maybePrincipal = obj[exports.JSON_KEY_PRINCIPAL];
            }
          }

          var canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, "");
          var arr = (0, base32_1.decode)(canisterIdNoDash);
          arr = arr.slice(4, arr.length);
          var principal = new this(arr);

          if (principal.toText() !== maybePrincipal) {
            throw new Error("Principal \"" + principal.toText() + "\" does not have a valid checksum (original value \"" + maybePrincipal + "\" may not be a valid Principal ID).");
          }

          return principal;
        };

        _Principal.fromUint8Array = function fromUint8Array(arr) {
          return new this(arr);
        };

        var _proto5 = _Principal.prototype;

        _proto5.isAnonymous = function isAnonymous() {
          return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
        };

        _proto5.toUint8Array = function toUint8Array() {
          return this._arr;
        };

        _proto5.toHex = function toHex() {
          return toHexString(this._arr).toUpperCase();
        };

        _proto5.toText = function toText() {
          var checksumArrayBuf = new ArrayBuffer(4);
          var view = new DataView(checksumArrayBuf);
          view.setUint32(0, (0, getCrc_1.getCrc32)(this._arr));
          var checksum = new Uint8Array(checksumArrayBuf);
          var bytes = Uint8Array.from(this._arr);
          var array = new Uint8Array(checksum.length + bytes.length);
          array.set(checksum);
          array.set(bytes, checksum.length);
          var result = (0, base32_1.encode)(array);
          var matches = result.match(/.{1,5}/g);

          if (!matches) {
            throw new Error();
          }

          return matches.join("-");
        };

        _proto5.toString = function toString() {
          return this.toText();
        }
        /**
         * Serializes to JSON
         * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string
         */
        ;

        _proto5.toJSON = function toJSON() {
          var _ref3;

          return _ref3 = {}, _ref3[exports.JSON_KEY_PRINCIPAL] = this.toText(), _ref3;
        }
        /**
         * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification
         * @param {Principal} other - a {@link Principal} to compare
         * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than
         */
        ;

        _proto5.compareTo = function compareTo(other) {
          for (var i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {
            if (this._arr[i] < other._arr[i]) return "lt";else if (this._arr[i] > other._arr[i]) return "gt";
          }

          if (this._arr.length < other._arr.length) return "lt";
          if (this._arr.length > other._arr.length) return "gt";
          return "eq";
        }
        /**
         * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method
         * @param other a {@link Principal} to compare
         * @returns {boolean} boolean
         */
        ;

        _proto5.ltEq = function ltEq(other) {
          var cmp = this.compareTo(other);
          return cmp == "lt" || cmp == "eq";
        }
        /**
         * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method
         * @param other a {@link Principal} to compare
         * @returns {boolean} boolean
         */
        ;

        _proto5.gtEq = function gtEq(other) {
          var cmp = this.compareTo(other);
          return cmp == "gt" || cmp == "eq";
        };

        return _Principal;
      }();

      exports.Principal = Principal;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/utils/buffer.js


  var require_buffer2 = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/utils/buffer.js": function node_modulesDfinityAgentLibCjsUtilsBufferJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bufFromBufLike = exports.uint8ToBuf = exports.bufEquals = exports.compare = exports.fromHex = exports.toHex = exports.concat = void 0;

      function concat() {
        for (var _len3 = arguments.length, buffers = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
          buffers[_key4] = arguments[_key4];
        }

        var result = new Uint8Array(buffers.reduce(function (acc, curr) {
          return acc + curr.byteLength;
        }, 0));
        var index = 0;

        for (var _i6 = 0, _buffers = buffers; _i6 < _buffers.length; _i6++) {
          var b = _buffers[_i6];
          result.set(new Uint8Array(b), index);
          index += b.byteLength;
        }

        return result.buffer;
      }

      exports.concat = concat;

      function toHex(buffer) {
        return [].concat(new Uint8Array(buffer)).map(function (x) {
          return x.toString(16).padStart(2, "0");
        }).join("");
      }

      exports.toHex = toHex;
      var hexRe = new RegExp(/^[0-9a-fA-F]+$/);

      function fromHex(hex) {
        if (!hexRe.test(hex)) {
          throw new Error("Invalid hexadecimal string.");
        }

        var buffer = [].concat(hex).reduce(function (acc, curr, i) {
          acc[i / 2 | 0] = (acc[i / 2 | 0] || "") + curr;
          return acc;
        }, []).map(function (x) {
          return Number.parseInt(x, 16);
        });
        return new Uint8Array(buffer).buffer;
      }

      exports.fromHex = fromHex;

      function compare(b1, b2) {
        if (b1.byteLength !== b2.byteLength) {
          return b1.byteLength - b2.byteLength;
        }

        var u1 = new Uint8Array(b1);
        var u2 = new Uint8Array(b2);

        for (var i = 0; i < u1.length; i++) {
          if (u1[i] !== u2[i]) {
            return u1[i] - u2[i];
          }
        }

        return 0;
      }

      exports.compare = compare;

      function bufEquals(b1, b2) {
        return compare(b1, b2) === 0;
      }

      exports.bufEquals = bufEquals;

      function uint8ToBuf(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
      }

      exports.uint8ToBuf = uint8ToBuf;

      function bufFromBufLike(bufLike) {
        if (bufLike instanceof Uint8Array) {
          return uint8ToBuf(bufLike);
        }

        if (bufLike instanceof ArrayBuffer) {
          return bufLike;
        }

        if (Array.isArray(bufLike)) {
          return uint8ToBuf(new Uint8Array(bufLike));
        }

        if ("buffer" in bufLike) {
          return bufFromBufLike(bufLike.buffer);
        }

        return uint8ToBuf(new Uint8Array(bufLike));
      }

      exports.bufFromBufLike = bufFromBufLike;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/errors.js


  var require_errors = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/errors.js": function node_modulesDfinityAgentLibCjsErrorsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UpdateCallRejectedError = exports.QueryCallRejectedError = exports.ActorCallError = exports.AgentError = void 0;
      var principal_1 = require_cjs();
      var api_1 = require_api();
      var buffer_1 = require_buffer2();

      var AgentError = /*#__PURE__*/function (_Error) {
        _inheritsLoose(_AgentError, _Error);

        function _AgentError(message) {
          var _this9;

          _this9 = _Error.call(this, message) || this;
          _this9.message = message;
          _this9.name = "AgentError";
          _this9.__proto__ = _AgentError.prototype;
          Object.setPrototypeOf(_assertThisInitialized(_this9), _AgentError.prototype);
          return _this9;
        }

        return _AgentError;
      }( /*#__PURE__*/_wrapNativeSuper(Error));

      exports.AgentError = AgentError;

      var ActorCallError = /*#__PURE__*/function (_AgentError2) {
        _inheritsLoose(_ActorCallError, _AgentError2);

        function _ActorCallError(canisterId, methodName, type, props) {
          var _this10;

          var cid = principal_1.Principal.from(canisterId);
          _this10 = _AgentError2.call(this, ["Call failed:", "  Canister: " + cid.toText(), "  Method: " + methodName + " (" + type + ")"].concat(Object.getOwnPropertyNames(props).map(function (n) {
            return "  \"" + n + "\": " + JSON.stringify(props[n]);
          })).join("\n")) || this;
          _this10.canisterId = canisterId;
          _this10.methodName = methodName;
          _this10.type = type;
          _this10.props = props;
          _this10.name = "ActorCallError";
          _this10.__proto__ = _ActorCallError.prototype;
          Object.setPrototypeOf(_assertThisInitialized(_this10), _ActorCallError.prototype);
          return _this10;
        }

        return _ActorCallError;
      }(AgentError);

      exports.ActorCallError = ActorCallError;

      var QueryCallRejectedError = /*#__PURE__*/function (_ActorCallError2) {
        _inheritsLoose(_QueryCallRejectedError, _ActorCallError2);

        function _QueryCallRejectedError(canisterId, methodName, result) {
          var _this11;

          var _a;

          var cid = principal_1.Principal.from(canisterId);
          _this11 = _ActorCallError2.call(this, cid, methodName, "query", {
            Status: result.status,
            Code: (_a = api_1.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : "Unknown Code \"" + result.reject_code + "\"",
            Message: result.reject_message
          }) || this;
          _this11.result = result;
          _this11.name = "QueryCallRejectedError";
          _this11.__proto__ = _QueryCallRejectedError.prototype;
          Object.setPrototypeOf(_assertThisInitialized(_this11), _QueryCallRejectedError.prototype);
          return _this11;
        }

        return _QueryCallRejectedError;
      }(ActorCallError);

      exports.QueryCallRejectedError = QueryCallRejectedError;

      var UpdateCallRejectedError = /*#__PURE__*/function (_ActorCallError3) {
        _inheritsLoose(_UpdateCallRejectedError, _ActorCallError3);

        function _UpdateCallRejectedError(canisterId, methodName, requestId, response) {
          var _this12;

          var cid = principal_1.Principal.from(canisterId);
          _this12 = _ActorCallError3.call(this, cid, methodName, "update", Object.assign({
            "Request ID": (0, buffer_1.toHex)(requestId)
          }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {
            "Error code": response.body.error_code
          } : {}), {
            "Reject code": String(response.body.reject_code),
            "Reject message": response.body.reject_message
          }) : {
            "HTTP status code": response.status.toString(),
            "HTTP status text": response.statusText
          })) || this;
          _this12.requestId = requestId;
          _this12.response = response;
          _this12.name = "UpdateCallRejectedError";
          _this12.__proto__ = _UpdateCallRejectedError.prototype;
          Object.setPrototypeOf(_assertThisInitialized(_this12), _UpdateCallRejectedError.prototype);
          return _this12;
        }

        return _UpdateCallRejectedError;
      }(ActorCallError);

      exports.UpdateCallRejectedError = UpdateCallRejectedError;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/utils/buffer.js


  var require_buffer3 = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/utils/buffer.js": function node_modulesDfinityCandidLibCjsUtilsBufferJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bufFromBufLike = exports.uint8ToBuf = exports.PipeArrayBuffer = exports.fromHexString = exports.toHexString = exports.concat = void 0;

      function concat() {
        for (var _len4 = arguments.length, buffers = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
          buffers[_key5] = arguments[_key5];
        }

        var result = new Uint8Array(buffers.reduce(function (acc, curr) {
          return acc + curr.byteLength;
        }, 0));
        var index = 0;

        for (var _i7 = 0, _buffers2 = buffers; _i7 < _buffers2.length; _i7++) {
          var b = _buffers2[_i7];
          result.set(new Uint8Array(b), index);
          index += b.byteLength;
        }

        return result;
      }

      exports.concat = concat;

      function toHexString(bytes) {
        return new Uint8Array(bytes).reduce(function (str, _byte6) {
          return str + _byte6.toString(16).padStart(2, "0");
        }, "");
      }

      exports.toHexString = toHexString;

      function fromHexString(hexString) {
        var _a;

        return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(function (_byte7) {
          return parseInt(_byte7, 16);
        }));
      }

      exports.fromHexString = fromHexString;

      var PipeArrayBuffer = /*#__PURE__*/function () {
        /**
         * Creates a new instance of a pipe
         * @param buffer an optional buffer to start with
         * @param length an optional amount of bytes to use for the length.
         */
        function PipeArrayBuffer(buffer, length) {
          if (length === void 0) {
            length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0;
          }

          this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));
          this._view = new Uint8Array(this._buffer, 0, length);
        }
        /**
         * Save a checkpoint of the reading view (for backtracking)
         */


        var _proto6 = PipeArrayBuffer.prototype;

        _proto6.save = function save() {
          return this._view;
        }
        /**
         * Restore a checkpoint of the reading view (for backtracking)
         * @param checkPoint a previously saved checkpoint
         */
        ;

        _proto6.restore = function restore(checkPoint) {
          this._view = checkPoint;
        };

        /**
         * Read `num` number of bytes from the front of the pipe.
         * @param num The number of bytes to read.
         */
        _proto6.read = function read(num) {
          var result = this._view.subarray(0, num);

          this._view = this._view.subarray(num);
          return result.slice().buffer;
        };

        _proto6.readUint8 = function readUint8() {
          var result = this._view[0];
          this._view = this._view.subarray(1);
          return result;
        }
        /**
         * Write a buffer to the end of the pipe.
         * @param buf The bytes to write.
         */
        ;

        _proto6.write = function write(buf) {
          var b = new Uint8Array(buf);
          var offset = this._view.byteLength;

          if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {
            this.alloc(b.byteLength);
          } else {
            this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);
          }

          this._view.set(b, offset);
        }
        /**
         * Whether or not there is more data to read from the buffer
         */
        ;

        /**
         * Allocate a fixed amount of memory in the buffer. This does not affect the view.
         * @param amount A number of bytes to add to the buffer.
         */
        _proto6.alloc = function alloc(amount) {
          var b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
          var v = new Uint8Array(b, 0, this._view.byteLength + amount);
          v.set(this._view);
          this._buffer = b;
          this._view = v;
        };

        _createClass(PipeArrayBuffer, [{
          key: "buffer",
          get: function get() {
            return bufFromBufLike(this._view.slice());
          }
        }, {
          key: "byteLength",
          get: function get() {
            return this._view.byteLength;
          }
        }, {
          key: "end",
          get: function get() {
            return this._view.byteLength === 0;
          }
        }]);

        return PipeArrayBuffer;
      }();

      exports.PipeArrayBuffer = PipeArrayBuffer;

      function uint8ToBuf(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
      }

      exports.uint8ToBuf = uint8ToBuf;

      function bufFromBufLike(bufLike) {
        if (bufLike instanceof Uint8Array) {
          return uint8ToBuf(bufLike);
        }

        if (bufLike instanceof ArrayBuffer) {
          return bufLike;
        }

        if (Array.isArray(bufLike)) {
          return uint8ToBuf(new Uint8Array(bufLike));
        }

        if ("buffer" in bufLike) {
          return bufFromBufLike(bufLike.buffer);
        }

        return uint8ToBuf(new Uint8Array(bufLike));
      }

      exports.bufFromBufLike = bufFromBufLike;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/utils/hash.js


  var require_hash = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/utils/hash.js": function node_modulesDfinityCandidLibCjsUtilsHashJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.idlLabelToId = void 0;

      function idlHash(s) {
        var utf8encoder = new TextEncoder();
        var array = utf8encoder.encode(s);
        var h = 0;

        for (var _iterator3 = _createForOfIteratorHelperLoose(array), _step3; !(_step3 = _iterator3()).done;) {
          var c = _step3.value;
          h = (h * 223 + c) % Math.pow(2, 32);
        }

        return h;
      }

      function idlLabelToId(label) {
        if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
          var num = +label.slice(1, -1);

          if (Number.isSafeInteger(num) && num >= 0 && num < Math.pow(2, 32)) {
            return num;
          }
        }

        return idlHash(label);
      }

      exports.idlLabelToId = idlLabelToId;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/utils/leb128.js


  var require_leb128 = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/utils/leb128.js": function node_modulesDfinityCandidLibCjsUtilsLeb128Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.readIntLE = exports.readUIntLE = exports.writeIntLE = exports.writeUIntLE = exports.slebDecode = exports.slebEncode = exports.lebDecode = exports.lebEncode = exports.safeReadUint8 = exports.safeRead = void 0;
      var buffer_1 = require_buffer3();

      function eob() {
        throw new Error("unexpected end of buffer");
      }

      function safeRead(pipe, num) {
        if (pipe.byteLength < num) {
          eob();
        }

        return pipe.read(num);
      }

      exports.safeRead = safeRead;

      function safeReadUint8(pipe) {
        var _byte8 = pipe.readUint8();

        if (_byte8 === void 0) {
          eob();
        }

        return _byte8;
      }

      exports.safeReadUint8 = safeReadUint8;

      function lebEncode(value) {
        if (typeof value === "number") {
          value = BigInt(value);
        }

        if (value < BigInt(0)) {
          throw new Error("Cannot leb encode negative values.");
        }

        var byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
        var pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);

        while (true) {
          var i = Number(value & BigInt(127));
          value /= BigInt(128);

          if (value === BigInt(0)) {
            pipe.write(new Uint8Array([i]));
            break;
          } else {
            pipe.write(new Uint8Array([i | 128]));
          }
        }

        return pipe.buffer;
      }

      exports.lebEncode = lebEncode;

      function lebDecode(pipe) {
        var weight = BigInt(1);
        var value = BigInt(0);

        var _byte9;

        do {
          _byte9 = safeReadUint8(pipe);
          value += BigInt(_byte9 & 127).valueOf() * weight;
          weight *= BigInt(128);
        } while (_byte9 >= 128);

        return value;
      }

      exports.lebDecode = lebDecode;

      function slebEncode(value) {
        if (typeof value === "number") {
          value = BigInt(value);
        }

        var isNeg = value < BigInt(0);

        if (isNeg) {
          value = -value - BigInt(1);
        }

        var byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
        var pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);

        while (true) {
          var i = getLowerBytes(value);
          value /= BigInt(128);

          if (isNeg && value === BigInt(0) && (i & 64) !== 0 || !isNeg && value === BigInt(0) && (i & 64) === 0) {
            pipe.write(new Uint8Array([i]));
            break;
          } else {
            pipe.write(new Uint8Array([i | 128]));
          }
        }

        function getLowerBytes(num) {
          var bytes = num % BigInt(128);

          if (isNeg) {
            return Number(BigInt(128) - bytes - BigInt(1));
          } else {
            return Number(bytes);
          }
        }

        return pipe.buffer;
      }

      exports.slebEncode = slebEncode;

      function slebDecode(pipe) {
        var pipeView = new Uint8Array(pipe.buffer);
        var len = 0;

        for (; len < pipeView.byteLength; len++) {
          if (pipeView[len] < 128) {
            if ((pipeView[len] & 64) === 0) {
              return lebDecode(pipe);
            }

            break;
          }
        }

        var bytes = new Uint8Array(safeRead(pipe, len + 1));
        var value = BigInt(0);

        for (var i = bytes.byteLength - 1; i >= 0; i--) {
          value = value * BigInt(128) + BigInt(128 - (bytes[i] & 127) - 1);
        }

        return -value - BigInt(1);
      }

      exports.slebDecode = slebDecode;

      function writeUIntLE(value, byteLength) {
        if (BigInt(value) < BigInt(0)) {
          throw new Error("Cannot write negative values.");
        }

        return writeIntLE(value, byteLength);
      }

      exports.writeUIntLE = writeUIntLE;

      function writeIntLE(value, byteLength) {
        value = BigInt(value);
        var pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);
        var i = 0;
        var mul = BigInt(256);
        var sub = BigInt(0);

        var _byte10 = Number(value % mul);

        pipe.write(new Uint8Array([_byte10]));

        while (++i < byteLength) {
          if (value < 0 && sub === BigInt(0) && _byte10 !== 0) {
            sub = BigInt(1);
          }

          _byte10 = Number((value / mul - sub) % BigInt(256));
          pipe.write(new Uint8Array([_byte10]));
          mul *= BigInt(256);
        }

        return pipe.buffer;
      }

      exports.writeIntLE = writeIntLE;

      function readUIntLE(pipe, byteLength) {
        var val = BigInt(safeReadUint8(pipe));
        var mul = BigInt(1);
        var i = 0;

        while (++i < byteLength) {
          mul *= BigInt(256);

          var _byte11 = BigInt(safeReadUint8(pipe));

          val = val + mul * _byte11;
        }

        return val;
      }

      exports.readUIntLE = readUIntLE;

      function readIntLE(pipe, byteLength) {
        var val = readUIntLE(pipe, byteLength);
        var mul = Math.pow(BigInt(2), BigInt(8) * BigInt(byteLength - 1) + BigInt(7));

        if (val >= mul) {
          val -= mul * BigInt(2);
        }

        return val;
      }

      exports.readIntLE = readIntLE;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/utils/bigint-math.js


  var require_bigint_math = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/utils/bigint-math.js": function node_modulesDfinityCandidLibCjsUtilsBigintMathJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.iexp2 = exports.ilog2 = void 0;

      function ilog2(n) {
        var nBig = BigInt(n);

        if (n <= 0) {
          throw new RangeError("Input must be positive");
        }

        return nBig.toString(2).length - 1;
      }

      exports.ilog2 = ilog2;

      function iexp2(n) {
        var nBig = BigInt(n);

        if (n < 0) {
          throw new RangeError("Input must be non-negative");
        }

        return BigInt(1) << nBig;
      }

      exports.iexp2 = iexp2;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/idl.js


  var require_idl = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/idl.js": function node_modulesDfinityCandidLibCjsIdlJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Variant = exports.Record = exports.Opt = exports.Vec = exports.Tuple = exports.Principal = exports.Nat64 = exports.Nat32 = exports.Nat16 = exports.Nat8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Float64 = exports.Float32 = exports.Nat = exports.Int = exports.Text = exports.Null = exports.Bool = exports.Unknown = exports.Reserved = exports.Empty = exports.decode = exports.encode = exports.ServiceClass = exports.FuncClass = exports.PrincipalClass = exports.RecClass = exports.VariantClass = exports.TupleClass = exports.RecordClass = exports.OptClass = exports.VecClass = exports.FixedNatClass = exports.FixedIntClass = exports.FloatClass = exports.NatClass = exports.IntClass = exports.TextClass = exports.ReservedClass = exports.NullClass = exports.BoolClass = exports.UnknownClass = exports.EmptyClass = exports.ConstructType = exports.PrimitiveType = exports.Type = exports.Visitor = void 0;
      exports.Service = exports.Func = exports.Rec = void 0;
      var principal_1 = require_cjs();
      var buffer_1 = require_buffer3();
      var hash_1 = require_hash();
      var leb128_1 = require_leb128();
      var bigint_math_1 = require_bigint_math();
      var magicNumber = "DIDL";
      var toReadableString_max = 400;

      function zipWith(xs, ys, f) {
        return xs.map(function (x, i) {
          return f(x, ys[i]);
        });
      }

      var TypeTable = /*#__PURE__*/function () {
        function TypeTable() {
          this._typs = [];
          this._idx = /* @__PURE__ */new Map();
        }

        var _proto7 = TypeTable.prototype;

        _proto7.has = function has(obj) {
          return this._idx.has(obj.name);
        };

        _proto7.add = function add(type, buf) {
          var idx = this._typs.length;

          this._idx.set(type.name, idx);

          this._typs.push(buf);
        };

        _proto7.merge = function merge(obj, knot) {
          var idx = this._idx.get(obj.name);

          var knotIdx = this._idx.get(knot);

          if (idx === void 0) {
            throw new Error("Missing type index for " + obj);
          }

          if (knotIdx === void 0) {
            throw new Error("Missing type index for " + knot);
          }

          this._typs[idx] = this._typs[knotIdx];

          this._typs.splice(knotIdx, 1);

          this._idx["delete"](knot);
        };

        _proto7.encode = function encode() {
          var len = (0, leb128_1.lebEncode)(this._typs.length);
          var buf = (0, buffer_1.concat).apply(void 0, this._typs);
          return (0, buffer_1.concat)(len, buf);
        };

        _proto7.indexOf = function indexOf(typeName) {
          if (!this._idx.has(typeName)) {
            throw new Error("Missing type index for " + typeName);
          }

          return (0, leb128_1.slebEncode)(this._idx.get(typeName) || 0);
        };

        return TypeTable;
      }();

      var Visitor = /*#__PURE__*/function () {
        function Visitor() {}

        var _proto8 = Visitor.prototype;

        _proto8.visitType = function visitType(t, data) {
          throw new Error("Not implemented");
        };

        _proto8.visitPrimitive = function visitPrimitive(t, data) {
          return this.visitType(t, data);
        };

        _proto8.visitEmpty = function visitEmpty(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitBool = function visitBool(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitNull = function visitNull(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitReserved = function visitReserved(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitText = function visitText(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitNumber = function visitNumber(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitInt = function visitInt(t, data) {
          return this.visitNumber(t, data);
        };

        _proto8.visitNat = function visitNat(t, data) {
          return this.visitNumber(t, data);
        };

        _proto8.visitFloat = function visitFloat(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitFixedInt = function visitFixedInt(t, data) {
          return this.visitNumber(t, data);
        };

        _proto8.visitFixedNat = function visitFixedNat(t, data) {
          return this.visitNumber(t, data);
        };

        _proto8.visitPrincipal = function visitPrincipal(t, data) {
          return this.visitPrimitive(t, data);
        };

        _proto8.visitConstruct = function visitConstruct(t, data) {
          return this.visitType(t, data);
        };

        _proto8.visitVec = function visitVec(t, ty, data) {
          return this.visitConstruct(t, data);
        };

        _proto8.visitOpt = function visitOpt(t, ty, data) {
          return this.visitConstruct(t, data);
        };

        _proto8.visitRecord = function visitRecord(t, fields, data) {
          return this.visitConstruct(t, data);
        };

        _proto8.visitTuple = function visitTuple(t, components, data) {
          var fields = components.map(function (ty, i) {
            return ["_" + i + "_", ty];
          });
          return this.visitRecord(t, fields, data);
        };

        _proto8.visitVariant = function visitVariant(t, fields, data) {
          return this.visitConstruct(t, data);
        };

        _proto8.visitRec = function visitRec(t, ty, data) {
          return this.visitConstruct(ty, data);
        };

        _proto8.visitFunc = function visitFunc(t, data) {
          return this.visitConstruct(t, data);
        };

        _proto8.visitService = function visitService(t, data) {
          return this.visitConstruct(t, data);
        };

        return Visitor;
      }();

      exports.Visitor = Visitor;

      var Type = /*#__PURE__*/function () {
        function Type() {}

        var _proto9 = Type.prototype;

        /* Display type name */
        _proto9.display = function display() {
          return this.name;
        };

        _proto9.valueToString = function valueToString(x) {
          return toReadableString(x);
        }
        /* Implement `T` in the IDL spec, only needed for non-primitive types */
        ;

        _proto9.buildTypeTable = function buildTypeTable(typeTable) {
          if (!typeTable.has(this)) {
            this._buildTypeTableImpl(typeTable);
          }
        };

        return Type;
      }();

      exports.Type = Type;

      var PrimitiveType = /*#__PURE__*/function (_Type) {
        _inheritsLoose(PrimitiveType, _Type);

        function PrimitiveType() {
          return _Type.apply(this, arguments) || this;
        }

        var _proto10 = PrimitiveType.prototype;

        _proto10.checkType = function checkType(t) {
          if (this.name !== t.name) {
            throw new Error("type mismatch: type on the wire " + t.name + ", expect type " + this.name);
          }

          return t;
        } // eslint-disable-next-line @typescript-eslint/no-unused-vars
        ;

        _proto10._buildTypeTableImpl = function _buildTypeTableImpl(typeTable) {
          return;
        };

        return PrimitiveType;
      }(Type);

      exports.PrimitiveType = PrimitiveType;

      var ConstructType = /*#__PURE__*/function (_Type2) {
        _inheritsLoose(ConstructType, _Type2);

        function ConstructType() {
          return _Type2.apply(this, arguments) || this;
        }

        var _proto11 = ConstructType.prototype;

        _proto11.checkType = function checkType(t) {
          if (t instanceof RecClass) {
            var ty = t.getType();

            if (typeof ty === "undefined") {
              throw new Error("type mismatch with uninitialized type");
            }

            return ty;
          }

          throw new Error("type mismatch: type on the wire " + t.name + ", expect type " + this.name);
        };

        _proto11.encodeType = function encodeType(typeTable) {
          return typeTable.indexOf(this.name);
        };

        return ConstructType;
      }(Type);

      exports.ConstructType = ConstructType;

      var EmptyClass = /*#__PURE__*/function (_PrimitiveType) {
        _inheritsLoose(EmptyClass, _PrimitiveType);

        function EmptyClass() {
          return _PrimitiveType.apply(this, arguments) || this;
        }

        var _proto12 = EmptyClass.prototype;

        _proto12.accept = function accept(v, d) {
          return v.visitEmpty(this, d);
        };

        _proto12.covariant = function covariant(x) {
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto12.encodeValue = function encodeValue() {
          throw new Error("Empty cannot appear as a function argument");
        };

        _proto12.valueToString = function valueToString() {
          throw new Error("Empty cannot appear as a value");
        };

        _proto12.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-17
          /* IDLTypeIds.Empty */
          );
        };

        _proto12.decodeValue = function decodeValue() {
          throw new Error("Empty cannot appear as an output");
        };

        _createClass(EmptyClass, [{
          key: "name",
          get: function get() {
            return "empty";
          }
        }]);

        return EmptyClass;
      }(PrimitiveType);

      exports.EmptyClass = EmptyClass;

      var UnknownClass = /*#__PURE__*/function (_Type3) {
        _inheritsLoose(UnknownClass, _Type3);

        function UnknownClass() {
          return _Type3.apply(this, arguments) || this;
        }

        var _proto13 = UnknownClass.prototype;

        _proto13.checkType = function checkType(t) {
          throw new Error("Method not implemented for unknown.");
        };

        _proto13.accept = function accept(v, d) {
          throw v.visitType(this, d);
        };

        _proto13.covariant = function covariant(x) {
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto13.encodeValue = function encodeValue() {
          throw new Error("Unknown cannot appear as a function argument");
        };

        _proto13.valueToString = function valueToString() {
          throw new Error("Unknown cannot appear as a value");
        };

        _proto13.encodeType = function encodeType() {
          throw new Error("Unknown cannot be serialized");
        };

        _proto13.decodeValue = function decodeValue(b, t) {
          var decodedValue = t.decodeValue(b, t);

          if (Object(decodedValue) !== decodedValue) {
            decodedValue = Object(decodedValue);
          }

          var typeFunc;

          if (t instanceof RecClass) {
            typeFunc = function typeFunc() {
              return t.getType();
            };
          } else {
            typeFunc = function typeFunc() {
              return t;
            };
          }

          Object.defineProperty(decodedValue, "type", {
            value: typeFunc,
            writable: true,
            enumerable: false,
            configurable: true
          });
          return decodedValue;
        };

        _proto13._buildTypeTableImpl = function _buildTypeTableImpl() {
          throw new Error("Unknown cannot be serialized");
        };

        _createClass(UnknownClass, [{
          key: "name",
          get: function get() {
            return "Unknown";
          }
        }]);

        return UnknownClass;
      }(Type);

      exports.UnknownClass = UnknownClass;

      var BoolClass = /*#__PURE__*/function (_PrimitiveType2) {
        _inheritsLoose(BoolClass, _PrimitiveType2);

        function BoolClass() {
          return _PrimitiveType2.apply(this, arguments) || this;
        }

        var _proto14 = BoolClass.prototype;

        _proto14.accept = function accept(v, d) {
          return v.visitBool(this, d);
        };

        _proto14.covariant = function covariant(x) {
          if (typeof x === "boolean") return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto14.encodeValue = function encodeValue(x) {
          return new Uint8Array([x ? 1 : 0]);
        };

        _proto14.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-2
          /* IDLTypeIds.Bool */
          );
        };

        _proto14.decodeValue = function decodeValue(b, t) {
          this.checkType(t);

          switch ((0, leb128_1.safeReadUint8)(b)) {
            case 0:
              return false;

            case 1:
              return true;

            default:
              throw new Error("Boolean value out of range");
          }
        };

        _createClass(BoolClass, [{
          key: "name",
          get: function get() {
            return "bool";
          }
        }]);

        return BoolClass;
      }(PrimitiveType);

      exports.BoolClass = BoolClass;

      var NullClass = /*#__PURE__*/function (_PrimitiveType3) {
        _inheritsLoose(NullClass, _PrimitiveType3);

        function NullClass() {
          return _PrimitiveType3.apply(this, arguments) || this;
        }

        var _proto15 = NullClass.prototype;

        _proto15.accept = function accept(v, d) {
          return v.visitNull(this, d);
        };

        _proto15.covariant = function covariant(x) {
          if (x === null) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto15.encodeValue = function encodeValue() {
          return new ArrayBuffer(0);
        };

        _proto15.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-1
          /* IDLTypeIds.Null */
          );
        };

        _proto15.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          return null;
        };

        _createClass(NullClass, [{
          key: "name",
          get: function get() {
            return "null";
          }
        }]);

        return NullClass;
      }(PrimitiveType);

      exports.NullClass = NullClass;

      var ReservedClass = /*#__PURE__*/function (_PrimitiveType4) {
        _inheritsLoose(ReservedClass, _PrimitiveType4);

        function ReservedClass() {
          return _PrimitiveType4.apply(this, arguments) || this;
        }

        var _proto16 = ReservedClass.prototype;

        _proto16.accept = function accept(v, d) {
          return v.visitReserved(this, d);
        };

        _proto16.covariant = function covariant(x) {
          return true;
        };

        _proto16.encodeValue = function encodeValue() {
          return new ArrayBuffer(0);
        };

        _proto16.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-16
          /* IDLTypeIds.Reserved */
          );
        };

        _proto16.decodeValue = function decodeValue(b, t) {
          if (t.name !== this.name) {
            t.decodeValue(b, t);
          }

          return null;
        };

        _createClass(ReservedClass, [{
          key: "name",
          get: function get() {
            return "reserved";
          }
        }]);

        return ReservedClass;
      }(PrimitiveType);

      exports.ReservedClass = ReservedClass;

      var TextClass = /*#__PURE__*/function (_PrimitiveType5) {
        _inheritsLoose(TextClass, _PrimitiveType5);

        function TextClass() {
          return _PrimitiveType5.apply(this, arguments) || this;
        }

        var _proto17 = TextClass.prototype;

        _proto17.accept = function accept(v, d) {
          return v.visitText(this, d);
        };

        _proto17.covariant = function covariant(x) {
          if (typeof x === "string") return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto17.encodeValue = function encodeValue(x) {
          var buf = new TextEncoder().encode(x);
          var len = (0, leb128_1.lebEncode)(buf.byteLength);
          return (0, buffer_1.concat)(len, buf);
        };

        _proto17.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-15
          /* IDLTypeIds.Text */
          );
        };

        _proto17.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          var len = (0, leb128_1.lebDecode)(b);
          var buf = (0, leb128_1.safeRead)(b, Number(len));
          var decoder = new TextDecoder("utf8", {
            fatal: true
          });
          return decoder.decode(buf);
        };

        _proto17.valueToString = function valueToString(x) {
          return '"' + x + '"';
        };

        _createClass(TextClass, [{
          key: "name",
          get: function get() {
            return "text";
          }
        }]);

        return TextClass;
      }(PrimitiveType);

      exports.TextClass = TextClass;

      var IntClass = /*#__PURE__*/function (_PrimitiveType6) {
        _inheritsLoose(IntClass, _PrimitiveType6);

        function IntClass() {
          return _PrimitiveType6.apply(this, arguments) || this;
        }

        var _proto18 = IntClass.prototype;

        _proto18.accept = function accept(v, d) {
          return v.visitInt(this, d);
        };

        _proto18.covariant = function covariant(x) {
          if (typeof x === "bigint" || Number.isInteger(x)) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto18.encodeValue = function encodeValue(x) {
          return (0, leb128_1.slebEncode)(x);
        };

        _proto18.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-4
          /* IDLTypeIds.Int */
          );
        };

        _proto18.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          return (0, leb128_1.slebDecode)(b);
        };

        _proto18.valueToString = function valueToString(x) {
          return x.toString();
        };

        _createClass(IntClass, [{
          key: "name",
          get: function get() {
            return "int";
          }
        }]);

        return IntClass;
      }(PrimitiveType);

      exports.IntClass = IntClass;

      var NatClass = /*#__PURE__*/function (_PrimitiveType7) {
        _inheritsLoose(NatClass, _PrimitiveType7);

        function NatClass() {
          return _PrimitiveType7.apply(this, arguments) || this;
        }

        var _proto19 = NatClass.prototype;

        _proto19.accept = function accept(v, d) {
          return v.visitNat(this, d);
        };

        _proto19.covariant = function covariant(x) {
          if (typeof x === "bigint" && x >= BigInt(0) || Number.isInteger(x) && x >= 0) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto19.encodeValue = function encodeValue(x) {
          return (0, leb128_1.lebEncode)(x);
        };

        _proto19.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-3
          /* IDLTypeIds.Nat */
          );
        };

        _proto19.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          return (0, leb128_1.lebDecode)(b);
        };

        _proto19.valueToString = function valueToString(x) {
          return x.toString();
        };

        _createClass(NatClass, [{
          key: "name",
          get: function get() {
            return "nat";
          }
        }]);

        return NatClass;
      }(PrimitiveType);

      exports.NatClass = NatClass;

      var FloatClass = /*#__PURE__*/function (_PrimitiveType8) {
        _inheritsLoose(FloatClass, _PrimitiveType8);

        function FloatClass(_bits) {
          var _this13;

          _this13 = _PrimitiveType8.call(this) || this;
          _this13._bits = _bits;

          if (_bits !== 32 && _bits !== 64) {
            throw new Error("not a valid float type");
          }

          return _this13;
        }

        var _proto20 = FloatClass.prototype;

        _proto20.accept = function accept(v, d) {
          return v.visitFloat(this, d);
        };

        _proto20.covariant = function covariant(x) {
          if (typeof x === "number" || x instanceof Number) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto20.encodeValue = function encodeValue(x) {
          var buf = new ArrayBuffer(this._bits / 8);
          var view = new DataView(buf);

          if (this._bits === 32) {
            view.setFloat32(0, x, true);
          } else {
            view.setFloat64(0, x, true);
          }

          return buf;
        };

        _proto20.encodeType = function encodeType() {
          var opcode = this._bits === 32 ? -13 : -14;
          return (0, leb128_1.slebEncode)(opcode);
        };

        _proto20.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          var bytes = (0, leb128_1.safeRead)(b, this._bits / 8);
          var view = new DataView(bytes);

          if (this._bits === 32) {
            return view.getFloat32(0, true);
          } else {
            return view.getFloat64(0, true);
          }
        };

        _proto20.valueToString = function valueToString(x) {
          return x.toString();
        };

        _createClass(FloatClass, [{
          key: "name",
          get: function get() {
            return "float" + this._bits;
          }
        }]);

        return FloatClass;
      }(PrimitiveType);

      exports.FloatClass = FloatClass;

      var FixedIntClass = /*#__PURE__*/function (_PrimitiveType9) {
        _inheritsLoose(FixedIntClass, _PrimitiveType9);

        function FixedIntClass(_bits) {
          var _this14;

          _this14 = _PrimitiveType9.call(this) || this;
          _this14._bits = _bits;
          return _this14;
        }

        var _proto21 = FixedIntClass.prototype;

        _proto21.accept = function accept(v, d) {
          return v.visitFixedInt(this, d);
        };

        _proto21.covariant = function covariant(x) {
          var min = (0, bigint_math_1.iexp2)(this._bits - 1) * BigInt(-1);
          var max = (0, bigint_math_1.iexp2)(this._bits - 1) - BigInt(1);
          var ok = false;

          if (typeof x === "bigint") {
            ok = x >= min && x <= max;
          } else if (Number.isInteger(x)) {
            var v = BigInt(x);
            ok = v >= min && v <= max;
          } else {
            ok = false;
          }

          if (ok) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto21.encodeValue = function encodeValue(x) {
          return (0, leb128_1.writeIntLE)(x, this._bits / 8);
        };

        _proto21.encodeType = function encodeType() {
          var offset = Math.log2(this._bits) - 3;
          return (0, leb128_1.slebEncode)(-9 - offset);
        };

        _proto21.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          var num = (0, leb128_1.readIntLE)(b, this._bits / 8);

          if (this._bits <= 32) {
            return Number(num);
          } else {
            return num;
          }
        };

        _proto21.valueToString = function valueToString(x) {
          return x.toString();
        };

        _createClass(FixedIntClass, [{
          key: "name",
          get: function get() {
            return "int" + this._bits;
          }
        }]);

        return FixedIntClass;
      }(PrimitiveType);

      exports.FixedIntClass = FixedIntClass;

      var FixedNatClass = /*#__PURE__*/function (_PrimitiveType10) {
        _inheritsLoose(FixedNatClass, _PrimitiveType10);

        function FixedNatClass(_bits) {
          var _this15;

          _this15 = _PrimitiveType10.call(this) || this;
          _this15._bits = _bits;
          return _this15;
        }

        var _proto22 = FixedNatClass.prototype;

        _proto22.accept = function accept(v, d) {
          return v.visitFixedNat(this, d);
        };

        _proto22.covariant = function covariant(x) {
          var max = (0, bigint_math_1.iexp2)(this._bits);
          var ok = false;

          if (typeof x === "bigint" && x >= BigInt(0)) {
            ok = x < max;
          } else if (Number.isInteger(x) && x >= 0) {
            var v = BigInt(x);
            ok = v < max;
          } else {
            ok = false;
          }

          if (ok) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto22.encodeValue = function encodeValue(x) {
          return (0, leb128_1.writeUIntLE)(x, this._bits / 8);
        };

        _proto22.encodeType = function encodeType() {
          var offset = Math.log2(this._bits) - 3;
          return (0, leb128_1.slebEncode)(-5 - offset);
        };

        _proto22.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          var num = (0, leb128_1.readUIntLE)(b, this._bits / 8);

          if (this._bits <= 32) {
            return Number(num);
          } else {
            return num;
          }
        };

        _proto22.valueToString = function valueToString(x) {
          return x.toString();
        };

        _createClass(FixedNatClass, [{
          key: "name",
          get: function get() {
            return "nat" + this._bits;
          }
        }]);

        return FixedNatClass;
      }(PrimitiveType);

      exports.FixedNatClass = FixedNatClass;

      var VecClass = /*#__PURE__*/function (_ConstructType) {
        _inheritsLoose(_VecClass, _ConstructType);

        function _VecClass(_type) {
          var _this16;

          _this16 = _ConstructType.call(this) || this;
          _this16._type = _type;
          _this16._blobOptimization = false;

          if (_type instanceof FixedNatClass && _type._bits === 8) {
            _this16._blobOptimization = true;
          }

          return _this16;
        }

        var _proto23 = _VecClass.prototype;

        _proto23.accept = function accept(v, d) {
          return v.visitVec(this, this._type, d);
        };

        _proto23.covariant = function covariant(x) {
          var _this17 = this;

          var bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;
          if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every(function (v, idx) {
            try {
              return _this17._type.covariant(v);
            } catch (e) {
              throw new Error("Invalid " + _this17.display() + " argument: \n\nindex " + idx + " -> " + e.message);
            }
          })) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto23.encodeValue = function encodeValue(x) {
          var len = (0, leb128_1.lebEncode)(x.length);

          if (this._blobOptimization) {
            return (0, buffer_1.concat)(len, new Uint8Array(x));
          }

          if (ArrayBuffer.isView(x)) {
            return (0, buffer_1.concat)(len, new Uint8Array(x.buffer));
          }

          var buf = new buffer_1.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);
          buf.write(len);

          for (var _iterator4 = _createForOfIteratorHelperLoose(x), _step4; !(_step4 = _iterator4()).done;) {
            var d = _step4.value;

            var encoded = this._type.encodeValue(d);

            buf.write(new Uint8Array(encoded));
          }

          return buf.buffer;
        };

        _proto23._buildTypeTableImpl = function _buildTypeTableImpl(typeTable) {
          this._type.buildTypeTable(typeTable);

          var opCode = (0, leb128_1.slebEncode)(-19
          /* IDLTypeIds.Vector */
          );

          var buffer = this._type.encodeType(typeTable);

          typeTable.add(this, (0, buffer_1.concat)(opCode, buffer));
        };

        _proto23.decodeValue = function decodeValue(b, t) {
          var vec = this.checkType(t);

          if (!(vec instanceof _VecClass)) {
            throw new Error("Not a vector type");
          }

          var len = Number((0, leb128_1.lebDecode)(b));

          if (this._type instanceof FixedNatClass) {
            if (this._type._bits == 8) {
              return new Uint8Array(b.read(len));
            }

            if (this._type._bits == 16) {
              return new Uint16Array(b.read(len * 2));
            }

            if (this._type._bits == 32) {
              return new Uint32Array(b.read(len * 4));
            }

            if (this._type._bits == 64) {
              return new BigUint64Array(b.read(len * 8));
            }
          }

          if (this._type instanceof FixedIntClass) {
            if (this._type._bits == 8) {
              return new Int8Array(b.read(len));
            }

            if (this._type._bits == 16) {
              return new Int16Array(b.read(len * 2));
            }

            if (this._type._bits == 32) {
              return new Int32Array(b.read(len * 4));
            }

            if (this._type._bits == 64) {
              return new BigInt64Array(b.read(len * 8));
            }
          }

          var rets = [];

          for (var i = 0; i < len; i++) {
            rets.push(this._type.decodeValue(b, vec._type));
          }

          return rets;
        };

        _proto23.display = function display() {
          return "vec " + this._type.display();
        };

        _proto23.valueToString = function valueToString(x) {
          var _this18 = this;

          var elements = x.map(function (e) {
            return _this18._type.valueToString(e);
          });
          return "vec {" + elements.join("; ") + "}";
        };

        _createClass(_VecClass, [{
          key: "name",
          get: function get() {
            return "vec " + this._type.name;
          }
        }]);

        return _VecClass;
      }(ConstructType);

      exports.VecClass = VecClass;

      var OptClass = /*#__PURE__*/function (_ConstructType2) {
        _inheritsLoose(_OptClass, _ConstructType2);

        function _OptClass(_type) {
          var _this19;

          _this19 = _ConstructType2.call(this) || this;
          _this19._type = _type;
          return _this19;
        }

        var _proto24 = _OptClass.prototype;

        _proto24.accept = function accept(v, d) {
          return v.visitOpt(this, this._type, d);
        };

        _proto24.covariant = function covariant(x) {
          try {
            if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0]))) return true;
          } catch (e) {
            throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x) + " \n\n-> " + e.message);
          }

          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto24.encodeValue = function encodeValue(x) {
          if (x.length === 0) {
            return new Uint8Array([0]);
          } else {
            return (0, buffer_1.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));
          }
        };

        _proto24._buildTypeTableImpl = function _buildTypeTableImpl(typeTable) {
          this._type.buildTypeTable(typeTable);

          var opCode = (0, leb128_1.slebEncode)(-18
          /* IDLTypeIds.Opt */
          );

          var buffer = this._type.encodeType(typeTable);

          typeTable.add(this, (0, buffer_1.concat)(opCode, buffer));
        };

        _proto24.decodeValue = function decodeValue(b, t) {
          if (t instanceof NullClass) {
            return [];
          }

          if (t instanceof ReservedClass) {
            return [];
          }

          var wireType = t;

          if (t instanceof RecClass) {
            var ty = t.getType();

            if (typeof ty === "undefined") {
              throw new Error("type mismatch with uninitialized type");
            } else wireType = ty;
          }

          if (wireType instanceof _OptClass) {
            switch ((0, leb128_1.safeReadUint8)(b)) {
              case 0:
                return [];

              case 1:
                {
                  var checkpoint = b.save();

                  try {
                    var v = this._type.decodeValue(b, wireType._type);

                    return [v];
                  } catch (e) {
                    b.restore(checkpoint);

                    var skipped = wireType._type.decodeValue(b, wireType._type);

                    return [];
                  }
                }

              default:
                throw new Error("Not an option value");
            }
          } else if (this._type instanceof NullClass || this._type instanceof _OptClass || this._type instanceof ReservedClass) {
            var _skipped = wireType.decodeValue(b, wireType);

            return [];
          } else {
            var _checkpoint = b.save();

            try {
              var _v = this._type.decodeValue(b, t);

              return [_v];
            } catch (e) {
              b.restore(_checkpoint);

              var _skipped2 = wireType.decodeValue(b, t);

              return [];
            }
          }
        };

        _proto24.display = function display() {
          return "opt " + this._type.display();
        };

        _proto24.valueToString = function valueToString(x) {
          if (x.length === 0) {
            return "null";
          } else {
            return "opt " + this._type.valueToString(x[0]);
          }
        };

        _createClass(_OptClass, [{
          key: "name",
          get: function get() {
            return "opt " + this._type.name;
          }
        }]);

        return _OptClass;
      }(ConstructType);

      exports.OptClass = OptClass;

      var RecordClass = /*#__PURE__*/function (_ConstructType3) {
        _inheritsLoose(_RecordClass, _ConstructType3);

        function _RecordClass(fields) {
          var _this20;

          if (fields === void 0) {
            fields = {};
          }

          _this20 = _ConstructType3.call(this) || this;
          _this20._fields = Object.entries(fields).sort(function (a, b) {
            return (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b[0]);
          });
          return _this20;
        }

        var _proto25 = _RecordClass.prototype;

        _proto25.accept = function accept(v, d) {
          return v.visitRecord(this, this._fields, d);
        };

        _proto25.tryAsTuple = function tryAsTuple() {
          var res = [];

          for (var i = 0; i < this._fields.length; i++) {
            var _this$_fields$i = this._fields[i],
                key = _this$_fields$i[0],
                type = _this$_fields$i[1];

            if (key !== "_" + i + "_") {
              return null;
            }

            res.push(type);
          }

          return res;
        };

        _proto25.covariant = function covariant(x) {
          var _this21 = this;

          if (typeof x === "object" && this._fields.every(function (_ref4) {
            var k = _ref4[0],
                t = _ref4[1];

            if (!x.hasOwnProperty(k)) {
              throw new Error("Record is missing key \"" + k + "\".");
            }

            try {
              return t.covariant(x[k]);
            } catch (e) {
              throw new Error("Invalid " + _this21.display() + " argument: \n\nfield " + k + " -> " + e.message);
            }
          })) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto25.encodeValue = function encodeValue(x) {
          var values = this._fields.map(function (_ref5) {
            var key = _ref5[0];
            return x[key];
          });

          var bufs = zipWith(this._fields, values, function (_ref6, d) {
            var c = _ref6[1];
            return c.encodeValue(d);
          });
          return (0, buffer_1.concat).apply(void 0, bufs);
        };

        _proto25._buildTypeTableImpl = function _buildTypeTableImpl(T) {
          this._fields.forEach(function (_ref7) {
            var _ = _ref7[0],
                value = _ref7[1];
            return value.buildTypeTable(T);
          });

          var opCode = (0, leb128_1.slebEncode)(-20
          /* IDLTypeIds.Record */
          );
          var len = (0, leb128_1.lebEncode)(this._fields.length);

          var fields = this._fields.map(function (_ref8) {
            var key = _ref8[0],
                value = _ref8[1];
            return (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value.encodeType(T));
          });

          T.add(this, (0, buffer_1.concat)(opCode, len, (0, buffer_1.concat).apply(void 0, fields)));
        };

        _proto25.decodeValue = function decodeValue(b, t) {
          var record = this.checkType(t);

          if (!(record instanceof _RecordClass)) {
            throw new Error("Not a record type");
          }

          var x = {};
          var expectedRecordIdx = 0;
          var actualRecordIdx = 0;

          while (actualRecordIdx < record._fields.length) {
            var _record$_fields$actua = record._fields[actualRecordIdx],
                hash = _record$_fields$actua[0],
                type = _record$_fields$actua[1];

            if (expectedRecordIdx >= this._fields.length) {
              type.decodeValue(b, type);
              actualRecordIdx++;
              continue;
            }

            var _this$_fields$expecte = this._fields[expectedRecordIdx],
                expectKey = _this$_fields$expecte[0],
                expectType = _this$_fields$expecte[1];
            var expectedId = (0, hash_1.idlLabelToId)(this._fields[expectedRecordIdx][0]);
            var actualId = (0, hash_1.idlLabelToId)(hash);

            if (expectedId === actualId) {
              x[expectKey] = expectType.decodeValue(b, type);
              expectedRecordIdx++;
              actualRecordIdx++;
            } else if (actualId > expectedId) {
              if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
                x[expectKey] = [];
                expectedRecordIdx++;
              } else {
                throw new Error("Cannot find required field " + expectKey);
              }
            } else {
              type.decodeValue(b, type);
              actualRecordIdx++;
            }
          }

          for (var _iterator5 = _createForOfIteratorHelperLoose(this._fields.slice(expectedRecordIdx)), _step5; !(_step5 = _iterator5()).done;) {
            var _step5$value = _step5.value,
                _expectKey = _step5$value[0],
                _expectType = _step5$value[1];

            if (_expectType instanceof OptClass || _expectType instanceof ReservedClass) {
              x[_expectKey] = [];
            } else {
              throw new Error("Cannot find required field " + _expectKey);
            }
          }

          return x;
        };

        _proto25.display = function display() {
          var fields = this._fields.map(function (_ref9) {
            var key = _ref9[0],
                value = _ref9[1];
            return key + ":" + value.display();
          });

          return "record {" + fields.join("; ") + "}";
        };

        _proto25.valueToString = function valueToString(x) {
          var values = this._fields.map(function (_ref10) {
            var key = _ref10[0];
            return x[key];
          });

          var fields = zipWith(this._fields, values, function (_ref11, d) {
            var k = _ref11[0],
                c = _ref11[1];
            return k + "=" + c.valueToString(d);
          });
          return "record {" + fields.join("; ") + "}";
        };

        _createClass(_RecordClass, [{
          key: "name",
          get: function get() {
            var fields = this._fields.map(function (_ref12) {
              var key = _ref12[0],
                  value = _ref12[1];
              return key + ":" + value.name;
            });

            return "record {" + fields.join("; ") + "}";
          }
        }]);

        return _RecordClass;
      }(ConstructType);

      exports.RecordClass = RecordClass;

      var TupleClass = /*#__PURE__*/function (_RecordClass2) {
        _inheritsLoose(_TupleClass, _RecordClass2);

        function _TupleClass(_components) {
          var _this22;

          var x = {};

          _components.forEach(function (e, i) {
            return x["_" + i + "_"] = e;
          });

          _this22 = _RecordClass2.call(this, x) || this;
          _this22._components = _components;
          return _this22;
        }

        var _proto26 = _TupleClass.prototype;

        _proto26.accept = function accept(v, d) {
          return v.visitTuple(this, this._components, d);
        };

        _proto26.covariant = function covariant(x) {
          var _this23 = this;

          if (Array.isArray(x) && x.length >= this._fields.length && this._components.every(function (t, i) {
            try {
              return t.covariant(x[i]);
            } catch (e) {
              throw new Error("Invalid " + _this23.display() + " argument: \n\nindex " + i + " -> " + e.message);
            }
          })) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto26.encodeValue = function encodeValue(x) {
          var bufs = zipWith(this._components, x, function (c, d) {
            return c.encodeValue(d);
          });
          return (0, buffer_1.concat).apply(void 0, bufs);
        };

        _proto26.decodeValue = function decodeValue(b, t) {
          var tuple = this.checkType(t);

          if (!(tuple instanceof _TupleClass)) {
            throw new Error("not a tuple type");
          }

          if (tuple._components.length < this._components.length) {
            throw new Error("tuple mismatch");
          }

          var res = [];

          for (var _iterator6 = _createForOfIteratorHelperLoose(tuple._components.entries()), _step6; !(_step6 = _iterator6()).done;) {
            var _step6$value = _step6.value,
                i = _step6$value[0],
                wireType = _step6$value[1];

            if (i >= this._components.length) {
              wireType.decodeValue(b, wireType);
            } else {
              res.push(this._components[i].decodeValue(b, wireType));
            }
          }

          return res;
        };

        _proto26.display = function display() {
          var fields = this._components.map(function (value) {
            return value.display();
          });

          return "record {" + fields.join("; ") + "}";
        };

        _proto26.valueToString = function valueToString(values) {
          var fields = zipWith(this._components, values, function (c, d) {
            return c.valueToString(d);
          });
          return "record {" + fields.join("; ") + "}";
        };

        return _TupleClass;
      }(RecordClass);

      exports.TupleClass = TupleClass;

      var VariantClass = /*#__PURE__*/function (_ConstructType4) {
        _inheritsLoose(_VariantClass, _ConstructType4);

        function _VariantClass(fields) {
          var _this24;

          if (fields === void 0) {
            fields = {};
          }

          _this24 = _ConstructType4.call(this) || this;
          _this24._fields = Object.entries(fields).sort(function (a, b) {
            return (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b[0]);
          });
          return _this24;
        }

        var _proto27 = _VariantClass.prototype;

        _proto27.accept = function accept(v, d) {
          return v.visitVariant(this, this._fields, d);
        };

        _proto27.covariant = function covariant(x) {
          var _this25 = this;

          if (typeof x === "object" && Object.entries(x).length === 1 && this._fields.every(function (_ref13) {
            var k = _ref13[0],
                v = _ref13[1];

            try {
              return !x.hasOwnProperty(k) || v.covariant(x[k]);
            } catch (e) {
              throw new Error("Invalid " + _this25.display() + " argument: \n\nvariant " + k + " -> " + e.message);
            }
          })) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto27.encodeValue = function encodeValue(x) {
          for (var i = 0; i < this._fields.length; i++) {
            var _this$_fields$i2 = this._fields[i],
                name = _this$_fields$i2[0],
                type = _this$_fields$i2[1];

            if (x.hasOwnProperty(name)) {
              var idx = (0, leb128_1.lebEncode)(i);
              var buf = type.encodeValue(x[name]);
              return (0, buffer_1.concat)(idx, buf);
            }
          }

          throw Error("Variant has no data: " + x);
        };

        _proto27._buildTypeTableImpl = function _buildTypeTableImpl(typeTable) {
          this._fields.forEach(function (_ref14) {
            var type = _ref14[1];
            type.buildTypeTable(typeTable);
          });

          var opCode = (0, leb128_1.slebEncode)(-21
          /* IDLTypeIds.Variant */
          );
          var len = (0, leb128_1.lebEncode)(this._fields.length);

          var fields = this._fields.map(function (_ref15) {
            var key = _ref15[0],
                value = _ref15[1];
            return (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value.encodeType(typeTable));
          });

          typeTable.add(this, (0, buffer_1.concat).apply(void 0, [opCode, len].concat(fields)));
        };

        _proto27.decodeValue = function decodeValue(b, t) {
          var variant = this.checkType(t);

          if (!(variant instanceof _VariantClass)) {
            throw new Error("Not a variant type");
          }

          var idx = Number((0, leb128_1.lebDecode)(b));

          if (idx >= variant._fields.length) {
            throw Error("Invalid variant index: " + idx);
          }

          var _variant$_fields$idx = variant._fields[idx],
              wireHash = _variant$_fields$idx[0],
              wireType = _variant$_fields$idx[1];

          for (var _iterator7 = _createForOfIteratorHelperLoose(this._fields), _step7; !(_step7 = _iterator7()).done;) {
            var _step7$value = _step7.value,
                key = _step7$value[0],
                expectType = _step7$value[1];

            if ((0, hash_1.idlLabelToId)(wireHash) === (0, hash_1.idlLabelToId)(key)) {
              var _ref16;

              var value = expectType.decodeValue(b, wireType);
              return _ref16 = {}, _ref16[key] = value, _ref16;
            }
          }

          throw new Error("Cannot find field hash " + wireHash);
        };

        _proto27.display = function display() {
          var fields = this._fields.map(function (_ref17) {
            var key = _ref17[0],
                type = _ref17[1];
            return key + (type.name === "null" ? "" : ":" + type.display());
          });

          return "variant {" + fields.join("; ") + "}";
        };

        _proto27.valueToString = function valueToString(x) {
          for (var _iterator8 = _createForOfIteratorHelperLoose(this._fields), _step8; !(_step8 = _iterator8()).done;) {
            var _step8$value = _step8.value,
                name = _step8$value[0],
                type = _step8$value[1];

            if (x.hasOwnProperty(name)) {
              var value = type.valueToString(x[name]);

              if (value === "null") {
                return "variant {" + name + "}";
              } else {
                return "variant {" + name + "=" + value + "}";
              }
            }
          }

          throw new Error("Variant has no data: " + x);
        };

        _createClass(_VariantClass, [{
          key: "name",
          get: function get() {
            var fields = this._fields.map(function (_ref18) {
              var key = _ref18[0],
                  type = _ref18[1];
              return key + ":" + type.name;
            });

            return "variant {" + fields.join("; ") + "}";
          }
        }]);

        return _VariantClass;
      }(ConstructType);

      exports.VariantClass = VariantClass;

      var RecClass = /*#__PURE__*/function (_ConstructType5) {
        _inheritsLoose(_RecClass, _ConstructType5);

        function _RecClass() {
          var _this26;

          _this26 = _ConstructType5.apply(this, arguments) || this;
          _this26._id = _RecClass._counter++;
          _this26._type = void 0;
          return _this26;
        }

        var _proto28 = _RecClass.prototype;

        _proto28.accept = function accept(v, d) {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          return v.visitRec(this, this._type, d);
        };

        _proto28.fill = function fill(t) {
          this._type = t;
        };

        _proto28.getType = function getType() {
          return this._type;
        };

        _proto28.covariant = function covariant(x) {
          if (this._type ? this._type.covariant(x) : false) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto28.encodeValue = function encodeValue(x) {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          return this._type.encodeValue(x);
        };

        _proto28._buildTypeTableImpl = function _buildTypeTableImpl(typeTable) {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          typeTable.add(this, new Uint8Array([]));

          this._type.buildTypeTable(typeTable);

          typeTable.merge(this, this._type.name);
        };

        _proto28.decodeValue = function decodeValue(b, t) {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          return this._type.decodeValue(b, t);
        };

        _proto28.display = function display() {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          return "\u03BC" + this.name + "." + this._type.name;
        };

        _proto28.valueToString = function valueToString(x) {
          if (!this._type) {
            throw Error("Recursive type uninitialized.");
          }

          return this._type.valueToString(x);
        };

        _createClass(_RecClass, [{
          key: "name",
          get: function get() {
            return "rec_" + this._id;
          }
        }]);

        return _RecClass;
      }(ConstructType);

      exports.RecClass = RecClass;
      RecClass._counter = 0;

      function decodePrincipalId(b) {
        var x = (0, leb128_1.safeReadUint8)(b);

        if (x !== 1) {
          throw new Error("Cannot decode principal");
        }

        var len = Number((0, leb128_1.lebDecode)(b));
        return principal_1.Principal.fromUint8Array(new Uint8Array((0, leb128_1.safeRead)(b, len)));
      }

      var PrincipalClass = /*#__PURE__*/function (_PrimitiveType11) {
        _inheritsLoose(PrincipalClass, _PrimitiveType11);

        function PrincipalClass() {
          return _PrimitiveType11.apply(this, arguments) || this;
        }

        var _proto29 = PrincipalClass.prototype;

        _proto29.accept = function accept(v, d) {
          return v.visitPrincipal(this, d);
        };

        _proto29.covariant = function covariant(x) {
          if (x && x._isPrincipal) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto29.encodeValue = function encodeValue(x) {
          var buf = x.toUint8Array();
          var len = (0, leb128_1.lebEncode)(buf.byteLength);
          return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
        };

        _proto29.encodeType = function encodeType() {
          return (0, leb128_1.slebEncode)(-24
          /* IDLTypeIds.Principal */
          );
        };

        _proto29.decodeValue = function decodeValue(b, t) {
          this.checkType(t);
          return decodePrincipalId(b);
        };

        _proto29.valueToString = function valueToString(x) {
          return this.name + " \"" + x.toText() + "\"";
        };

        _createClass(PrincipalClass, [{
          key: "name",
          get: function get() {
            return "principal";
          }
        }]);

        return PrincipalClass;
      }(PrimitiveType);

      exports.PrincipalClass = PrincipalClass;

      var FuncClass = /*#__PURE__*/function (_ConstructType6) {
        _inheritsLoose(FuncClass, _ConstructType6);

        function FuncClass(argTypes, retTypes, annotations) {
          var _this27;

          if (annotations === void 0) {
            annotations = [];
          }

          _this27 = _ConstructType6.call(this) || this;
          _this27.argTypes = argTypes;
          _this27.retTypes = retTypes;
          _this27.annotations = annotations;
          return _this27;
        }

        FuncClass.argsToString = function argsToString(types, v) {
          if (types.length !== v.length) {
            throw new Error("arity mismatch");
          }

          return "(" + types.map(function (t, i) {
            return t.valueToString(v[i]);
          }).join(", ") + ")";
        };

        var _proto30 = FuncClass.prototype;

        _proto30.accept = function accept(v, d) {
          return v.visitFunc(this, d);
        };

        _proto30.covariant = function covariant(x) {
          if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === "string") return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto30.encodeValue = function encodeValue(_ref19) {
          var principal = _ref19[0],
              methodName = _ref19[1];
          var buf = principal.toUint8Array();
          var len = (0, leb128_1.lebEncode)(buf.byteLength);
          var canister = (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
          var method = new TextEncoder().encode(methodName);
          var methodLen = (0, leb128_1.lebEncode)(method.byteLength);
          return (0, buffer_1.concat)(new Uint8Array([1]), canister, methodLen, method);
        };

        _proto30._buildTypeTableImpl = function _buildTypeTableImpl(T) {
          var _this28 = this;

          this.argTypes.forEach(function (arg) {
            return arg.buildTypeTable(T);
          });
          this.retTypes.forEach(function (arg) {
            return arg.buildTypeTable(T);
          });
          var opCode = (0, leb128_1.slebEncode)(-22
          /* IDLTypeIds.Func */
          );
          var argLen = (0, leb128_1.lebEncode)(this.argTypes.length);
          var args = (0, buffer_1.concat).apply(void 0, this.argTypes.map(function (arg) {
            return arg.encodeType(T);
          }));
          var retLen = (0, leb128_1.lebEncode)(this.retTypes.length);
          var rets = (0, buffer_1.concat).apply(void 0, this.retTypes.map(function (arg) {
            return arg.encodeType(T);
          }));
          var annLen = (0, leb128_1.lebEncode)(this.annotations.length);
          var anns = (0, buffer_1.concat).apply(void 0, this.annotations.map(function (a) {
            return _this28.encodeAnnotation(a);
          }));
          T.add(this, (0, buffer_1.concat)(opCode, argLen, args, retLen, rets, annLen, anns));
        };

        _proto30.decodeValue = function decodeValue(b) {
          var x = (0, leb128_1.safeReadUint8)(b);

          if (x !== 1) {
            throw new Error("Cannot decode function reference");
          }

          var canister = decodePrincipalId(b);
          var mLen = Number((0, leb128_1.lebDecode)(b));
          var buf = (0, leb128_1.safeRead)(b, mLen);
          var decoder = new TextDecoder("utf8", {
            fatal: true
          });
          var method = decoder.decode(buf);
          return [canister, method];
        };

        _proto30.valueToString = function valueToString(_ref20) {
          var principal = _ref20[0],
              str = _ref20[1];
          return "func \"" + principal.toText() + "\"." + str;
        };

        _proto30.display = function display() {
          var args = this.argTypes.map(function (arg) {
            return arg.display();
          }).join(", ");
          var rets = this.retTypes.map(function (arg) {
            return arg.display();
          }).join(", ");
          var annon = " " + this.annotations.join(" ");
          return "(" + args + ") \u2192 (" + rets + ")" + annon;
        };

        _proto30.encodeAnnotation = function encodeAnnotation(ann) {
          if (ann === "query") {
            return new Uint8Array([1]);
          } else if (ann === "oneway") {
            return new Uint8Array([2]);
          } else if (ann === "composite_query") {
            return new Uint8Array([3]);
          } else {
            throw new Error("Illegal function annotation");
          }
        };

        _createClass(FuncClass, [{
          key: "name",
          get: function get() {
            var args = this.argTypes.map(function (arg) {
              return arg.name;
            }).join(", ");
            var rets = this.retTypes.map(function (arg) {
              return arg.name;
            }).join(", ");
            var annon = " " + this.annotations.join(" ");
            return "(" + args + ") -> (" + rets + ")" + annon;
          }
        }]);

        return FuncClass;
      }(ConstructType);

      exports.FuncClass = FuncClass;

      var ServiceClass = /*#__PURE__*/function (_ConstructType7) {
        _inheritsLoose(ServiceClass, _ConstructType7);

        function ServiceClass(fields) {
          var _this29;

          _this29 = _ConstructType7.call(this) || this;
          _this29._fields = Object.entries(fields).sort(function (a, b) {
            if (a[0] < b[0]) {
              return -1;
            }

            if (a[0] > b[0]) {
              return 1;
            }

            return 0;
          });
          return _this29;
        }

        var _proto31 = ServiceClass.prototype;

        _proto31.accept = function accept(v, d) {
          return v.visitService(this, d);
        };

        _proto31.covariant = function covariant(x) {
          if (x && x._isPrincipal) return true;
          throw new Error("Invalid " + this.display() + " argument: " + toReadableString(x));
        };

        _proto31.encodeValue = function encodeValue(x) {
          var buf = x.toUint8Array();
          var len = (0, leb128_1.lebEncode)(buf.length);
          return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
        };

        _proto31._buildTypeTableImpl = function _buildTypeTableImpl(T) {
          this._fields.forEach(function (_ref21) {
            var _ = _ref21[0],
                func = _ref21[1];
            return func.buildTypeTable(T);
          });

          var opCode = (0, leb128_1.slebEncode)(-23
          /* IDLTypeIds.Service */
          );
          var len = (0, leb128_1.lebEncode)(this._fields.length);

          var meths = this._fields.map(function (_ref22) {
            var label = _ref22[0],
                func = _ref22[1];
            var labelBuf = new TextEncoder().encode(label);
            var labelLen = (0, leb128_1.lebEncode)(labelBuf.length);
            return (0, buffer_1.concat)(labelLen, labelBuf, func.encodeType(T));
          });

          T.add(this, (0, buffer_1.concat).apply(void 0, [opCode, len].concat(meths)));
        };

        _proto31.decodeValue = function decodeValue(b) {
          return decodePrincipalId(b);
        };

        _proto31.valueToString = function valueToString(x) {
          return "service \"" + x.toText() + "\"";
        };

        _createClass(ServiceClass, [{
          key: "name",
          get: function get() {
            var fields = this._fields.map(function (_ref23) {
              var key = _ref23[0],
                  value = _ref23[1];
              return key + ":" + value.name;
            });

            return "service {" + fields.join("; ") + "}";
          }
        }]);

        return ServiceClass;
      }(ConstructType);

      exports.ServiceClass = ServiceClass;

      function toReadableString(x) {
        var str = JSON.stringify(x, function (_key, value) {
          return typeof value === "bigint" ? "BigInt(" + value + ")" : value;
        });
        return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + "..." : str;
      }

      function encode(argTypes, args) {
        if (args.length < argTypes.length) {
          throw Error("Wrong number of message arguments");
        }

        var typeTable = new TypeTable();
        argTypes.forEach(function (t) {
          return t.buildTypeTable(typeTable);
        });
        var magic = new TextEncoder().encode(magicNumber);
        var table = typeTable.encode();
        var len = (0, leb128_1.lebEncode)(args.length);
        var typs = (0, buffer_1.concat).apply(void 0, argTypes.map(function (t) {
          return t.encodeType(typeTable);
        }));
        var vals = (0, buffer_1.concat).apply(void 0, zipWith(argTypes, args, function (t, x) {
          try {
            t.covariant(x);
          } catch (e) {
            var err = new Error(e.message + "\n\n");
            throw err;
          }

          return t.encodeValue(x);
        }));
        return (0, buffer_1.concat)(magic, table, len, typs, vals);
      }

      exports.encode = encode;

      function decode(retTypes, bytes) {
        var b = new buffer_1.PipeArrayBuffer(bytes);

        if (bytes.byteLength < magicNumber.length) {
          throw new Error("Message length smaller than magic number");
        }

        var magicBuffer = (0, leb128_1.safeRead)(b, magicNumber.length);
        var magic = new TextDecoder().decode(magicBuffer);

        if (magic !== magicNumber) {
          throw new Error("Wrong magic number: " + JSON.stringify(magic));
        }

        function readTypeTable(pipe) {
          var typeTable = [];
          var len = Number((0, leb128_1.lebDecode)(pipe));

          for (var i = 0; i < len; i++) {
            var ty = Number((0, leb128_1.slebDecode)(pipe));

            switch (ty) {
              case -18:
              case -19:
                {
                  var t = Number((0, leb128_1.slebDecode)(pipe));
                  typeTable.push([ty, t]);
                  break;
                }

              case -20:
              case -21:
                {
                  var fields = [];
                  var objectLength = Number((0, leb128_1.lebDecode)(pipe));
                  var prevHash = void 0;

                  while (objectLength--) {
                    var hash = Number((0, leb128_1.lebDecode)(pipe));

                    if (hash >= Math.pow(2, 32)) {
                      throw new Error("field id out of 32-bit range");
                    }

                    if (typeof prevHash === "number" && prevHash >= hash) {
                      throw new Error("field id collision or not sorted");
                    }

                    prevHash = hash;

                    var _t = Number((0, leb128_1.slebDecode)(pipe));

                    fields.push([hash, _t]);
                  }

                  typeTable.push([ty, fields]);
                  break;
                }

              case -22:
                {
                  var args = [];
                  var argLength = Number((0, leb128_1.lebDecode)(pipe));

                  while (argLength--) {
                    args.push(Number((0, leb128_1.slebDecode)(pipe)));
                  }

                  var returnValues = [];
                  var returnValuesLength = Number((0, leb128_1.lebDecode)(pipe));

                  while (returnValuesLength--) {
                    returnValues.push(Number((0, leb128_1.slebDecode)(pipe)));
                  }

                  var annotations = [];
                  var annotationLength = Number((0, leb128_1.lebDecode)(pipe));

                  while (annotationLength--) {
                    var annotation = Number((0, leb128_1.lebDecode)(pipe));

                    switch (annotation) {
                      case 1:
                        {
                          annotations.push("query");
                          break;
                        }

                      case 2:
                        {
                          annotations.push("oneway");
                          break;
                        }

                      case 3:
                        {
                          annotations.push("composite_query");
                          break;
                        }

                      default:
                        throw new Error("unknown annotation");
                    }
                  }

                  typeTable.push([ty, [args, returnValues, annotations]]);
                  break;
                }

              case -23:
                {
                  var servLength = Number((0, leb128_1.lebDecode)(pipe));
                  var methods = [];

                  while (servLength--) {
                    var nameLength = Number((0, leb128_1.lebDecode)(pipe));
                    var funcName = new TextDecoder().decode((0, leb128_1.safeRead)(pipe, nameLength));
                    var funcType = (0, leb128_1.slebDecode)(pipe);
                    methods.push([funcName, funcType]);
                  }

                  typeTable.push([ty, methods]);
                  break;
                }

              default:
                throw new Error("Illegal op_code: " + ty);
            }
          }

          var rawList = [];
          var length = Number((0, leb128_1.lebDecode)(pipe));

          for (var _i8 = 0; _i8 < length; _i8++) {
            rawList.push(Number((0, leb128_1.slebDecode)(pipe)));
          }

          return [typeTable, rawList];
        }

        var _readTypeTable = readTypeTable(b),
            rawTable = _readTypeTable[0],
            rawTypes = _readTypeTable[1];

        if (rawTypes.length < retTypes.length) {
          throw new Error("Wrong number of return values");
        }

        var table = rawTable.map(function (_) {
          return Rec();
        });

        function getType(t) {
          if (t < -24) {
            throw new Error("future value not supported");
          }

          if (t < 0) {
            switch (t) {
              case -1:
                return exports.Null;

              case -2:
                return exports.Bool;

              case -3:
                return exports.Nat;

              case -4:
                return exports.Int;

              case -5:
                return exports.Nat8;

              case -6:
                return exports.Nat16;

              case -7:
                return exports.Nat32;

              case -8:
                return exports.Nat64;

              case -9:
                return exports.Int8;

              case -10:
                return exports.Int16;

              case -11:
                return exports.Int32;

              case -12:
                return exports.Int64;

              case -13:
                return exports.Float32;

              case -14:
                return exports.Float64;

              case -15:
                return exports.Text;

              case -16:
                return exports.Reserved;

              case -17:
                return exports.Empty;

              case -24:
                return exports.Principal;

              default:
                throw new Error("Illegal op_code: " + t);
            }
          }

          if (t >= rawTable.length) {
            throw new Error("type index out of range");
          }

          return table[t];
        }

        function buildType(entry) {
          switch (entry[0]) {
            case -19:
              {
                var ty = getType(entry[1]);
                return Vec(ty);
              }

            case -18:
              {
                var _ty = getType(entry[1]);

                return Opt(_ty);
              }

            case -20:
              {
                var fields = {};

                for (var _iterator9 = _createForOfIteratorHelperLoose(entry[1]), _step9; !(_step9 = _iterator9()).done;) {
                  var _step9$value = _step9.value,
                      hash = _step9$value[0],
                      _ty2 = _step9$value[1];
                  var name = "_" + hash + "_";
                  fields[name] = getType(_ty2);
                }

                var record = Record(fields);
                var tuple = record.tryAsTuple();

                if (Array.isArray(tuple)) {
                  return Tuple.apply(void 0, tuple);
                } else {
                  return record;
                }
              }

            case -21:
              {
                var _fields = {};

                for (var _iterator10 = _createForOfIteratorHelperLoose(entry[1]), _step10; !(_step10 = _iterator10()).done;) {
                  var _step10$value = _step10.value,
                      _hash = _step10$value[0],
                      _ty3 = _step10$value[1];

                  var _name = "_" + _hash + "_";

                  _fields[_name] = getType(_ty3);
                }

                return Variant(_fields);
              }

            case -22:
              {
                var _entry$ = entry[1],
                    args = _entry$[0],
                    returnValues = _entry$[1],
                    annotations = _entry$[2];
                return Func(args.map(function (t) {
                  return getType(t);
                }), returnValues.map(function (t) {
                  return getType(t);
                }), annotations);
              }

            case -23:
              {
                var rec = {};
                var methods = entry[1];

                for (var _iterator11 = _createForOfIteratorHelperLoose(methods), _step11; !(_step11 = _iterator11()).done;) {
                  var _step11$value = _step11.value,
                      _name2 = _step11$value[0],
                      typeRef = _step11$value[1];
                  var type = getType(typeRef);

                  if (type instanceof RecClass) {
                    type = type.getType();
                  }

                  if (!(type instanceof FuncClass)) {
                    throw new Error("Illegal service definition: services can only contain functions");
                  }

                  rec[_name2] = type;
                }

                return Service(rec);
              }

            default:
              throw new Error("Illegal op_code: " + entry[0]);
          }
        }

        rawTable.forEach(function (entry, i) {
          if (entry[0] === -22) {
            var t = buildType(entry);
            table[i].fill(t);
          }
        });
        rawTable.forEach(function (entry, i) {
          if (entry[0] !== -22) {
            var t = buildType(entry);
            table[i].fill(t);
          }
        });
        var types = rawTypes.map(function (t) {
          return getType(t);
        });
        var output = retTypes.map(function (t, i) {
          return t.decodeValue(b, types[i]);
        });

        for (var ind = retTypes.length; ind < types.length; ind++) {
          types[ind].decodeValue(b, types[ind]);
        }

        if (b.byteLength > 0) {
          throw new Error("decode: Left-over bytes");
        }

        return output;
      }

      exports.decode = decode;
      exports.Empty = new EmptyClass();
      exports.Reserved = new ReservedClass();
      exports.Unknown = new UnknownClass();
      exports.Bool = new BoolClass();
      exports.Null = new NullClass();
      exports.Text = new TextClass();
      exports.Int = new IntClass();
      exports.Nat = new NatClass();
      exports.Float32 = new FloatClass(32);
      exports.Float64 = new FloatClass(64);
      exports.Int8 = new FixedIntClass(8);
      exports.Int16 = new FixedIntClass(16);
      exports.Int32 = new FixedIntClass(32);
      exports.Int64 = new FixedIntClass(64);
      exports.Nat8 = new FixedNatClass(8);
      exports.Nat16 = new FixedNatClass(16);
      exports.Nat32 = new FixedNatClass(32);
      exports.Nat64 = new FixedNatClass(64);
      exports.Principal = new PrincipalClass();

      function Tuple() {
        for (var _len5 = arguments.length, types = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
          types[_key6] = arguments[_key6];
        }

        return new TupleClass(types);
      }

      exports.Tuple = Tuple;

      function Vec(t) {
        return new VecClass(t);
      }

      exports.Vec = Vec;

      function Opt(t) {
        return new OptClass(t);
      }

      exports.Opt = Opt;

      function Record(t) {
        return new RecordClass(t);
      }

      exports.Record = Record;

      function Variant(fields) {
        return new VariantClass(fields);
      }

      exports.Variant = Variant;

      function Rec() {
        return new RecClass();
      }

      exports.Rec = Rec;

      function Func(args, ret, annotations) {
        if (annotations === void 0) {
          annotations = [];
        }

        return new FuncClass(args, ret, annotations);
      }

      exports.Func = Func;

      function Service(t) {
        return new ServiceClass(t);
      }

      exports.Service = Service;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/candid-core.js


  var require_candid_core = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/candid-core.js": function node_modulesDfinityCandidLibCjsCandidCoreJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VecForm = exports.OptionForm = exports.VariantForm = exports.TupleForm = exports.RecordForm = exports.InputForm = exports.InputBox = void 0;

      var InputBox = /*#__PURE__*/function () {
        function InputBox(idl, ui) {
          var _this30 = this;

          this.idl = idl;
          this.ui = ui;
          this.label = null;
          this.value = void 0;
          var status = document.createElement("span");
          status.className = "status";
          this.status = status;

          if (ui.input) {
            ui.input.addEventListener("blur", function () {
              if (ui.input.value === "") {
                return;
              }

              _this30.parse();
            });
            ui.input.addEventListener("input", function () {
              status.style.display = "none";
              ui.input.classList.remove("reject");
            });
          }
        }

        var _proto32 = InputBox.prototype;

        _proto32.isRejected = function isRejected() {
          return this.value === void 0;
        };

        _proto32.parse = function parse(config) {
          if (config === void 0) {
            config = {};
          }

          if (this.ui.form) {
            var value = this.ui.form.parse(config);
            this.value = value;
            return value;
          }

          if (this.ui.input) {
            var input = this.ui.input;

            try {
              var _value = this.ui.parse(this.idl, config, input.value);

              if (!this.idl.covariant(_value)) {
                throw new Error(input.value + " is not of type " + this.idl.display());
              }

              this.status.style.display = "none";
              this.value = _value;
              return _value;
            } catch (err) {
              input.classList.add("reject");
              this.status.style.display = "block";
              this.status.innerHTML = "InputError: " + err.message;
              this.value = void 0;
              return void 0;
            }
          }

          return null;
        };

        _proto32.render = function render(dom) {
          var container = document.createElement("span");

          if (this.label) {
            var label = document.createElement("label");
            label.innerText = this.label;
            container.appendChild(label);
          }

          if (this.ui.input) {
            container.appendChild(this.ui.input);
            container.appendChild(this.status);
          }

          if (this.ui.form) {
            this.ui.form.render(container);
          }

          dom.appendChild(container);
        };

        return InputBox;
      }();

      exports.InputBox = InputBox;

      var InputForm = /*#__PURE__*/function () {
        function InputForm(ui) {
          this.ui = ui;
          this.form = [];
        }

        var _proto33 = InputForm.prototype;

        _proto33.renderForm = function renderForm(dom) {
          var _this31 = this;

          if (this.ui.container) {
            this.form.forEach(function (e) {
              return e.render(_this31.ui.container);
            });
            dom.appendChild(this.ui.container);
          } else {
            this.form.forEach(function (e) {
              return e.render(dom);
            });
          }
        };

        _proto33.render = function render(dom) {
          if (this.ui.open && this.ui.event) {
            dom.appendChild(this.ui.open);
            var form = this;
            form.ui.open.addEventListener(form.ui.event, function () {
              if (form.ui.container) {
                form.ui.container.innerHTML = "";
              } else {
                var oldContainer = form.ui.open.nextElementSibling;

                if (oldContainer) {
                  oldContainer.parentNode.removeChild(oldContainer);
                }
              }

              form.generateForm();
              form.renderForm(dom);
            });
          } else {
            this.generateForm();
            this.renderForm(dom);
          }
        };

        return InputForm;
      }();

      exports.InputForm = InputForm;

      var RecordForm = /*#__PURE__*/function (_InputForm) {
        _inheritsLoose(RecordForm, _InputForm);

        function RecordForm(fields, ui) {
          var _this32;

          _this32 = _InputForm.call(this, ui) || this;
          _this32.fields = fields;
          _this32.ui = ui;
          return _this32;
        }

        var _proto34 = RecordForm.prototype;

        _proto34.generateForm = function generateForm() {
          var _this33 = this;

          this.form = this.fields.map(function (_ref24) {
            var key = _ref24[0],
                type = _ref24[1];

            var input = _this33.ui.render(type);

            if (_this33.ui.labelMap && _this33.ui.labelMap.hasOwnProperty(key)) {
              input.label = _this33.ui.labelMap[key] + " ";
            } else {
              input.label = key + " ";
            }

            return input;
          });
        };

        _proto34.parse = function parse(config) {
          var _this34 = this;

          var v = {};
          this.fields.forEach(function (_ref25, i) {
            var key = _ref25[0],
                _ = _ref25[1];

            var value = _this34.form[i].parse(config);

            v[key] = value;
          });

          if (this.form.some(function (input) {
            return input.isRejected();
          })) {
            return void 0;
          }

          return v;
        };

        return RecordForm;
      }(InputForm);

      exports.RecordForm = RecordForm;

      var TupleForm = /*#__PURE__*/function (_InputForm2) {
        _inheritsLoose(TupleForm, _InputForm2);

        function TupleForm(components, ui) {
          var _this35;

          _this35 = _InputForm2.call(this, ui) || this;
          _this35.components = components;
          _this35.ui = ui;
          return _this35;
        }

        var _proto35 = TupleForm.prototype;

        _proto35.generateForm = function generateForm() {
          var _this36 = this;

          this.form = this.components.map(function (type) {
            var input = _this36.ui.render(type);

            return input;
          });
        };

        _proto35.parse = function parse(config) {
          var _this37 = this;

          var v = [];
          this.components.forEach(function (_, i) {
            var value = _this37.form[i].parse(config);

            v.push(value);
          });

          if (this.form.some(function (input) {
            return input.isRejected();
          })) {
            return void 0;
          }

          return v;
        };

        return TupleForm;
      }(InputForm);

      exports.TupleForm = TupleForm;

      var VariantForm = /*#__PURE__*/function (_InputForm3) {
        _inheritsLoose(VariantForm, _InputForm3);

        function VariantForm(fields, ui) {
          var _this38;

          _this38 = _InputForm3.call(this, ui) || this;
          _this38.fields = fields;
          _this38.ui = ui;
          return _this38;
        }

        var _proto36 = VariantForm.prototype;

        _proto36.generateForm = function generateForm() {
          var index = this.ui.open.selectedIndex;
          var _this$fields$index = this.fields[index],
              _ = _this$fields$index[0],
              type = _this$fields$index[1];
          var variant = this.ui.render(type);
          this.form = [variant];
        };

        _proto36.parse = function parse(config) {
          var select = this.ui.open;
          var selected = select.options[select.selectedIndex].value;
          var value = this.form[0].parse(config);

          if (value === void 0) {
            return void 0;
          }

          var v = {};
          v[selected] = value;
          return v;
        };

        return VariantForm;
      }(InputForm);

      exports.VariantForm = VariantForm;

      var OptionForm = /*#__PURE__*/function (_InputForm4) {
        _inheritsLoose(OptionForm, _InputForm4);

        function OptionForm(ty, ui) {
          var _this39;

          _this39 = _InputForm4.call(this, ui) || this;
          _this39.ty = ty;
          _this39.ui = ui;
          return _this39;
        }

        var _proto37 = OptionForm.prototype;

        _proto37.generateForm = function generateForm() {
          if (this.ui.open.checked) {
            var opt = this.ui.render(this.ty);
            this.form = [opt];
          } else {
            this.form = [];
          }
        };

        _proto37.parse = function parse(config) {
          if (this.form.length === 0) {
            return [];
          } else {
            var value = this.form[0].parse(config);

            if (value === void 0) {
              return void 0;
            }

            return [value];
          }
        };

        return OptionForm;
      }(InputForm);

      exports.OptionForm = OptionForm;

      var VecForm = /*#__PURE__*/function (_InputForm5) {
        _inheritsLoose(VecForm, _InputForm5);

        function VecForm(ty, ui) {
          var _this40;

          _this40 = _InputForm5.call(this, ui) || this;
          _this40.ty = ty;
          _this40.ui = ui;
          return _this40;
        }

        var _proto38 = VecForm.prototype;

        _proto38.generateForm = function generateForm() {
          var len = +this.ui.open.value;
          this.form = [];

          for (var i = 0; i < len; i++) {
            var t = this.ui.render(this.ty);
            this.form.push(t);
          }
        };

        _proto38.parse = function parse(config) {
          var value = this.form.map(function (input) {
            return input.parse(config);
          });

          if (this.form.some(function (input) {
            return input.isRejected();
          })) {
            return void 0;
          }

          return value;
        };

        return VecForm;
      }(InputForm);

      exports.VecForm = VecForm;
    }
  }); // node_modules/@dfinity/candid/lib/cjs/candid-ui.js


  var require_candid_ui = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/candid-ui.js": function node_modulesDfinityCandidLibCjsCandidUiJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.renderValue = exports.renderInput = exports.Render = exports.vecForm = exports.optForm = exports.variantForm = exports.tupleForm = exports.recordForm = exports.inputBox = void 0;

      var IDL = __importStar(require_idl());

      var principal_1 = require_cjs();

      var UI = __importStar(require_candid_core());

      var InputConfig = {
        parse: parsePrimitive
      };
      var FormConfig = {
        render: renderInput
      };

      var inputBox = function inputBox(t, config) {
        return new UI.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));
      };

      exports.inputBox = inputBox;

      var recordForm = function recordForm(fields, config) {
        return new UI.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));
      };

      exports.recordForm = recordForm;

      var tupleForm = function tupleForm(components, config) {
        return new UI.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));
      };

      exports.tupleForm = tupleForm;

      var variantForm = function variantForm(fields, config) {
        return new UI.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));
      };

      exports.variantForm = variantForm;

      var optForm = function optForm(ty, config) {
        return new UI.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));
      };

      exports.optForm = optForm;

      var vecForm = function vecForm(ty, config) {
        return new UI.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));
      };

      exports.vecForm = vecForm;

      var Render = /*#__PURE__*/function (_IDL$Visitor) {
        _inheritsLoose(Render, _IDL$Visitor);

        function Render() {
          return _IDL$Visitor.apply(this, arguments) || this;
        }

        var _proto39 = Render.prototype;

        _proto39.visitType = function visitType(t, d) {
          var input = document.createElement("input");
          input.classList.add("argument");
          input.placeholder = t.display();
          return (0, exports.inputBox)(t, {
            input: input
          });
        };

        _proto39.visitNull = function visitNull(t, d) {
          return (0, exports.inputBox)(t, {});
        };

        _proto39.visitRecord = function visitRecord(t, fields, d) {
          var config = {};

          if (fields.length > 1) {
            var container = document.createElement("div");
            container.classList.add("popup-form");
            config = {
              container: container
            };
          }

          var form = (0, exports.recordForm)(fields, config);
          return (0, exports.inputBox)(t, {
            form: form
          });
        };

        _proto39.visitTuple = function visitTuple(t, components, d) {
          var config = {};

          if (components.length > 1) {
            var container = document.createElement("div");
            container.classList.add("popup-form");
            config = {
              container: container
            };
          }

          var form = (0, exports.tupleForm)(components, config);
          return (0, exports.inputBox)(t, {
            form: form
          });
        };

        _proto39.visitVariant = function visitVariant(t, fields, d) {
          var select = document.createElement("select");

          for (var _iterator12 = _createForOfIteratorHelperLoose(fields), _step12; !(_step12 = _iterator12()).done;) {
            var _step12$value = _step12.value,
                key = _step12$value[0],
                type = _step12$value[1];
            var option = new Option(key);
            select.add(option);
          }

          select.selectedIndex = -1;
          select.classList.add("open");
          var config = {
            open: select,
            event: "change"
          };
          var form = (0, exports.variantForm)(fields, config);
          return (0, exports.inputBox)(t, {
            form: form
          });
        };

        _proto39.visitOpt = function visitOpt(t, ty, d) {
          var checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.classList.add("open");
          var form = (0, exports.optForm)(ty, {
            open: checkbox,
            event: "change"
          });
          return (0, exports.inputBox)(t, {
            form: form
          });
        };

        _proto39.visitVec = function visitVec(t, ty, d) {
          var len = document.createElement("input");
          len.type = "number";
          len.min = "0";
          len.max = "100";
          len.style.width = "8rem";
          len.placeholder = "len";
          len.classList.add("open");
          var container = document.createElement("div");
          container.classList.add("popup-form");
          var form = (0, exports.vecForm)(ty, {
            open: len,
            event: "change",
            container: container
          });
          return (0, exports.inputBox)(t, {
            form: form
          });
        };

        _proto39.visitRec = function visitRec(t, ty, d) {
          return renderInput(ty);
        };

        return Render;
      }(IDL.Visitor);

      exports.Render = Render;

      var Parse = /*#__PURE__*/function (_IDL$Visitor2) {
        _inheritsLoose(Parse, _IDL$Visitor2);

        function Parse() {
          return _IDL$Visitor2.apply(this, arguments) || this;
        }

        var _proto40 = Parse.prototype;

        _proto40.visitNull = function visitNull(t, v) {
          return null;
        };

        _proto40.visitBool = function visitBool(t, v) {
          if (v === "true") {
            return true;
          }

          if (v === "false") {
            return false;
          }

          throw new Error("Cannot parse " + v + " as boolean");
        };

        _proto40.visitText = function visitText(t, v) {
          return v;
        };

        _proto40.visitFloat = function visitFloat(t, v) {
          return parseFloat(v);
        };

        _proto40.visitFixedInt = function visitFixedInt(t, v) {
          if (t._bits <= 32) {
            return parseInt(v, 10);
          } else {
            return BigInt(v);
          }
        };

        _proto40.visitFixedNat = function visitFixedNat(t, v) {
          if (t._bits <= 32) {
            return parseInt(v, 10);
          } else {
            return BigInt(v);
          }
        };

        _proto40.visitNumber = function visitNumber(t, v) {
          return BigInt(v);
        };

        _proto40.visitPrincipal = function visitPrincipal(t, v) {
          return principal_1.Principal.fromText(v);
        };

        _proto40.visitService = function visitService(t, v) {
          return principal_1.Principal.fromText(v);
        };

        _proto40.visitFunc = function visitFunc(t, v) {
          var x = v.split(".", 2);
          return [principal_1.Principal.fromText(x[0]), x[1]];
        };

        return Parse;
      }(IDL.Visitor);

      var Random = /*#__PURE__*/function (_IDL$Visitor3) {
        _inheritsLoose(Random, _IDL$Visitor3);

        function Random() {
          return _IDL$Visitor3.apply(this, arguments) || this;
        }

        var _proto41 = Random.prototype;

        _proto41.visitNull = function visitNull(t, v) {
          return null;
        };

        _proto41.visitBool = function visitBool(t, v) {
          return Math.random() < 0.5;
        };

        _proto41.visitText = function visitText(t, v) {
          return Math.random().toString(36).substring(6);
        };

        _proto41.visitFloat = function visitFloat(t, v) {
          return Math.random();
        };

        _proto41.visitInt = function visitInt(t, v) {
          return BigInt(this.generateNumber(true));
        };

        _proto41.visitNat = function visitNat(t, v) {
          return BigInt(this.generateNumber(false));
        };

        _proto41.visitFixedInt = function visitFixedInt(t, v) {
          var x = this.generateNumber(true);

          if (t._bits <= 32) {
            return x;
          } else {
            return BigInt(v);
          }
        };

        _proto41.visitFixedNat = function visitFixedNat(t, v) {
          var x = this.generateNumber(false);

          if (t._bits <= 32) {
            return x;
          } else {
            return BigInt(v);
          }
        };

        _proto41.generateNumber = function generateNumber(signed) {
          var num = Math.floor(Math.random() * 100);

          if (signed && Math.random() < 0.5) {
            return -num;
          } else {
            return num;
          }
        };

        return Random;
      }(IDL.Visitor);

      function parsePrimitive(t, config, d) {
        if (config.random && d === "") {
          return t.accept(new Random(), d);
        } else {
          return t.accept(new Parse(), d);
        }
      }

      function renderInput(t) {
        return t.accept(new Render(), null);
      }

      exports.renderInput = renderInput;

      function renderValue(t, input, value) {
        return t.accept(new RenderValue(), {
          input: input,
          value: value
        });
      }

      exports.renderValue = renderValue;

      var RenderValue = /*#__PURE__*/function (_IDL$Visitor4) {
        _inheritsLoose(RenderValue, _IDL$Visitor4);

        function RenderValue() {
          return _IDL$Visitor4.apply(this, arguments) || this;
        }

        var _proto42 = RenderValue.prototype;

        _proto42.visitType = function visitType(t, d) {
          d.input.ui.input.value = t.valueToString(d.value);
        } // eslint-disable-next-line @typescript-eslint/no-empty-function
        ;

        _proto42.visitNull = function visitNull(t, d) {};

        _proto42.visitText = function visitText(t, d) {
          d.input.ui.input.value = d.value;
        };

        _proto42.visitRec = function visitRec(t, ty, d) {
          renderValue(ty, d.input, d.value);
        };

        _proto42.visitOpt = function visitOpt(t, ty, d) {
          if (d.value.length === 0) {
            return;
          } else {
            var form = d.input.ui.form;
            var open = form.ui.open;
            open.checked = true;
            open.dispatchEvent(new Event(form.ui.event));
            renderValue(ty, form.form[0], d.value[0]);
          }
        };

        _proto42.visitRecord = function visitRecord(t, fields, d) {
          var form = d.input.ui.form;
          fields.forEach(function (_ref26, i) {
            var key = _ref26[0],
                type = _ref26[1];
            renderValue(type, form.form[i], d.value[key]);
          });
        };

        _proto42.visitTuple = function visitTuple(t, components, d) {
          var form = d.input.ui.form;
          components.forEach(function (type, i) {
            renderValue(type, form.form[i], d.value[i]);
          });
        };

        _proto42.visitVariant = function visitVariant(t, fields, d) {
          var form = d.input.ui.form;
          var selected = Object.entries(d.value)[0];
          fields.forEach(function (_ref27, i) {
            var key = _ref27[0],
                type = _ref27[1];

            if (key === selected[0]) {
              var open = form.ui.open;
              open.selectedIndex = i;
              open.dispatchEvent(new Event(form.ui.event));
              renderValue(type, form.form[0], selected[1]);
            }
          });
        };

        _proto42.visitVec = function visitVec(t, ty, d) {
          var form = d.input.ui.form;
          var len = d.value.length;
          var open = form.ui.open;
          open.value = len;
          open.dispatchEvent(new Event(form.ui.event));
          d.value.forEach(function (v, i) {
            renderValue(ty, form.form[i], v);
          });
        };

        return RenderValue;
      }(IDL.Visitor);
    }
  }); // node_modules/@dfinity/candid/lib/cjs/types.js


  var require_types = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/types.js": function node_modulesDfinityCandidLibCjsTypesJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    }
  }); // node_modules/@dfinity/candid/lib/cjs/index.js


  var require_cjs2 = __commonJS({
    "node_modules/@dfinity/candid/lib/cjs/index.js": function node_modulesDfinityCandidLibCjsIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IDL = void 0;

      __exportStar(require_candid_ui(), exports);

      __exportStar(require_candid_core(), exports);

      exports.IDL = __importStar(require_idl());

      __exportStar(require_hash(), exports);

      __exportStar(require_leb128(), exports);

      __exportStar(require_buffer3(), exports);

      __exportStar(require_types(), exports);
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/node_modules/buffer/index.js


  var require_buffer4 = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/node_modules/buffer/index.js": function node_modulesDfinityAgentNode_modulesBorcNode_modulesBufferIndexJs(exports) {
      "use strict";

      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();

      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }

      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = {
            foo: function foo() {
              return 42;
            }
          };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }

      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });

      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }

        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }

          return allocUnsafe(arg);
        }

        return from(arg, encodingOrOffset, length);
      }

      Buffer2.poolSize = 8192;

      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }

        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }

        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }

        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }

        var valueOf = value.valueOf && value.valueOf();

        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }

        var b = fromObject(value);
        if (b) return b;

        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }

        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }

      Buffer2.from = function (value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };

      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);

      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }

      function alloc(size, fill, encoding) {
        assertSize(size);

        if (size <= 0) {
          return createBuffer(size);
        }

        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }

        return createBuffer(size);
      }

      Buffer2.alloc = function (size, fill, encoding) {
        return alloc(size, fill, encoding);
      };

      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }

      Buffer2.allocUnsafe = function (size) {
        return allocUnsafe(size);
      };

      Buffer2.allocUnsafeSlow = function (size) {
        return allocUnsafe(size);
      };

      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }

        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }

        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);

        if (actual !== length) {
          buf = buf.slice(0, actual);
        }

        return buf;
      }

      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);

        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }

        return buf;
      }

      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }

        return fromArrayLike(arrayView);
      }

      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }

        var buf;

        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }

        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);

          if (buf.length === 0) {
            return buf;
          }

          obj.copy(buf, 0, 0, len);
          return buf;
        }

        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }

          return fromArrayLike(obj);
        }

        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }

      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }

        return length | 0;
      }

      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }

        return Buffer2.alloc(+length);
      }

      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };

      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);

        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }

        if (a === b) return 0;
        var x = a.length;
        var y = b.length;

        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;

          default:
            return false;
        }
      };

      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        if (list.length === 0) {
          return Buffer2.alloc(0);
        }

        var i;

        if (length === void 0) {
          length = 0;

          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }

        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;

        for (i = 0; i < list.length; ++i) {
          var buf = list[i];

          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer2.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }

          pos += buf.length;
        }

        return buffer;
      };

      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }

        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }

        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }

        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;

            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;

            case "hex":
              return len >>> 1;

            case "base64":
              return base64ToBytes(string).length;

            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }

              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.byteLength = byteLength;

      function slowToString(encoding, start, end) {
        var loweredCase = false;

        if (start === void 0 || start < 0) {
          start = 0;
        }

        if (start > this.length) {
          return "";
        }

        if (end === void 0 || end > this.length) {
          end = this.length;
        }

        if (end <= 0) {
          return "";
        }

        end >>>= 0;
        start >>>= 0;

        if (end <= start) {
          return "";
        }

        if (!encoding) encoding = "utf8";

        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);

            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);

            case "ascii":
              return asciiSlice(this, start, end);

            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);

            case "base64":
              return base64Slice(this, start, end);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.prototype._isBuffer = true;

      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }

      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;

        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }

        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }

        return this;
      };

      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;

        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }

        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }

        return this;
      };

      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;

        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }

        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }

        return this;
      };

      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };

      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;

      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };

      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };

      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }

      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }

        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }

        if (start === void 0) {
          start = 0;
        }

        if (end === void 0) {
          end = target ? target.length : 0;
        }

        if (thisStart === void 0) {
          thisStart = 0;
        }

        if (thisEnd === void 0) {
          thisEnd = this.length;
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }

        if (thisStart >= thisEnd) {
          return -1;
        }

        if (start >= end) {
          return 1;
        }

        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);

        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;

        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }

        byteOffset = +byteOffset;

        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }

        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

        if (byteOffset >= buffer.length) {
          if (dir) return -1;else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;else return -1;
        }

        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }

        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }

          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;

          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }

          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }

        throw new TypeError("val must be string, number or Buffer");
      }

      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;

        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();

          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }

            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }

        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }

        var i;

        if (dir) {
          var foundIndex = -1;

          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

          for (i = byteOffset; i >= 0; i--) {
            var found = true;

            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }

            if (found) return i;
          }
        }

        return -1;
      }

      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };

      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };

      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };

      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;

        if (!length) {
          length = remaining;
        } else {
          length = Number(length);

          if (length > remaining) {
            length = remaining;
          }
        }

        var strLen = string.length;

        if (length > strLen / 2) {
          length = strLen / 2;
        }

        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }

        return i;
      }

      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }

      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }

      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }

      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }

      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;

          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }

        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;

        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }

        if (!encoding) encoding = "utf8";
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);

            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);

            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);

            case "base64":
              return base64Write(this, string, offset, length);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };

      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };

      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }

      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;

        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;

          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }

                break;

              case 2:
                secondByte = buf[i + 1];

                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;

                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;

                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;

                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }

            }
          }

          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }

          res.push(codePoint);
          i += bytesPerSequence;
        }

        return decodeCodePointsArray(res);
      }

      var MAX_ARGUMENTS_LENGTH = 4096;

      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;

        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }

        var res = "";
        var i = 0;

        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }

        return res;
      }

      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }

        return ret;
      }

      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }

        return ret;
      }

      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out = "";

        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }

        return out;
      }

      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";

        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }

        return res;
      }

      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;

        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }

        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }

        if (end < start) end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };

      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }

      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }

        var val = this[offset + --byteLength2];
        var mul = 1;

        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };

      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };

      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };

      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };

      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };

      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];

        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };

      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };

      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };

      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };

      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };

      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };

      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };

      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }

      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var mul = 1;
        var i = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };

      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }

      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }

        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }

      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };

      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }

        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }

      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };

      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;

        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }

        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;

        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }

        var len = end - start;

        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }

        return len;
      };

      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }

          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }

          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }

          if (val.length === 1) {
            var code = val.charCodeAt(0);

            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }

        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }

        if (end <= start) {
          return this;
        }

        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;

        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          var len = bytes.length;

          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }

          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }

        return this;
      };

      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";

        while (str.length % 4 !== 0) {
          str = str + "=";
        }

        return str;
      }

      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];

        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);

          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }

              leadSurrogate = codePoint;
              continue;
            }

            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }

            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }

          leadSurrogate = null;

          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }

        return bytes;
      }

      function asciiToBytes(str) {
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }

        return byteArray;
      }

      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }

        return byteArray;
      }

      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }

      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }

        return i;
      }

      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }

      function numberIsNaN(obj) {
        return obj !== obj;
      }

      var hexSliceLookupTable = function () {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);

        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;

          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }

        return table;
      }();
    }
  }); // node_modules/bignumber.js/bignumber.js


  var require_bignumber = __commonJS({
    "node_modules/bignumber.js/bignumber.js": function node_modulesBignumberJsBignumberJs(exports, module) {
      (function (globalObject) {
        "use strict";

        var BigNumber,
            isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
            mathceil = Math.ceil,
            mathfloor = Math.floor,
            bignumberError = "[BigNumber Error] ",
            tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ",
            BASE = 1e14,
            LOG_BASE = 14,
            MAX_SAFE_INTEGER = 9007199254740991,
            POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
            SQRT_BASE = 1e7,
            MAX = 1e9;

        function clone(configObject) {
          var div,
              convertBase,
              parseNumeric,
              P = BigNumber2.prototype = {
            constructor: BigNumber2,
            toString: null,
            valueOf: null
          },
              ONE = new BigNumber2(1),
              DECIMAL_PLACES = 20,
              ROUNDING_MODE = 4,
              TO_EXP_NEG = -7,
              TO_EXP_POS = 21,
              MIN_EXP = -1e7,
              MAX_EXP = 1e7,
              CRYPTO = false,
              MODULO_MODE = 1,
              POW_PRECISION = 0,
              FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xA0",
            // non-breaking space
            suffix: ""
          },
              ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz",
              alphabetHasNormalDecimalDigits = true;

          function BigNumber2(v, b) {
            var alphabet,
                c,
                caseChanged,
                e,
                i,
                isNum,
                len,
                str,
                x = this;
            if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);

            if (b == null) {
              if (v && v._isBigNumber === true) {
                x.s = v.s;

                if (!v.c || v.e > MAX_EXP) {
                  x.c = x.e = null;
                } else if (v.e < MIN_EXP) {
                  x.c = [x.e = 0];
                } else {
                  x.e = v.e;
                  x.c = v.c.slice();
                }

                return;
              }

              if ((isNum = typeof v == "number") && v * 0 == 0) {
                x.s = 1 / v < 0 ? (v = -v, -1) : 1;

                if (v === ~~v) {
                  for (e = 0, i = v; i >= 10; i /= 10, e++) {
                    ;
                  }

                  if (e > MAX_EXP) {
                    x.c = x.e = null;
                  } else {
                    x.e = e;
                    x.c = [v];
                  }

                  return;
                }

                str = String(v);
              } else {
                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
              }

              if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");

              if ((i = str.search(/e/i)) > 0) {
                if (e < 0) e = i;
                e += +str.slice(i + 1);
                str = str.substring(0, i);
              } else if (e < 0) {
                e = str.length;
              }
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");

              if (b == 10 && alphabetHasNormalDecimalDigits) {
                x = new BigNumber2(v);
                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
              }

              str = String(v);

              if (isNum = typeof v == "number") {
                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

                if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                  throw Error(tooManyDigits + v);
                }
              } else {
                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
              }

              alphabet = ALPHABET.slice(0, b);
              e = i = 0;

              for (len = str.length; i < len; i++) {
                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                  if (c == ".") {
                    if (i > e) {
                      e = len;
                      continue;
                    }
                  } else if (!caseChanged) {
                    if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                      caseChanged = true;
                      i = -1;
                      e = 0;
                      continue;
                    }
                  }

                  return parseNumeric(x, String(v), isNum, b);
                }
              }

              isNum = false;
              str = convertBase(str, b, 10, x.s);
              if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");else e = str.length;
            }

            for (i = 0; str.charCodeAt(i) === 48; i++) {
              ;
            }

            for (len = str.length; str.charCodeAt(--len) === 48;) {
              ;
            }

            if (str = str.slice(i, ++len)) {
              len -= i;

              if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error(tooManyDigits + x.s * v);
              }

              if ((e = e - i - 1) > MAX_EXP) {
                x.c = x.e = null;
              } else if (e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = e;
                x.c = [];
                i = (e + 1) % LOG_BASE;
                if (e < 0) i += LOG_BASE;

                if (i < len) {
                  if (i) x.c.push(+str.slice(0, i));

                  for (len -= LOG_BASE; i < len;) {
                    x.c.push(+str.slice(i, i += LOG_BASE));
                  }

                  i = LOG_BASE - (str = str.slice(i)).length;
                } else {
                  i -= len;
                }

                for (; i--; str += "0") {
                  ;
                }

                x.c.push(+str);
              }
            } else {
              x.c = [x.e = 0];
            }
          }

          BigNumber2.clone = clone;
          BigNumber2.ROUND_UP = 0;
          BigNumber2.ROUND_DOWN = 1;
          BigNumber2.ROUND_CEIL = 2;
          BigNumber2.ROUND_FLOOR = 3;
          BigNumber2.ROUND_HALF_UP = 4;
          BigNumber2.ROUND_HALF_DOWN = 5;
          BigNumber2.ROUND_HALF_EVEN = 6;
          BigNumber2.ROUND_HALF_CEIL = 7;
          BigNumber2.ROUND_HALF_FLOOR = 8;
          BigNumber2.EUCLID = 9;

          BigNumber2.config = BigNumber2.set = function (obj) {
            var p, v;

            if (obj != null) {
              if (typeof obj == "object") {
                if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  DECIMAL_PLACES = v;
                }

                if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 8, p);
                  ROUNDING_MODE = v;
                }

                if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                  v = obj[p];

                  if (v && v.pop) {
                    intCheck(v[0], -MAX, 0, p);
                    intCheck(v[1], 0, MAX, p);
                    TO_EXP_NEG = v[0];
                    TO_EXP_POS = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);
                    TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                  }
                }

                if (obj.hasOwnProperty(p = "RANGE")) {
                  v = obj[p];

                  if (v && v.pop) {
                    intCheck(v[0], -MAX, -1, p);
                    intCheck(v[1], 1, MAX, p);
                    MIN_EXP = v[0];
                    MAX_EXP = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);

                    if (v) {
                      MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                    } else {
                      throw Error(bignumberError + p + " cannot be zero: " + v);
                    }
                  }
                }

                if (obj.hasOwnProperty(p = "CRYPTO")) {
                  v = obj[p];

                  if (v === !!v) {
                    if (v) {
                      if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                        CRYPTO = v;
                      } else {
                        CRYPTO = !v;
                        throw Error(bignumberError + "crypto unavailable");
                      }
                    } else {
                      CRYPTO = v;
                    }
                  } else {
                    throw Error(bignumberError + p + " not true or false: " + v);
                  }
                }

                if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 9, p);
                  MODULO_MODE = v;
                }

                if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  POW_PRECISION = v;
                }

                if (obj.hasOwnProperty(p = "FORMAT")) {
                  v = obj[p];
                  if (typeof v == "object") FORMAT = v;else throw Error(bignumberError + p + " not an object: " + v);
                }

                if (obj.hasOwnProperty(p = "ALPHABET")) {
                  v = obj[p];

                  if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                    alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                    ALPHABET = v;
                  } else {
                    throw Error(bignumberError + p + " invalid: " + v);
                  }
                }
              } else {
                throw Error(bignumberError + "Object expected: " + obj);
              }
            }

            return {
              DECIMAL_PLACES: DECIMAL_PLACES,
              ROUNDING_MODE: ROUNDING_MODE,
              EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
              RANGE: [MIN_EXP, MAX_EXP],
              CRYPTO: CRYPTO,
              MODULO_MODE: MODULO_MODE,
              POW_PRECISION: POW_PRECISION,
              FORMAT: FORMAT,
              ALPHABET: ALPHABET
            };
          };

          BigNumber2.isBigNumber = function (v) {
            if (!v || v._isBigNumber !== true) return false;
            if (!BigNumber2.DEBUG) return true;
            var i,
                n,
                c = v.c,
                e = v.e,
                s = v.s;

            out: if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1) return true;
                  break out;
                }

                i = (e + 1) % LOG_BASE;
                if (i < 1) i += LOG_BASE;

                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                  }

                  if (n !== 0) return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }

            throw Error(bignumberError + "Invalid BigNumber: " + v);
          };

          BigNumber2.maximum = BigNumber2.max = function () {
            return maxOrMin(arguments, -1);
          };

          BigNumber2.minimum = BigNumber2.min = function () {
            return maxOrMin(arguments, 1);
          };

          BigNumber2.random = function () {
            var pow2_53 = 9007199254740992;
            var random53bitInt = Math.random() * pow2_53 & 2097151 ? function () {
              return mathfloor(Math.random() * pow2_53);
            } : function () {
              return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
            };
            return function (dp) {
              var a,
                  b,
                  e,
                  k,
                  v,
                  i = 0,
                  c = [],
                  rand = new BigNumber2(ONE);
              if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
              k = mathceil(dp / LOG_BASE);

              if (CRYPTO) {
                if (crypto.getRandomValues) {
                  a = crypto.getRandomValues(new Uint32Array(k *= 2));

                  for (; i < k;) {
                    v = a[i] * 131072 + (a[i + 1] >>> 11);

                    if (v >= 9e15) {
                      b = crypto.getRandomValues(new Uint32Array(2));
                      a[i] = b[0];
                      a[i + 1] = b[1];
                    } else {
                      c.push(v % 1e14);
                      i += 2;
                    }
                  }

                  i = k / 2;
                } else if (crypto.randomBytes) {
                  a = crypto.randomBytes(k *= 7);

                  for (; i < k;) {
                    v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                    if (v >= 9e15) {
                      crypto.randomBytes(7).copy(a, i);
                    } else {
                      c.push(v % 1e14);
                      i += 7;
                    }
                  }

                  i = k / 7;
                } else {
                  CRYPTO = false;
                  throw Error(bignumberError + "crypto unavailable");
                }
              }

              if (!CRYPTO) {
                for (; i < k;) {
                  v = random53bitInt();
                  if (v < 9e15) c[i++] = v % 1e14;
                }
              }

              k = c[--i];
              dp %= LOG_BASE;

              if (k && dp) {
                v = POWS_TEN[LOG_BASE - dp];
                c[i] = mathfloor(k / v) * v;
              }

              for (; c[i] === 0; c.pop(), i--) {
                ;
              }

              if (i < 0) {
                c = [e = 0];
              } else {
                for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) {
                  ;
                }

                for (i = 1, v = c[0]; v >= 10; v /= 10, i++) {
                  ;
                }

                if (i < LOG_BASE) e -= LOG_BASE - i;
              }

              rand.e = e;
              rand.c = c;
              return rand;
            };
          }();

          BigNumber2.sum = function () {
            var i = 1,
                args = arguments,
                sum = new BigNumber2(args[0]);

            for (; i < args.length;) {
              sum = sum.plus(args[i++]);
            }

            return sum;
          };

          convertBase = /* @__PURE__ */function () {
            var decimal = "0123456789";

            function toBaseOut(str, baseIn, baseOut, alphabet) {
              var j,
                  arr = [0],
                  arrL,
                  i = 0,
                  len = str.length;

              for (; i < len;) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) {
                  ;
                }

                arr[0] += alphabet.indexOf(str.charAt(i++));

                for (j = 0; j < arr.length; j++) {
                  if (arr[j] > baseOut - 1) {
                    if (arr[j + 1] == null) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                  }
                }
              }

              return arr.reverse();
            }

            return function (str, baseIn, baseOut, sign, callerIsToString) {
              var alphabet,
                  d,
                  e,
                  k,
                  r,
                  x,
                  xc,
                  y,
                  i = str.indexOf("."),
                  dp = DECIMAL_PLACES,
                  rm = ROUNDING_MODE;

              if (i >= 0) {
                k = POW_PRECISION;
                POW_PRECISION = 0;
                str = str.replace(".", "");
                y = new BigNumber2(baseIn);
                x = y.pow(str.length - i);
                POW_PRECISION = k;
                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
                y.e = y.c.length;
              }

              xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
              e = k = xc.length;

              for (; xc[--k] == 0; xc.pop()) {
                ;
              }

              if (!xc[0]) return alphabet.charAt(0);

              if (i < 0) {
                --e;
              } else {
                x.c = xc;
                x.e = e;
                x.s = sign;
                x = div(x, y, dp, rm, baseOut);
                xc = x.c;
                r = x.r;
                e = x.e;
              }

              d = e + dp + 1;
              i = xc[d];
              k = baseOut / 2;
              r = r || d < 0 || xc[d + 1] != null;
              r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));

              if (d < 1 || !xc[0]) {
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
              } else {
                xc.length = d;

                if (r) {
                  for (--baseOut; ++xc[--d] > baseOut;) {
                    xc[d] = 0;

                    if (!d) {
                      ++e;
                      xc = [1].concat(xc);
                    }
                  }
                }

                for (k = xc.length; !xc[--k];) {
                  ;
                }

                for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) {
                  ;
                }

                str = toFixedPoint(str, e, alphabet.charAt(0));
              }

              return str;
            };
          }();

          div = /* @__PURE__ */function () {
            function multiply(x, k, base) {
              var m,
                  temp,
                  xlo,
                  xhi,
                  carry = 0,
                  i = x.length,
                  klo = k % SQRT_BASE,
                  khi = k / SQRT_BASE | 0;

              for (x = x.slice(); i--;) {
                xlo = x[i] % SQRT_BASE;
                xhi = x[i] / SQRT_BASE | 0;
                m = khi * xlo + xhi * klo;
                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                x[i] = temp % base;
              }

              if (carry) x = [carry].concat(x);
              return x;
            }

            function compare2(a, b, aL, bL) {
              var i, cmp;

              if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
              } else {
                for (i = cmp = 0; i < aL; i++) {
                  if (a[i] != b[i]) {
                    cmp = a[i] > b[i] ? 1 : -1;
                    break;
                  }
                }
              }

              return cmp;
            }

            function subtract(a, b, aL, base) {
              var i = 0;

              for (; aL--;) {
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base + a[aL] - b[aL];
              }

              for (; !a[0] && a.length > 1; a.splice(0, 1)) {
                ;
              }
            }

            return function (x, y, dp, rm, base) {
              var cmp,
                  e,
                  i,
                  more,
                  n,
                  prod,
                  prodL,
                  q,
                  qc,
                  rem,
                  remL,
                  rem0,
                  xi,
                  xL,
                  yc0,
                  yL,
                  yz,
                  s = x.s == y.s ? 1 : -1,
                  xc = x.c,
                  yc = y.c;

              if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber2( // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
              }

              q = new BigNumber2(s);
              qc = q.c = [];
              e = x.e - y.e;
              s = dp + e + 1;

              if (!base) {
                base = BASE;
                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                s = s / LOG_BASE | 0;
              }

              for (i = 0; yc[i] == (xc[i] || 0); i++) {
                ;
              }

              if (yc[i] > (xc[i] || 0)) e--;

              if (s < 0) {
                qc.push(1);
                more = true;
              } else {
                xL = xc.length;
                yL = yc.length;
                i = 0;
                s += 2;
                n = mathfloor(base / (yc[0] + 1));

                if (n > 1) {
                  yc = multiply(yc, n, base);
                  xc = multiply(xc, n, base);
                  yL = yc.length;
                  xL = xc.length;
                }

                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;

                for (; remL < yL; rem[remL++] = 0) {
                  ;
                }

                yz = yc.slice();
                yz = [0].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base / 2) yc0++;

                do {
                  n = 0;
                  cmp = compare2(yc, rem, yL, remL);

                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                    n = mathfloor(rem0 / yc0);

                    if (n > 1) {
                      if (n >= base) n = base - 1;
                      prod = multiply(yc, n, base);
                      prodL = prod.length;
                      remL = rem.length;

                      while (compare2(prod, rem, prodL, remL) == 1) {
                        n--;
                        subtract(prod, yL < prodL ? yz : yc, prodL, base);
                        prodL = prod.length;
                        cmp = 1;
                      }
                    } else {
                      if (n == 0) {
                        cmp = n = 1;
                      }

                      prod = yc.slice();
                      prodL = prod.length;
                    }

                    if (prodL < remL) prod = [0].concat(prod);
                    subtract(rem, prod, remL, base);
                    remL = rem.length;

                    if (cmp == -1) {
                      while (compare2(yc, rem, yL, remL) < 1) {
                        n++;
                        subtract(rem, yL < remL ? yz : yc, remL, base);
                        remL = rem.length;
                      }
                    }
                  } else if (cmp === 0) {
                    n++;
                    rem = [0];
                  }

                  qc[i++] = n;

                  if (rem[0]) {
                    rem[remL++] = xc[xi] || 0;
                  } else {
                    rem = [xc[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] != null) && s--);

                more = rem[0] != null;
                if (!qc[0]) qc.splice(0, 1);
              }

              if (base == BASE) {
                for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) {
                  ;
                }

                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
              } else {
                q.e = e;
                q.r = +more;
              }

              return q;
            };
          }();

          function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
            if (!n.c) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if (i == null) {
              str = coeffToString(n.c);
              str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
            } else {
              n = round(new BigNumber2(n), i, rm);
              e = n.e;
              str = coeffToString(n.c);
              len = str.length;

              if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                for (; len < i; str += "0", len++) {
                  ;
                }

                str = toExponential(str, e);
              } else {
                i -= ne + (id === 2 && e > ne);
                str = toFixedPoint(str, e, "0");

                if (e + 1 > len) {
                  if (--i > 0) for (str += "."; i--; str += "0") {
                    ;
                  }
                } else {
                  i += e - len;

                  if (i > 0) {
                    if (e + 1 == len) str += ".";

                    for (; i--; str += "0") {
                      ;
                    }
                  }
                }
              }
            }

            return n.s < 0 && c0 ? "-" + str : str;
          }

          function maxOrMin(args, n) {
            var k,
                y,
                i = 1,
                x = new BigNumber2(args[0]);

            for (; i < args.length; i++) {
              y = new BigNumber2(args[i]);

              if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                x = y;
              }
            }

            return x;
          }

          function normalise(n, c, e) {
            var i = 1,
                j = c.length;

            for (; !c[--j]; c.pop()) {
              ;
            }

            for (j = c[0]; j >= 10; j /= 10, i++) {
              ;
            }

            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
              n.c = n.e = null;
            } else if (e < MIN_EXP) {
              n.c = [n.e = 0];
            } else {
              n.e = e;
              n.c = c;
            }

            return n;
          }

          parseNumeric = /* @__PURE__ */function () {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function (x, str, isNum, b) {
              var base,
                  s = isNum ? str : str.replace(whitespaceOrPlus, "");

              if (isInfinityOrNaN.test(s)) {
                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
              } else {
                if (!isNum) {
                  s = s.replace(basePrefix, function (m, p1, p2) {
                    base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                    return !b || b == base ? p1 : m;
                  });

                  if (b) {
                    base = b;
                    s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                  }

                  if (str != s) return new BigNumber2(s, base);
                }

                if (BigNumber2.DEBUG) {
                  throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                }

                x.s = null;
              }

              x.c = x.e = null;
            };
          }();

          function round(x, sd, rm, r) {
            var d,
                i,
                j,
                k,
                n,
                ni,
                rd,
                xc = x.c,
                pows10 = POWS_TEN;

            if (xc) {
              out: {
                for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) {
                  ;
                }

                i = sd - d;

                if (i < 0) {
                  i += LOG_BASE;
                  j = sd;
                  n = xc[ni = 0];
                  rd = mathfloor(n / pows10[d - j - 1] % 10);
                } else {
                  ni = mathceil((i + 1) / LOG_BASE);

                  if (ni >= xc.length) {
                    if (r) {
                      for (; xc.length <= ni; xc.push(0)) {
                        ;
                      }

                      n = rd = 0;
                      d = 1;
                      i %= LOG_BASE;
                      j = i - LOG_BASE + 1;
                    } else {
                      break out;
                    }
                  } else {
                    n = k = xc[ni];

                    for (d = 1; k >= 10; k /= 10, d++) {
                      ;
                    }

                    i %= LOG_BASE;
                    j = i - LOG_BASE + d;
                    rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                  }
                }

                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

                if (sd < 1 || !xc[0]) {
                  xc.length = 0;

                  if (r) {
                    sd -= x.e + 1;
                    xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                    x.e = -sd || 0;
                  } else {
                    xc[0] = x.e = 0;
                  }

                  return x;
                }

                if (i == 0) {
                  xc.length = ni;
                  k = 1;
                  ni--;
                } else {
                  xc.length = ni + 1;
                  k = pows10[LOG_BASE - i];
                  xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                }

                if (r) {
                  for (;;) {
                    if (ni == 0) {
                      for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) {
                        ;
                      }

                      j = xc[0] += k;

                      for (k = 1; j >= 10; j /= 10, k++) {
                        ;
                      }

                      if (i != k) {
                        x.e++;
                        if (xc[0] == BASE) xc[0] = 1;
                      }

                      break;
                    } else {
                      xc[ni] += k;
                      if (xc[ni] != BASE) break;
                      xc[ni--] = 0;
                      k = 1;
                    }
                  }
                }

                for (i = xc.length; xc[--i] === 0; xc.pop()) {
                  ;
                }
              }

              if (x.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (x.e < MIN_EXP) {
                x.c = [x.e = 0];
              }
            }

            return x;
          }

          function valueOf(n) {
            var str,
                e = n.e;
            if (e === null) return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
            return n.s < 0 ? "-" + str : str;
          }

          P.absoluteValue = P.abs = function () {
            var x = new BigNumber2(this);
            if (x.s < 0) x.s = 1;
            return x;
          };

          P.comparedTo = function (y, b) {
            return compare(this, new BigNumber2(y, b));
          };

          P.decimalPlaces = P.dp = function (dp, rm) {
            var c,
                n,
                v,
                x = this;

            if (dp != null) {
              intCheck(dp, 0, MAX);
              if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
              return round(new BigNumber2(x), dp + x.e + 1, rm);
            }

            if (!(c = x.c)) return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) {
              ;
            }
            if (n < 0) n = 0;
            return n;
          };

          P.dividedBy = P.div = function (y, b) {
            return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
          };

          P.dividedToIntegerBy = P.idiv = function (y, b) {
            return div(this, new BigNumber2(y, b), 0, 1);
          };

          P.exponentiatedBy = P.pow = function (n, m) {
            var half,
                isModExp,
                i,
                k,
                more,
                nIsBig,
                nIsNeg,
                nIsOdd,
                y,
                x = this;
            n = new BigNumber2(n);

            if (n.c && !n.isInteger()) {
              throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
            }

            if (m != null) m = new BigNumber2(m);
            nIsBig = n.e > 14;

            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
              y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
              return m ? y.mod(m) : y;
            }

            nIsNeg = n.s < 0;

            if (m) {
              if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
              isModExp = !nIsNeg && x.isInteger() && m.isInteger();
              if (isModExp) x = x.mod(m);
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
              k = x.s < 0 && isOdd(n) ? -0 : 0;
              if (x.e > -1) k = 1 / k;
              return new BigNumber2(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) {
              k = mathceil(POW_PRECISION / LOG_BASE + 2);
            }

            if (nIsBig) {
              half = new BigNumber2(0.5);
              if (nIsNeg) n.s = 1;
              nIsOdd = isOdd(n);
            } else {
              i = Math.abs(+valueOf(n));
              nIsOdd = i % 2;
            }

            y = new BigNumber2(ONE);

            for (;;) {
              if (nIsOdd) {
                y = y.times(x);
                if (!y.c) break;

                if (k) {
                  if (y.c.length > k) y.c.length = k;
                } else if (isModExp) {
                  y = y.mod(m);
                }
              }

              if (i) {
                i = mathfloor(i / 2);
                if (i === 0) break;
                nIsOdd = i % 2;
              } else {
                n = n.times(half);
                round(n, n.e + 1, 1);

                if (n.e > 14) {
                  nIsOdd = isOdd(n);
                } else {
                  i = +valueOf(n);
                  if (i === 0) break;
                  nIsOdd = i % 2;
                }
              }

              x = x.times(x);

              if (k) {
                if (x.c && x.c.length > k) x.c.length = k;
              } else if (isModExp) {
                x = x.mod(m);
              }
            }

            if (isModExp) return y;
            if (nIsNeg) y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
          };

          P.integerValue = function (rm) {
            var n = new BigNumber2(this);
            if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
          };

          P.isEqualTo = P.eq = function (y, b) {
            return compare(this, new BigNumber2(y, b)) === 0;
          };

          P.isFinite = function () {
            return !!this.c;
          };

          P.isGreaterThan = P.gt = function (y, b) {
            return compare(this, new BigNumber2(y, b)) > 0;
          };

          P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
            return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
          };

          P.isInteger = function () {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
          };

          P.isLessThan = P.lt = function (y, b) {
            return compare(this, new BigNumber2(y, b)) < 0;
          };

          P.isLessThanOrEqualTo = P.lte = function (y, b) {
            return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
          };

          P.isNaN = function () {
            return !this.s;
          };

          P.isNegative = function () {
            return this.s < 0;
          };

          P.isPositive = function () {
            return this.s > 0;
          };

          P.isZero = function () {
            return !!this.c && this.c[0] == 0;
          };

          P.minus = function (y, b) {
            var i,
                j,
                t,
                xLTy,
                x = this,
                a = x.s;
            y = new BigNumber2(y, b);
            b = y.s;
            if (!a || !b) return new BigNumber2(NaN);

            if (a != b) {
              y.s = -b;
              return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if (!xe || !ye) {
              if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);

              if (!xc[0] || !yc[0]) {
                return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0);
              }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            if (a = xe - ye) {
              if (xLTy = a < 0) {
                a = -a;
                t = xc;
              } else {
                ye = xe;
                t = yc;
              }

              t.reverse();

              for (b = a; b--; t.push(0)) {
                ;
              }

              t.reverse();
            } else {
              j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

              for (a = b = 0; b < j; b++) {
                if (xc[b] != yc[b]) {
                  xLTy = xc[b] < yc[b];
                  break;
                }
              }
            }

            if (xLTy) {
              t = xc;
              xc = yc;
              yc = t;
              y.s = -y.s;
            }

            b = (j = yc.length) - (i = xc.length);
            if (b > 0) for (; b--; xc[i++] = 0) {
              ;
            }
            b = BASE - 1;

            for (; j > a;) {
              if (xc[--j] < yc[j]) {
                for (i = j; i && !xc[--i]; xc[i] = b) {
                  ;
                }

                --xc[i];
                xc[j] += BASE;
              }

              xc[j] -= yc[j];
            }

            for (; xc[0] == 0; xc.splice(0, 1), --ye) {
              ;
            }

            if (!xc[0]) {
              y.s = ROUNDING_MODE == 3 ? -1 : 1;
              y.c = [y.e = 0];
              return y;
            }

            return normalise(y, xc, ye);
          };

          P.modulo = P.mod = function (y, b) {
            var q,
                s,
                x = this;
            y = new BigNumber2(y, b);

            if (!x.c || !y.s || y.c && !y.c[0]) {
              return new BigNumber2(NaN);
            } else if (!y.c || x.c && !x.c[0]) {
              return new BigNumber2(x);
            }

            if (MODULO_MODE == 9) {
              s = y.s;
              y.s = 1;
              q = div(x, y, 0, 3);
              y.s = s;
              q.s *= s;
            } else {
              q = div(x, y, 0, MODULO_MODE);
            }

            y = x.minus(q.times(y));
            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
            return y;
          };

          P.multipliedBy = P.times = function (y, b) {
            var c,
                e,
                i,
                j,
                k,
                m,
                xcL,
                xlo,
                xhi,
                ycL,
                ylo,
                yhi,
                zc,
                base,
                sqrtBase,
                x = this,
                xc = x.c,
                yc = (y = new BigNumber2(y, b)).c;

            if (!xc || !yc || !xc[0] || !yc[0]) {
              if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y.c = y.e = y.s = null;
              } else {
                y.s *= x.s;

                if (!xc || !yc) {
                  y.c = y.e = null;
                } else {
                  y.c = [0];
                  y.e = 0;
                }
              }

              return y;
            }

            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            if (xcL < ycL) {
              zc = xc;
              xc = yc;
              yc = zc;
              i = xcL;
              xcL = ycL;
              ycL = i;
            }

            for (i = xcL + ycL, zc = []; i--; zc.push(0)) {
              ;
            }

            base = BASE;
            sqrtBase = SQRT_BASE;

            for (i = ycL; --i >= 0;) {
              c = 0;
              ylo = yc[i] % sqrtBase;
              yhi = yc[i] / sqrtBase | 0;

              for (k = xcL, j = i + k; j > i;) {
                xlo = xc[--k] % sqrtBase;
                xhi = xc[k] / sqrtBase | 0;
                m = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                zc[j--] = xlo % base;
              }

              zc[j] = c;
            }

            if (c) {
              ++e;
            } else {
              zc.splice(0, 1);
            }

            return normalise(y, zc, e);
          };

          P.negated = function () {
            var x = new BigNumber2(this);
            x.s = -x.s || null;
            return x;
          };

          P.plus = function (y, b) {
            var t,
                x = this,
                a = x.s;
            y = new BigNumber2(y, b);
            b = y.s;
            if (!a || !b) return new BigNumber2(NaN);

            if (a != b) {
              y.s = -b;
              return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if (!xe || !ye) {
              if (!xc || !yc) return new BigNumber2(a / 0);
              if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            if (a = xe - ye) {
              if (a > 0) {
                ye = xe;
                t = yc;
              } else {
                a = -a;
                t = xc;
              }

              t.reverse();

              for (; a--; t.push(0)) {
                ;
              }

              t.reverse();
            }

            a = xc.length;
            b = yc.length;

            if (a - b < 0) {
              t = yc;
              yc = xc;
              xc = t;
              b = a;
            }

            for (a = 0; b;) {
              a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
              xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }

            if (a) {
              xc = [a].concat(xc);
              ++ye;
            }

            return normalise(y, xc, ye);
          };

          P.precision = P.sd = function (sd, rm) {
            var c,
                n,
                v,
                x = this;

            if (sd != null && sd !== !!sd) {
              intCheck(sd, 1, MAX);
              if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
              return round(new BigNumber2(x), sd, rm);
            }

            if (!(c = x.c)) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if (v = c[v]) {
              for (; v % 10 == 0; v /= 10, n--) {
                ;
              }

              for (v = c[0]; v >= 10; v /= 10, n++) {
                ;
              }
            }

            if (sd && x.e + 1 > n) n = x.e + 1;
            return n;
          };

          P.shiftedBy = function (k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times("1e" + k);
          };

          P.squareRoot = P.sqrt = function () {
            var m,
                n,
                r,
                rep,
                t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber2("0.5");

            if (s !== 1 || !c || !c[0]) {
              return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            }

            s = Math.sqrt(+valueOf(x));

            if (s == 0 || s == 1 / 0) {
              n = coeffToString(c);
              if ((n.length + e) % 2 == 0) n += "0";
              s = Math.sqrt(+n);
              e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

              if (s == 1 / 0) {
                n = "5e" + e;
              } else {
                n = s.toExponential();
                n = n.slice(0, n.indexOf("e") + 1) + e;
              }

              r = new BigNumber2(n);
            } else {
              r = new BigNumber2(s + "");
            }

            if (r.c[0]) {
              e = r.e;
              s = e + dp;
              if (s < 3) s = 0;

              for (;;) {
                t = r;
                r = half.times(t.plus(div(x, t, dp, 1)));

                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                  if (r.e < e) --s;
                  n = n.slice(s - 3, s + 1);

                  if (n == "9999" || !rep && n == "4999") {
                    if (!rep) {
                      round(t, t.e + DECIMAL_PLACES + 2, 0);

                      if (t.times(t).eq(x)) {
                        r = t;
                        break;
                      }
                    }

                    dp += 4;
                    s += 4;
                    rep = 1;
                  } else {
                    if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                      round(r, r.e + DECIMAL_PLACES + 2, 1);
                      m = !r.times(r).eq(x);
                    }

                    break;
                  }
                }
              }
            }

            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
          };

          P.toExponential = function (dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp++;
            }

            return format(this, dp, rm, 1);
          };

          P.toFixed = function (dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp = dp + this.e + 1;
            }

            return format(this, dp, rm);
          };

          P.toFormat = function (dp, rm, format2) {
            var str,
                x = this;

            if (format2 == null) {
              if (dp != null && rm && typeof rm == "object") {
                format2 = rm;
                rm = null;
              } else if (dp && typeof dp == "object") {
                format2 = dp;
                dp = rm = null;
              } else {
                format2 = FORMAT;
              }
            } else if (typeof format2 != "object") {
              throw Error(bignumberError + "Argument not an object: " + format2);
            }

            str = x.toFixed(dp, rm);

            if (x.c) {
              var i,
                  arr = str.split("."),
                  g1 = +format2.groupSize,
                  g2 = +format2.secondaryGroupSize,
                  groupSeparator = format2.groupSeparator || "",
                  intPart = arr[0],
                  fractionPart = arr[1],
                  isNeg = x.s < 0,
                  intDigits = isNeg ? intPart.slice(1) : intPart,
                  len = intDigits.length;

              if (g2) {
                i = g1;
                g1 = g2;
                g2 = i;
                len -= i;
              }

              if (g1 > 0 && len > 0) {
                i = len % g1 || g1;
                intPart = intDigits.substr(0, i);

                for (; i < len; i += g1) {
                  intPart += groupSeparator + intDigits.substr(i, g1);
                }

                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                if (isNeg) intPart = "-" + intPart;
              }

              str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
            }

            return (format2.prefix || "") + str + (format2.suffix || "");
          };

          P.toFraction = function (md) {
            var d,
                d0,
                d1,
                d2,
                e,
                exp,
                n,
                n0,
                n1,
                q,
                r,
                s,
                x = this,
                xc = x.c;

            if (md != null) {
              n = new BigNumber2(md);

              if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
              }
            }

            if (!xc) return new BigNumber2(x);
            d = new BigNumber2(ONE);
            n1 = d0 = new BigNumber2(ONE);
            d1 = n0 = new BigNumber2(ONE);
            s = coeffToString(xc);
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber2(s);
            n0.c[0] = 0;

            for (;;) {
              q = div(n, d, 0, 1);
              d2 = d0.plus(q.times(d1));
              if (d2.comparedTo(md) == 1) break;
              d0 = d1;
              d1 = d2;
              n1 = n0.plus(q.times(d2 = n1));
              n0 = d2;
              d = n.minus(q.times(d2 = d));
              n = d2;
            }

            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
            MAX_EXP = exp;
            return r;
          };

          P.toNumber = function () {
            return +valueOf(this);
          };

          P.toPrecision = function (sd, rm) {
            if (sd != null) intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
          };

          P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            if (e === null) {
              if (s) {
                str = "Infinity";
                if (s < 0) str = "-" + str;
              } else {
                str = "NaN";
              }
            } else {
              if (b == null) {
                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
              } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n.c), n.e, "0");
              } else {
                intCheck(b, 2, ALPHABET.length, "Base");
                str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
              }

              if (s < 0 && n.c[0]) str = "-" + str;
            }

            return str;
          };

          P.valueOf = P.toJSON = function () {
            return valueOf(this);
          };

          P._isBigNumber = true;
          if (configObject != null) BigNumber2.set(configObject);
          return BigNumber2;
        }

        function bitFloor(n) {
          var i = n | 0;
          return n > 0 || n === i ? i : i - 1;
        }

        function coeffToString(a) {
          var s,
              z,
              i = 1,
              j = a.length,
              r = a[0] + "";

          for (; i < j;) {
            s = a[i++] + "";
            z = LOG_BASE - s.length;

            for (; z--; s = "0" + s) {
              ;
            }

            r += s;
          }

          for (j = r.length; r.charCodeAt(--j) === 48;) {
            ;
          }

          return r.slice(0, j + 1 || 1);
        }

        function compare(x, y) {
          var a,
              b,
              xc = x.c,
              yc = y.c,
              i = x.s,
              j = y.s,
              k = x.e,
              l = y.e;
          if (!i || !j) return null;
          a = xc && !xc[0];
          b = yc && !yc[0];
          if (a || b) return a ? b ? 0 : -j : i;
          if (i != j) return i;
          a = i < 0;
          b = k == l;
          if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
          if (!b) return k > l ^ a ? 1 : -1;
          j = (k = xc.length) < (l = yc.length) ? k : l;

          for (i = 0; i < j; i++) {
            if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
          }

          return k == l ? 0 : k > l ^ a ? 1 : -1;
        }

        function intCheck(n, min, max, name) {
          if (n < min || n > max || n !== mathfloor(n)) {
            throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
          }
        }

        function isOdd(n) {
          var k = n.c.length - 1;
          return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
        }

        function toExponential(str, e) {
          return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
        }

        function toFixedPoint(str, e, z) {
          var len, zs;

          if (e < 0) {
            for (zs = z + "."; ++e; zs += z) {
              ;
            }

            str = zs + str;
          } else {
            len = str.length;

            if (++e > len) {
              for (zs = z, e -= len; --e; zs += z) {
                ;
              }

              str += zs;
            } else if (e < len) {
              str = str.slice(0, e) + "." + str.slice(e);
            }
          }

          return str;
        }

        BigNumber = clone();
        BigNumber["default"] = BigNumber.BigNumber = BigNumber;

        if (typeof define == "function" && define.amd) {
          define(function () {
            return BigNumber;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = BigNumber;
        } else {
          if (!globalObject) {
            globalObject = typeof self != "undefined" && self ? self : window;
          }

          globalObject.BigNumber = BigNumber;
        }
      })(exports);
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/decoder.asm.js


  var require_decoder_asm = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/decoder.asm.js": function node_modulesDfinityAgentNode_modulesBorcSrcDecoderAsmJs(exports, module) {
      module.exports = function decodeAsm(stdlib, foreign, buffer) {
        ;
        var heap = new stdlib.Uint8Array(buffer);
        var pushInt = foreign.pushInt;
        var pushInt32 = foreign.pushInt32;
        var pushInt32Neg = foreign.pushInt32Neg;
        var pushInt64 = foreign.pushInt64;
        var pushInt64Neg = foreign.pushInt64Neg;
        var pushFloat = foreign.pushFloat;
        var pushFloatSingle = foreign.pushFloatSingle;
        var pushFloatDouble = foreign.pushFloatDouble;
        var pushTrue = foreign.pushTrue;
        var pushFalse = foreign.pushFalse;
        var pushUndefined = foreign.pushUndefined;
        var pushNull = foreign.pushNull;
        var pushInfinity = foreign.pushInfinity;
        var pushInfinityNeg = foreign.pushInfinityNeg;
        var pushNaN = foreign.pushNaN;
        var pushNaNNeg = foreign.pushNaNNeg;
        var pushArrayStart = foreign.pushArrayStart;
        var pushArrayStartFixed = foreign.pushArrayStartFixed;
        var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
        var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
        var pushObjectStart = foreign.pushObjectStart;
        var pushObjectStartFixed = foreign.pushObjectStartFixed;
        var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
        var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
        var pushByteString = foreign.pushByteString;
        var pushByteStringStart = foreign.pushByteStringStart;
        var pushUtf8String = foreign.pushUtf8String;
        var pushUtf8StringStart = foreign.pushUtf8StringStart;
        var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
        var pushTagStart = foreign.pushTagStart;
        var pushTagStart4 = foreign.pushTagStart4;
        var pushTagStart8 = foreign.pushTagStart8;
        var pushTagUnassigned = foreign.pushTagUnassigned;
        var pushBreak = foreign.pushBreak;
        var pow = stdlib.Math.pow;
        var offset = 0;
        var inputLength = 0;
        var code = 0;

        function parse(input) {
          input = input | 0;
          offset = 0;
          inputLength = input;

          while ((offset | 0) < (inputLength | 0)) {
            code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;

            if ((code | 0) > 0) {
              break;
            }
          }

          return code | 0;
        }

        function checkOffset(n) {
          n = n | 0;

          if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
            return 0;
          }

          return 1;
        }

        function readUInt16(n) {
          n = n | 0;
          return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
        }

        function readUInt32(n) {
          n = n | 0;
          return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
        }

        function INT_P(octet) {
          octet = octet | 0;
          pushInt(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function UINT_P_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushInt(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function UINT_P_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushInt(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function UINT_P_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushInt32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function UINT_P_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushInt64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function INT_N(octet) {
          octet = octet | 0;
          pushInt(-1 - (octet - 32 | 0) | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function UINT_N_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushInt(-1 - (heap[offset + 1 | 0] | 0) | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function UINT_N_16(octet) {
          octet = octet | 0;
          var val = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          val = readUInt16(offset + 1 | 0) | 0;
          pushInt(-1 - (val | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function UINT_N_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushInt32Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function UINT_N_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushInt64Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function BYTE_STRING(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var step = 0;
          step = octet - 64 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          start = offset + 1 | 0;
          end = (offset + 1 | 0) + (step | 0) | 0;
          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_8(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          length = heap[offset + 1 | 0] | 0;
          start = offset + 2 | 0;
          end = (offset + 2 | 0) + (length | 0) | 0;

          if (checkOffset(length + 1 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_16(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          length = readUInt16(offset + 1 | 0) | 0;
          start = offset + 3 | 0;
          end = (offset + 3 | 0) + (length | 0) | 0;

          if (checkOffset(length + 2 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_32(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          length = readUInt32(offset + 1 | 0) | 0;
          start = offset + 5 | 0;
          end = (offset + 5 | 0) + (length | 0) | 0;

          if (checkOffset(length + 4 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_64(octet) {
          octet = octet | 0;
          return 1;
        }

        function BYTE_STRING_BREAK(octet) {
          octet = octet | 0;
          pushByteStringStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function UTF8_STRING(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var step = 0;
          step = octet - 96 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          start = offset + 1 | 0;
          end = (offset + 1 | 0) + (step | 0) | 0;
          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_8(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          length = heap[offset + 1 | 0] | 0;
          start = offset + 2 | 0;
          end = (offset + 2 | 0) + (length | 0) | 0;

          if (checkOffset(length + 1 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_16(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          length = readUInt16(offset + 1 | 0) | 0;
          start = offset + 3 | 0;
          end = (offset + 3 | 0) + (length | 0) | 0;

          if (checkOffset(length + 2 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_32(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          length = readUInt32(offset + 1 | 0) | 0;
          start = offset + 5 | 0;
          end = (offset + 5 | 0) + (length | 0) | 0;

          if (checkOffset(length + 4 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_64(octet) {
          octet = octet | 0;
          return 1;
        }

        function UTF8_STRING_BREAK(octet) {
          octet = octet | 0;
          pushUtf8StringStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function ARRAY(octet) {
          octet = octet | 0;
          pushArrayStartFixed(octet - 128 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function ARRAY_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushArrayStartFixed(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function ARRAY_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushArrayStartFixed(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function ARRAY_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushArrayStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function ARRAY_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushArrayStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function ARRAY_BREAK(octet) {
          octet = octet | 0;
          pushArrayStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function MAP(octet) {
          octet = octet | 0;
          var step = 0;
          step = octet - 160 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          pushObjectStartFixed(step | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function MAP_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushObjectStartFixed(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function MAP_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushObjectStartFixed(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function MAP_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushObjectStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function MAP_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushObjectStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function MAP_BREAK(octet) {
          octet = octet | 0;
          pushObjectStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_KNOWN(octet) {
          octet = octet | 0;
          pushTagStart(octet - 192 | 0 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_POS(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_NEG(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_FRAC(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_FLOAT(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_UNASSIGNED(octet) {
          octet = octet | 0;
          pushTagStart(octet - 192 | 0 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE64_URL(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE64(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE16(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_MORE_1(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushTagStart(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function TAG_MORE_2(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushTagStart(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function TAG_MORE_4(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushTagStart4(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function TAG_MORE_8(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushTagStart8(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function SIMPLE_UNASSIGNED(octet) {
          octet = octet | 0;
          pushSimpleUnassigned((octet | 0) - 224 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_FALSE(octet) {
          octet = octet | 0;
          pushFalse();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_TRUE(octet) {
          octet = octet | 0;
          pushTrue();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_NULL(octet) {
          octet = octet | 0;
          pushNull();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_UNDEFINED(octet) {
          octet = octet | 0;
          pushUndefined();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_BYTE(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_HALF(octet) {
          octet = octet | 0;
          var f = 0;
          var g = 0;
          var sign = 1;
          var exp = 0;
          var mant = 0;
          var r = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          f = heap[offset + 1 | 0] | 0;
          g = heap[offset + 2 | 0] | 0;

          if ((f | 0) & 128) {
            sign = -1;
          }

          exp = +(((f | 0) & 124) >> 2);
          mant = +(((f | 0) & 3) << 8 | g);

          if (+exp == 0) {
            pushFloat(+(+sign * 5960464477539063e-23 * +mant));
          } else if (+exp == 31) {
            if (+sign == 1) {
              if (+mant > 0) {
                pushNaN();
              } else {
                pushInfinity();
              }
            } else {
              if (+mant > 0) {
                pushNaNNeg();
              } else {
                pushInfinityNeg();
              }
            }
          } else {
            pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
          }

          offset = offset + 3 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_SINGLE(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushFloatSingle(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_DOUBLE(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushFloatDouble(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0, heap[offset + 5 | 0] | 0, heap[offset + 6 | 0] | 0, heap[offset + 7 | 0] | 0, heap[offset + 8 | 0] | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function ERROR(octet) {
          octet = octet | 0;
          return 1;
        }

        function BREAK(octet) {
          octet = octet | 0;
          pushBreak();
          offset = offset + 1 | 0;
          return 0;
        }

        var jumpTable = [// Integer 0x00..0x17 (0..23)
        INT_P, // 0x00
        INT_P, // 0x01
        INT_P, // 0x02
        INT_P, // 0x03
        INT_P, // 0x04
        INT_P, // 0x05
        INT_P, // 0x06
        INT_P, // 0x07
        INT_P, // 0x08
        INT_P, // 0x09
        INT_P, // 0x0A
        INT_P, // 0x0B
        INT_P, // 0x0C
        INT_P, // 0x0D
        INT_P, // 0x0E
        INT_P, // 0x0F
        INT_P, // 0x10
        INT_P, // 0x11
        INT_P, // 0x12
        INT_P, // 0x13
        INT_P, // 0x14
        INT_P, // 0x15
        INT_P, // 0x16
        INT_P, // 0x17
        // Unsigned integer (one-byte uint8_t follows)
        UINT_P_8, // 0x18
        // Unsigned integer (two-byte uint16_t follows)
        UINT_P_16, // 0x19
        // Unsigned integer (four-byte uint32_t follows)
        UINT_P_32, // 0x1a
        // Unsigned integer (eight-byte uint64_t follows)
        UINT_P_64, // 0x1b
        ERROR, // 0x1c
        ERROR, // 0x1d
        ERROR, // 0x1e
        ERROR, // 0x1f
        // Negative integer -1-0x00..-1-0x17 (-1..-24)
        INT_N, // 0x20
        INT_N, // 0x21
        INT_N, // 0x22
        INT_N, // 0x23
        INT_N, // 0x24
        INT_N, // 0x25
        INT_N, // 0x26
        INT_N, // 0x27
        INT_N, // 0x28
        INT_N, // 0x29
        INT_N, // 0x2A
        INT_N, // 0x2B
        INT_N, // 0x2C
        INT_N, // 0x2D
        INT_N, // 0x2E
        INT_N, // 0x2F
        INT_N, // 0x30
        INT_N, // 0x31
        INT_N, // 0x32
        INT_N, // 0x33
        INT_N, // 0x34
        INT_N, // 0x35
        INT_N, // 0x36
        INT_N, // 0x37
        // Negative integer -1-n (one-byte uint8_t for n follows)
        UINT_N_8, // 0x38
        // Negative integer -1-n (two-byte uint16_t for n follows)
        UINT_N_16, // 0x39
        // Negative integer -1-n (four-byte uint32_t for nfollows)
        UINT_N_32, // 0x3a
        // Negative integer -1-n (eight-byte uint64_t for n follows)
        UINT_N_64, // 0x3b
        ERROR, // 0x3c
        ERROR, // 0x3d
        ERROR, // 0x3e
        ERROR, // 0x3f
        // byte string (0x00..0x17 bytes follow)
        BYTE_STRING, // 0x40
        BYTE_STRING, // 0x41
        BYTE_STRING, // 0x42
        BYTE_STRING, // 0x43
        BYTE_STRING, // 0x44
        BYTE_STRING, // 0x45
        BYTE_STRING, // 0x46
        BYTE_STRING, // 0x47
        BYTE_STRING, // 0x48
        BYTE_STRING, // 0x49
        BYTE_STRING, // 0x4A
        BYTE_STRING, // 0x4B
        BYTE_STRING, // 0x4C
        BYTE_STRING, // 0x4D
        BYTE_STRING, // 0x4E
        BYTE_STRING, // 0x4F
        BYTE_STRING, // 0x50
        BYTE_STRING, // 0x51
        BYTE_STRING, // 0x52
        BYTE_STRING, // 0x53
        BYTE_STRING, // 0x54
        BYTE_STRING, // 0x55
        BYTE_STRING, // 0x56
        BYTE_STRING, // 0x57
        // byte string (one-byte uint8_t for n, and then n bytes follow)
        BYTE_STRING_8, // 0x58
        // byte string (two-byte uint16_t for n, and then n bytes follow)
        BYTE_STRING_16, // 0x59
        // byte string (four-byte uint32_t for n, and then n bytes follow)
        BYTE_STRING_32, // 0x5a
        // byte string (eight-byte uint64_t for n, and then n bytes follow)
        BYTE_STRING_64, // 0x5b
        ERROR, // 0x5c
        ERROR, // 0x5d
        ERROR, // 0x5e
        // byte string, byte strings follow, terminated by "break"
        BYTE_STRING_BREAK, // 0x5f
        // UTF-8 string (0x00..0x17 bytes follow)
        UTF8_STRING, // 0x60
        UTF8_STRING, // 0x61
        UTF8_STRING, // 0x62
        UTF8_STRING, // 0x63
        UTF8_STRING, // 0x64
        UTF8_STRING, // 0x65
        UTF8_STRING, // 0x66
        UTF8_STRING, // 0x67
        UTF8_STRING, // 0x68
        UTF8_STRING, // 0x69
        UTF8_STRING, // 0x6A
        UTF8_STRING, // 0x6B
        UTF8_STRING, // 0x6C
        UTF8_STRING, // 0x6D
        UTF8_STRING, // 0x6E
        UTF8_STRING, // 0x6F
        UTF8_STRING, // 0x70
        UTF8_STRING, // 0x71
        UTF8_STRING, // 0x72
        UTF8_STRING, // 0x73
        UTF8_STRING, // 0x74
        UTF8_STRING, // 0x75
        UTF8_STRING, // 0x76
        UTF8_STRING, // 0x77
        // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
        UTF8_STRING_8, // 0x78
        // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
        UTF8_STRING_16, // 0x79
        // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
        UTF8_STRING_32, // 0x7a
        // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
        UTF8_STRING_64, // 0x7b
        // UTF-8 string, UTF-8 strings follow, terminated by "break"
        ERROR, // 0x7c
        ERROR, // 0x7d
        ERROR, // 0x7e
        UTF8_STRING_BREAK, // 0x7f
        // array (0x00..0x17 data items follow)
        ARRAY, // 0x80
        ARRAY, // 0x81
        ARRAY, // 0x82
        ARRAY, // 0x83
        ARRAY, // 0x84
        ARRAY, // 0x85
        ARRAY, // 0x86
        ARRAY, // 0x87
        ARRAY, // 0x88
        ARRAY, // 0x89
        ARRAY, // 0x8A
        ARRAY, // 0x8B
        ARRAY, // 0x8C
        ARRAY, // 0x8D
        ARRAY, // 0x8E
        ARRAY, // 0x8F
        ARRAY, // 0x90
        ARRAY, // 0x91
        ARRAY, // 0x92
        ARRAY, // 0x93
        ARRAY, // 0x94
        ARRAY, // 0x95
        ARRAY, // 0x96
        ARRAY, // 0x97
        // array (one-byte uint8_t fo, and then n data items follow)
        ARRAY_8, // 0x98
        // array (two-byte uint16_t for n, and then n data items follow)
        ARRAY_16, // 0x99
        // array (four-byte uint32_t for n, and then n data items follow)
        ARRAY_32, // 0x9a
        // array (eight-byte uint64_t for n, and then n data items follow)
        ARRAY_64, // 0x9b
        // array, data items follow, terminated by "break"
        ERROR, // 0x9c
        ERROR, // 0x9d
        ERROR, // 0x9e
        ARRAY_BREAK, // 0x9f
        // map (0x00..0x17 pairs of data items follow)
        MAP, // 0xa0
        MAP, // 0xa1
        MAP, // 0xa2
        MAP, // 0xa3
        MAP, // 0xa4
        MAP, // 0xa5
        MAP, // 0xa6
        MAP, // 0xa7
        MAP, // 0xa8
        MAP, // 0xa9
        MAP, // 0xaA
        MAP, // 0xaB
        MAP, // 0xaC
        MAP, // 0xaD
        MAP, // 0xaE
        MAP, // 0xaF
        MAP, // 0xb0
        MAP, // 0xb1
        MAP, // 0xb2
        MAP, // 0xb3
        MAP, // 0xb4
        MAP, // 0xb5
        MAP, // 0xb6
        MAP, // 0xb7
        // map (one-byte uint8_t for n, and then n pairs of data items follow)
        MAP_8, // 0xb8
        // map (two-byte uint16_t for n, and then n pairs of data items follow)
        MAP_16, // 0xb9
        // map (four-byte uint32_t for n, and then n pairs of data items follow)
        MAP_32, // 0xba
        // map (eight-byte uint64_t for n, and then n pairs of data items follow)
        MAP_64, // 0xbb
        ERROR, // 0xbc
        ERROR, // 0xbd
        ERROR, // 0xbe
        // map, pairs of data items follow, terminated by "break"
        MAP_BREAK, // 0xbf
        // Text-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc0
        // Epoch-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc1
        // Positive bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc2
        // Negative bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc3
        // Decimal Fraction (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc4
        // Bigfloat (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc5
        // (tagged item)
        TAG_UNASSIGNED, // 0xc6
        TAG_UNASSIGNED, // 0xc7
        TAG_UNASSIGNED, // 0xc8
        TAG_UNASSIGNED, // 0xc9
        TAG_UNASSIGNED, // 0xca
        TAG_UNASSIGNED, // 0xcb
        TAG_UNASSIGNED, // 0xcc
        TAG_UNASSIGNED, // 0xcd
        TAG_UNASSIGNED, // 0xce
        TAG_UNASSIGNED, // 0xcf
        TAG_UNASSIGNED, // 0xd0
        TAG_UNASSIGNED, // 0xd1
        TAG_UNASSIGNED, // 0xd2
        TAG_UNASSIGNED, // 0xd3
        TAG_UNASSIGNED, // 0xd4
        // Expected Conversion (data item follows; see Section 2.4.4.2)
        TAG_UNASSIGNED, // 0xd5
        TAG_UNASSIGNED, // 0xd6
        TAG_UNASSIGNED, // 0xd7
        // (more tagged items, 1/2/4/8 bytes and then a data item follow)
        TAG_MORE_1, // 0xd8
        TAG_MORE_2, // 0xd9
        TAG_MORE_4, // 0xda
        TAG_MORE_8, // 0xdb
        ERROR, // 0xdc
        ERROR, // 0xdd
        ERROR, // 0xde
        ERROR, // 0xdf
        // (simple value)
        SIMPLE_UNASSIGNED, // 0xe0
        SIMPLE_UNASSIGNED, // 0xe1
        SIMPLE_UNASSIGNED, // 0xe2
        SIMPLE_UNASSIGNED, // 0xe3
        SIMPLE_UNASSIGNED, // 0xe4
        SIMPLE_UNASSIGNED, // 0xe5
        SIMPLE_UNASSIGNED, // 0xe6
        SIMPLE_UNASSIGNED, // 0xe7
        SIMPLE_UNASSIGNED, // 0xe8
        SIMPLE_UNASSIGNED, // 0xe9
        SIMPLE_UNASSIGNED, // 0xea
        SIMPLE_UNASSIGNED, // 0xeb
        SIMPLE_UNASSIGNED, // 0xec
        SIMPLE_UNASSIGNED, // 0xed
        SIMPLE_UNASSIGNED, // 0xee
        SIMPLE_UNASSIGNED, // 0xef
        SIMPLE_UNASSIGNED, // 0xf0
        SIMPLE_UNASSIGNED, // 0xf1
        SIMPLE_UNASSIGNED, // 0xf2
        SIMPLE_UNASSIGNED, // 0xf3
        // False
        SIMPLE_FALSE, // 0xf4
        // True
        SIMPLE_TRUE, // 0xf5
        // Null
        SIMPLE_NULL, // 0xf6
        // Undefined
        SIMPLE_UNDEFINED, // 0xf7
        // (simple value, one byte follows)
        SIMPLE_BYTE, // 0xf8
        // Half-Precision Float (two-byte IEEE 754)
        SIMPLE_FLOAT_HALF, // 0xf9
        // Single-Precision Float (four-byte IEEE 754)
        SIMPLE_FLOAT_SINGLE, // 0xfa
        // Double-Precision Float (eight-byte IEEE 754)
        SIMPLE_FLOAT_DOUBLE, // 0xfb
        ERROR, // 0xfc
        ERROR, // 0xfd
        ERROR, // 0xfe
        // "break" stop code
        BREAK // 0xff
        ];
        return {
          parse: parse
        };
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/constants.js


  var require_constants = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/constants.js": function node_modulesDfinityAgentNode_modulesBorcSrcConstantsJs(exports) {
      "use strict";

      var Bignumber = require_bignumber().BigNumber;
      exports.MT = {
        POS_INT: 0,
        NEG_INT: 1,
        BYTE_STRING: 2,
        UTF8_STRING: 3,
        ARRAY: 4,
        MAP: 5,
        TAG: 6,
        SIMPLE_FLOAT: 7
      };
      exports.TAG = {
        DATE_STRING: 0,
        DATE_EPOCH: 1,
        POS_BIGINT: 2,
        NEG_BIGINT: 3,
        DECIMAL_FRAC: 4,
        BIGFLOAT: 5,
        BASE64URL_EXPECTED: 21,
        BASE64_EXPECTED: 22,
        BASE16_EXPECTED: 23,
        CBOR: 24,
        URI: 32,
        BASE64URL: 33,
        BASE64: 34,
        REGEXP: 35,
        MIME: 36
      };
      exports.NUMBYTES = {
        ZERO: 0,
        ONE: 24,
        TWO: 25,
        FOUR: 26,
        EIGHT: 27,
        INDEFINITE: 31
      };
      exports.SIMPLE = {
        FALSE: 20,
        TRUE: 21,
        NULL: 22,
        UNDEFINED: 23
      };
      exports.SYMS = {
        NULL: Symbol("null"),
        UNDEFINED: Symbol("undef"),
        PARENT: Symbol("parent"),
        BREAK: Symbol("break"),
        STREAM: Symbol("stream")
      };
      exports.SHIFT32 = Math.pow(2, 32);
      exports.SHIFT16 = Math.pow(2, 16);
      exports.MAX_SAFE_HIGH = 2097151;
      exports.NEG_ONE = new Bignumber(-1);
      exports.TEN = new Bignumber(10);
      exports.TWO = new Bignumber(2);
      exports.PARENT = {
        ARRAY: 0,
        OBJECT: 1,
        MAP: 2,
        TAG: 3,
        BYTE_STRING: 4,
        UTF8_STRING: 5
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/utils.js


  var require_utils2 = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/utils.js": function node_modulesDfinityAgentNode_modulesBorcSrcUtilsJs(exports) {
      "use strict";

      var _require_buffer = require_buffer4(),
          Buffer2 = _require_buffer.Buffer;

      var Bignumber = require_bignumber().BigNumber;
      var constants = require_constants();
      var SHIFT32 = constants.SHIFT32;
      var SHIFT16 = constants.SHIFT16;
      var MAX_SAFE_HIGH = 2097151;

      exports.parseHalf = function parseHalf(buf) {
        var exp, mant, sign;
        sign = buf[0] & 128 ? -1 : 1;
        exp = (buf[0] & 124) >> 2;
        mant = (buf[0] & 3) << 8 | buf[1];

        if (!exp) {
          return sign * 5960464477539063e-23 * mant;
        } else if (exp === 31) {
          return sign * (mant ? 0 / 0 : Infinity);
        } else {
          return sign * Math.pow(2, exp - 25) * (1024 + mant);
        }
      };

      function toHex(n) {
        if (n < 16) {
          return "0" + n.toString(16);
        }

        return n.toString(16);
      }

      exports.arrayBufferToBignumber = function (buf) {
        var len = buf.byteLength;
        var res = "";

        for (var i = 0; i < len; i++) {
          res += toHex(buf[i]);
        }

        return new Bignumber(res, 16);
      };

      exports.buildMap = function (obj) {
        var res = /* @__PURE__ */new Map();
        var keys = Object.keys(obj);
        var length = keys.length;

        for (var i = 0; i < length; i++) {
          res.set(keys[i], obj[keys[i]]);
        }

        return res;
      };

      exports.buildInt32 = function (f, g) {
        return f * SHIFT16 + g;
      };

      exports.buildInt64 = function (f1, f2, g1, g2) {
        var f = exports.buildInt32(f1, f2);
        var g = exports.buildInt32(g1, g2);

        if (f > MAX_SAFE_HIGH) {
          return new Bignumber(f).times(SHIFT32).plus(g);
        } else {
          return f * SHIFT32 + g;
        }
      };

      exports.writeHalf = function writeHalf(buf, half) {
        var u32 = Buffer2.allocUnsafe(4);
        u32.writeFloatBE(half, 0);
        var u = u32.readUInt32BE(0);

        if ((u & 8191) !== 0) {
          return false;
        }

        var s16 = u >> 16 & 32768;
        var exp = u >> 23 & 255;
        var mant = u & 8388607;

        if (exp >= 113 && exp <= 142) {
          s16 += (exp - 112 << 10) + (mant >> 13);
        } else if (exp >= 103 && exp < 113) {
          if (mant & (1 << 126 - exp) - 1) {
            return false;
          }

          s16 += mant + 8388608 >> 126 - exp;
        } else {
          return false;
        }

        buf.writeUInt16BE(s16, 0);
        return true;
      };

      exports.keySorter = function (a, b) {
        var lenA = a[0].byteLength;
        var lenB = b[0].byteLength;

        if (lenA > lenB) {
          return 1;
        }

        if (lenB > lenA) {
          return -1;
        }

        return a[0].compare(b[0]);
      };

      exports.isNegativeZero = function (x) {
        return x === 0 && 1 / x < 0;
      };

      exports.nextPowerOf2 = function (n) {
        var count = 0;

        if (n && !(n & n - 1)) {
          return n;
        }

        while (n !== 0) {
          n >>= 1;
          count += 1;
        }

        return 1 << count;
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/simple.js


  var require_simple = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/simple.js": function node_modulesDfinityAgentNode_modulesBorcSrcSimpleJs(exports, module) {
      "use strict";

      var constants = require_constants();
      var MT = constants.MT;
      var SIMPLE = constants.SIMPLE;
      var SYMS = constants.SYMS;

      var Simple = /*#__PURE__*/function () {
        /**
         * Creates an instance of Simple.
         *
         * @param {integer} value - the simple value's integer value
         */
        function _Simple(value) {
          if (typeof value !== "number") {
            throw new Error("Invalid Simple type: " + typeof value);
          }

          if (value < 0 || value > 255 || (value | 0) !== value) {
            throw new Error("value must be a small positive integer: " + value);
          }

          this.value = value;
        }
        /**
         * Debug string for simple value
         *
         * @returns {string} simple(value)
         */


        var _proto43 = _Simple.prototype;

        _proto43.toString = function toString() {
          return "simple(" + this.value + ")";
        }
        /**
         * Debug string for simple value
         *
         * @returns {string} simple(value)
         */
        ;

        _proto43.inspect = function inspect() {
          return "simple(" + this.value + ")";
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {cbor.Encoder} gen The generator to push onto
         * @returns {number}
         */
        ;

        _proto43.encodeCBOR = function encodeCBOR(gen) {
          return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
        }
        /**
         * Is the given object a Simple?
         *
         * @param {any} obj - object to test
         * @returns {bool} - is it Simple?
         */
        ;

        _Simple.isSimple = function isSimple(obj) {
          return obj instanceof _Simple;
        }
        /**
         * Decode from the CBOR additional information into a JavaScript value.
         * If the CBOR item has no parent, return a "safe" symbol instead of
         * `null` or `undefined`, so that the value can be passed through a
         * stream in object mode.
         *
         * @param {Number} val - the CBOR additional info to convert
         * @param {bool} hasParent - Does the CBOR item have a parent?
         * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
         */
        ;

        _Simple.decode = function decode(val, hasParent) {
          if (hasParent == null) {
            hasParent = true;
          }

          switch (val) {
            case SIMPLE.FALSE:
              return false;

            case SIMPLE.TRUE:
              return true;

            case SIMPLE.NULL:
              if (hasParent) {
                return null;
              } else {
                return SYMS.NULL;
              }

            case SIMPLE.UNDEFINED:
              if (hasParent) {
                return void 0;
              } else {
                return SYMS.UNDEFINED;
              }

            case -1:
              if (!hasParent) {
                throw new Error("Invalid BREAK");
              }

              return SYMS.BREAK;

            default:
              return new _Simple(val);
          }
        };

        return _Simple;
      }();

      module.exports = Simple;
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/tagged.js


  var require_tagged = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/tagged.js": function node_modulesDfinityAgentNode_modulesBorcSrcTaggedJs(exports, module) {
      "use strict";

      var Tagged = /*#__PURE__*/function () {
        /**
         * Creates an instance of Tagged.
         *
         * @param {Number} tag - the number of the tag
         * @param {any} value - the value inside the tag
         * @param {Error} err - the error that was thrown parsing the tag, or null
         */
        function _Tagged(tag, value, err) {
          this.tag = tag;
          this.value = value;
          this.err = err;

          if (typeof this.tag !== "number") {
            throw new Error("Invalid tag type (" + typeof this.tag + ")");
          }

          if (this.tag < 0 || (this.tag | 0) !== this.tag) {
            throw new Error("Tag must be a positive integer: " + this.tag);
          }
        }
        /**
         * Convert to a String
         *
         * @returns {String} string of the form '1(2)'
         */


        var _proto44 = _Tagged.prototype;

        _proto44.toString = function toString() {
          return this.tag + "(" + JSON.stringify(this.value) + ")";
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {cbor.Encoder} gen The generator to push onto
         * @returns {number}
         */
        ;

        _proto44.encodeCBOR = function encodeCBOR(gen) {
          gen._pushTag(this.tag);

          return gen.pushAny(this.value);
        }
        /**
         * If we have a converter for this type, do the conversion.  Some converters
         * are built-in.  Additional ones can be passed in.  If you want to remove
         * a built-in converter, pass a converter in whose value is 'null' instead
         * of a function.
         *
         * @param {Object} converters - keys in the object are a tag number, the value
         *   is a function that takes the decoded CBOR and returns a JavaScript value
         *   of the appropriate type.  Throw an exception in the function on errors.
         * @returns {any} - the converted item
         */
        ;

        _proto44.convert = function convert(converters) {
          var er, f;
          f = converters != null ? converters[this.tag] : void 0;

          if (typeof f !== "function") {
            f = _Tagged["_tag" + this.tag];

            if (typeof f !== "function") {
              return this;
            }
          }

          try {
            return f.call(_Tagged, this.value);
          } catch (error) {
            er = error;
            this.err = er;
            return this;
          }
        };

        return _Tagged;
      }();

      module.exports = Tagged;
    }
  }); // node_modules/@dfinity/agent/node_modules/iso-url/src/url-browser.js


  var require_url_browser = __commonJS({
    "node_modules/@dfinity/agent/node_modules/iso-url/src/url-browser.js": function node_modulesDfinityAgentNode_modulesIsoUrlSrcUrlBrowserJs(exports, module) {
      "use strict";

      var defaultBase = self.location ? self.location.protocol + "//" + self.location.host : "";
      var URL2 = self.URL;

      var URLWithLegacySupport = /*#__PURE__*/function () {
        function URLWithLegacySupport(url, base) {
          if (url === void 0) {
            url = "";
          }

          if (base === void 0) {
            base = defaultBase;
          }

          this["super"] = new URL2(url, base);
          this.path = this.pathname + this.search;
          this.auth = this.username && this.password ? this.username + ":" + this.password : null;
          this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
        }

        var _proto45 = URLWithLegacySupport.prototype;

        _proto45.createObjectURL = function createObjectURL(o) {
          return this["super"].createObjectURL(o);
        };

        _proto45.revokeObjectURL = function revokeObjectURL(o) {
          this["super"].revokeObjectURL(o);
        };

        _proto45.toJSON = function toJSON() {
          return this["super"].toJSON();
        };

        _proto45.toString = function toString() {
          return this["super"].toString();
        };

        _proto45.format = function format() {
          return this.toString();
        };

        _createClass(URLWithLegacySupport, [{
          key: "hash",
          get: function get() {
            return this["super"].hash;
          },
          set: function set(hash) {
            this["super"].hash = hash;
          }
        }, {
          key: "host",
          get: function get() {
            return this["super"].host;
          },
          set: function set(host) {
            this["super"].host = host;
          }
        }, {
          key: "hostname",
          get: function get() {
            return this["super"].hostname;
          },
          set: function set(hostname) {
            this["super"].hostname = hostname;
          }
        }, {
          key: "href",
          get: function get() {
            return this["super"].href;
          },
          set: function set(href) {
            this["super"].href = href;
          }
        }, {
          key: "origin",
          get: function get() {
            return this["super"].origin;
          },
          set: function set(origin) {
            this["super"].origin = origin;
          }
        }, {
          key: "password",
          get: function get() {
            return this["super"].password;
          },
          set: function set(password) {
            this["super"].password = password;
          }
        }, {
          key: "pathname",
          get: function get() {
            return this["super"].pathname;
          },
          set: function set(pathname) {
            this["super"].pathname = pathname;
          }
        }, {
          key: "port",
          get: function get() {
            return this["super"].port;
          },
          set: function set(port) {
            this["super"].port = port;
          }
        }, {
          key: "protocol",
          get: function get() {
            return this["super"].protocol;
          },
          set: function set(protocol) {
            this["super"].protocol = protocol;
          }
        }, {
          key: "search",
          get: function get() {
            return this["super"].search;
          },
          set: function set(search) {
            this["super"].search = search;
          }
        }, {
          key: "searchParams",
          get: function get() {
            return this["super"].searchParams;
          },
          set: function set(searchParams) {
            this["super"].searchParams = searchParams;
          }
        }, {
          key: "username",
          get: function get() {
            return this["super"].username;
          },
          set: function set(username) {
            this["super"].username = username;
          }
        }]);

        return URLWithLegacySupport;
      }();

      function format(obj) {
        if (typeof obj === "string") {
          var url = new URL2(obj);
          return url.toString();
        }

        if (!(obj instanceof URL2)) {
          var userPass = obj.username && obj.password ? obj.username + ":" + obj.password + "@" : "";
          var auth = obj.auth ? obj.auth + "@" : "";
          var port = obj.port ? ":" + obj.port : "";
          var protocol = obj.protocol ? obj.protocol + "//" : "";
          var host = obj.host || "";
          var hostname = obj.hostname || "";
          var search = obj.search || (obj.query ? "?" + obj.query : "");
          var hash = obj.hash || "";
          var pathname = obj.pathname || "";
          var path = obj.path || pathname + search;
          return "" + protocol + (userPass || auth) + (host || hostname + port) + path + hash;
        }
      }

      module.exports = {
        URLWithLegacySupport: URLWithLegacySupport,
        URLSearchParams: self.URLSearchParams,
        defaultBase: defaultBase,
        format: format
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/iso-url/src/relative.js


  var require_relative = __commonJS({
    "node_modules/@dfinity/agent/node_modules/iso-url/src/relative.js": function node_modulesDfinityAgentNode_modulesIsoUrlSrcRelativeJs(exports, module) {
      "use strict";

      var _require_url_browser = require_url_browser(),
          URLWithLegacySupport = _require_url_browser.URLWithLegacySupport,
          format = _require_url_browser.format;

      module.exports = function (url, location2, protocolMap, defaultProtocol) {
        if (location2 === void 0) {
          location2 = {};
        }

        if (protocolMap === void 0) {
          protocolMap = {};
        }

        var protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
        protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
        var urlParsed;

        try {
          urlParsed = new URLWithLegacySupport(url);
        } catch (err) {
          urlParsed = {};
        }

        var base = Object.assign({}, location2, {
          protocol: protocol || urlParsed.protocol,
          host: location2.host || urlParsed.host
        });
        return new URLWithLegacySupport(url, format(base)).toString();
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/iso-url/index.js


  var require_iso_url = __commonJS({
    "node_modules/@dfinity/agent/node_modules/iso-url/index.js": function node_modulesDfinityAgentNode_modulesIsoUrlIndexJs(exports, module) {
      "use strict";

      var _require_url_browser2 = require_url_browser(),
          URLWithLegacySupport = _require_url_browser2.URLWithLegacySupport,
          format = _require_url_browser2.format,
          URLSearchParams = _require_url_browser2.URLSearchParams,
          defaultBase = _require_url_browser2.defaultBase;

      var relative = require_relative();
      module.exports = {
        URL: URLWithLegacySupport,
        URLSearchParams: URLSearchParams,
        format: format,
        relative: relative,
        defaultBase: defaultBase
      };
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/decoder.js


  var require_decoder = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/decoder.js": function node_modulesDfinityAgentNode_modulesBorcSrcDecoderJs(exports, module) {
      "use strict";

      var _require_buffer2 = require_buffer4(),
          Buffer2 = _require_buffer2.Buffer;

      var ieee754 = require_ieee754();
      var Bignumber = require_bignumber().BigNumber;
      var parser = require_decoder_asm();
      var utils = require_utils2();
      var c = require_constants();
      var Simple = require_simple();
      var Tagged = require_tagged();

      var _require_iso_url = require_iso_url(),
          URL2 = _require_iso_url.URL;

      var Decoder = /*#__PURE__*/function () {
        /**
         * @param {Object} [opts={}]
         * @param {number} [opts.size=65536] - Size of the allocated heap.
         */
        function _Decoder(opts) {
          opts = opts || {};

          if (!opts.size || opts.size < 65536) {
            opts.size = 65536;
          } else {
            opts.size = utils.nextPowerOf2(opts.size);
          }

          this._heap = new ArrayBuffer(opts.size);
          this._heap8 = new Uint8Array(this._heap);
          this._buffer = Buffer2.from(this._heap);

          this._reset();

          this._knownTags = Object.assign({
            0: function _(val) {
              return new Date(val);
            },
            1: function _(val) {
              return new Date(val * 1e3);
            },
            2: function _(val) {
              return utils.arrayBufferToBignumber(val);
            },
            3: function _(val) {
              return c.NEG_ONE.minus(utils.arrayBufferToBignumber(val));
            },
            4: function _(v) {
              return c.TEN.pow(v[0]).times(v[1]);
            },
            5: function _(v) {
              return c.TWO.pow(v[0]).times(v[1]);
            },
            32: function _(val) {
              return new URL2(val);
            },
            35: function _(val) {
              return new RegExp(val);
            }
          }, opts.tags);
          this.parser = parser(global, {
            // eslint-disable-next-line no-console
            log: console.log.bind(console),
            pushInt: this.pushInt.bind(this),
            pushInt32: this.pushInt32.bind(this),
            pushInt32Neg: this.pushInt32Neg.bind(this),
            pushInt64: this.pushInt64.bind(this),
            pushInt64Neg: this.pushInt64Neg.bind(this),
            pushFloat: this.pushFloat.bind(this),
            pushFloatSingle: this.pushFloatSingle.bind(this),
            pushFloatDouble: this.pushFloatDouble.bind(this),
            pushTrue: this.pushTrue.bind(this),
            pushFalse: this.pushFalse.bind(this),
            pushUndefined: this.pushUndefined.bind(this),
            pushNull: this.pushNull.bind(this),
            pushInfinity: this.pushInfinity.bind(this),
            pushInfinityNeg: this.pushInfinityNeg.bind(this),
            pushNaN: this.pushNaN.bind(this),
            pushNaNNeg: this.pushNaNNeg.bind(this),
            pushArrayStart: this.pushArrayStart.bind(this),
            pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
            pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
            pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
            pushObjectStart: this.pushObjectStart.bind(this),
            pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
            pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
            pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
            pushByteString: this.pushByteString.bind(this),
            pushByteStringStart: this.pushByteStringStart.bind(this),
            pushUtf8String: this.pushUtf8String.bind(this),
            pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
            pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
            pushTagUnassigned: this.pushTagUnassigned.bind(this),
            pushTagStart: this.pushTagStart.bind(this),
            pushTagStart4: this.pushTagStart4.bind(this),
            pushTagStart8: this.pushTagStart8.bind(this),
            pushBreak: this.pushBreak.bind(this)
          }, this._heap);
        }

        var _proto46 = _Decoder.prototype;

        // Finish the current parent
        _proto46._closeParent = function _closeParent() {
          var p = this._parents.pop();

          if (p.length > 0) {
            throw new Error("Missing " + p.length + " elements");
          }

          switch (p.type) {
            case c.PARENT.TAG:
              this._push(this.createTag(p.ref[0], p.ref[1]));

              break;

            case c.PARENT.BYTE_STRING:
              this._push(this.createByteString(p.ref, p.length));

              break;

            case c.PARENT.UTF8_STRING:
              this._push(this.createUtf8String(p.ref, p.length));

              break;

            case c.PARENT.MAP:
              if (p.values % 2 > 0) {
                throw new Error("Odd number of elements in the map");
              }

              this._push(this.createMap(p.ref, p.length));

              break;

            case c.PARENT.OBJECT:
              if (p.values % 2 > 0) {
                throw new Error("Odd number of elements in the map");
              }

              this._push(this.createObject(p.ref, p.length));

              break;

            case c.PARENT.ARRAY:
              this._push(this.createArray(p.ref, p.length));

              break;

            default:
              break;
          }

          if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
            this._dec();
          }
        } // Reduce the expected length of the current parent by one
        ;

        _proto46._dec = function _dec() {
          var p = this._currentParent;

          if (p.length < 0) {
            return;
          }

          p.length--;

          if (p.length === 0) {
            this._closeParent();
          }
        } // Push any value to the current parent
        ;

        _proto46._push = function _push(val, hasChildren) {
          var p = this._currentParent;
          p.values++;

          switch (p.type) {
            case c.PARENT.ARRAY:
            case c.PARENT.BYTE_STRING:
            case c.PARENT.UTF8_STRING:
              if (p.length > -1) {
                this._ref[this._ref.length - p.length] = val;
              } else {
                this._ref.push(val);
              }

              this._dec();

              break;

            case c.PARENT.OBJECT:
              if (p.tmpKey != null) {
                this._ref[p.tmpKey] = val;
                p.tmpKey = null;

                this._dec();
              } else {
                p.tmpKey = val;

                if (typeof p.tmpKey !== "string") {
                  p.type = c.PARENT.MAP;
                  p.ref = utils.buildMap(p.ref);
                }
              }

              break;

            case c.PARENT.MAP:
              if (p.tmpKey != null) {
                this._ref.set(p.tmpKey, val);

                p.tmpKey = null;

                this._dec();
              } else {
                p.tmpKey = val;
              }

              break;

            case c.PARENT.TAG:
              this._ref.push(val);

              if (!hasChildren) {
                this._dec();
              }

              break;

            default:
              throw new Error("Unknown parent type");
          }
        } // Create a new parent in the parents list
        ;

        _proto46._createParent = function _createParent(obj, type, len) {
          this._parents[this._depth] = {
            type: type,
            length: len,
            ref: obj,
            values: 0,
            tmpKey: null
          };
        } // Reset all state back to the beginning, also used for initiatlization
        ;

        _proto46._reset = function _reset() {
          this._res = [];
          this._parents = [{
            type: c.PARENT.ARRAY,
            length: -1,
            ref: this._res,
            values: 0,
            tmpKey: null
          }];
        } // -- Interface to customize deoding behaviour
        ;

        _proto46.createTag = function createTag(tagNumber, value) {
          var typ = this._knownTags[tagNumber];

          if (!typ) {
            return new Tagged(tagNumber, value);
          }

          return typ(value);
        };

        _proto46.createMap = function createMap(obj, len) {
          return obj;
        };

        _proto46.createObject = function createObject(obj, len) {
          return obj;
        };

        _proto46.createArray = function createArray(arr, len) {
          return arr;
        };

        _proto46.createByteString = function createByteString(raw, len) {
          return Buffer2.concat(raw);
        };

        _proto46.createByteStringFromHeap = function createByteStringFromHeap(start, end) {
          if (start === end) {
            return Buffer2.alloc(0);
          }

          return Buffer2.from(this._heap.slice(start, end));
        };

        _proto46.createInt = function createInt(val) {
          return val;
        };

        _proto46.createInt32 = function createInt32(f, g) {
          return utils.buildInt32(f, g);
        };

        _proto46.createInt64 = function createInt64(f1, f2, g1, g2) {
          return utils.buildInt64(f1, f2, g1, g2);
        };

        _proto46.createFloat = function createFloat(val) {
          return val;
        };

        _proto46.createFloatSingle = function createFloatSingle(a, b, c2, d) {
          return ieee754.read([a, b, c2, d], 0, false, 23, 4);
        };

        _proto46.createFloatDouble = function createFloatDouble(a, b, c2, d, e, f, g, h) {
          return ieee754.read([a, b, c2, d, e, f, g, h], 0, false, 52, 8);
        };

        _proto46.createInt32Neg = function createInt32Neg(f, g) {
          return -1 - utils.buildInt32(f, g);
        };

        _proto46.createInt64Neg = function createInt64Neg(f1, f2, g1, g2) {
          var f = utils.buildInt32(f1, f2);
          var g = utils.buildInt32(g1, g2);

          if (f > c.MAX_SAFE_HIGH) {
            return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
          }

          return -1 - (f * c.SHIFT32 + g);
        };

        _proto46.createTrue = function createTrue() {
          return true;
        };

        _proto46.createFalse = function createFalse() {
          return false;
        };

        _proto46.createNull = function createNull() {
          return null;
        };

        _proto46.createUndefined = function createUndefined() {
          return void 0;
        };

        _proto46.createInfinity = function createInfinity() {
          return Infinity;
        };

        _proto46.createInfinityNeg = function createInfinityNeg() {
          return -Infinity;
        };

        _proto46.createNaN = function createNaN() {
          return NaN;
        };

        _proto46.createNaNNeg = function createNaNNeg() {
          return NaN;
        };

        _proto46.createUtf8String = function createUtf8String(raw, len) {
          return raw.join("");
        };

        _proto46.createUtf8StringFromHeap = function createUtf8StringFromHeap(start, end) {
          if (start === end) {
            return "";
          }

          return this._buffer.toString("utf8", start, end);
        };

        _proto46.createSimpleUnassigned = function createSimpleUnassigned(val) {
          return new Simple(val);
        } // -- Interface for decoder.asm.js
        ;

        _proto46.pushInt = function pushInt(val) {
          this._push(this.createInt(val));
        };

        _proto46.pushInt32 = function pushInt32(f, g) {
          this._push(this.createInt32(f, g));
        };

        _proto46.pushInt64 = function pushInt64(f1, f2, g1, g2) {
          this._push(this.createInt64(f1, f2, g1, g2));
        };

        _proto46.pushFloat = function pushFloat(val) {
          this._push(this.createFloat(val));
        };

        _proto46.pushFloatSingle = function pushFloatSingle(a, b, c2, d) {
          this._push(this.createFloatSingle(a, b, c2, d));
        };

        _proto46.pushFloatDouble = function pushFloatDouble(a, b, c2, d, e, f, g, h) {
          this._push(this.createFloatDouble(a, b, c2, d, e, f, g, h));
        };

        _proto46.pushInt32Neg = function pushInt32Neg(f, g) {
          this._push(this.createInt32Neg(f, g));
        };

        _proto46.pushInt64Neg = function pushInt64Neg(f1, f2, g1, g2) {
          this._push(this.createInt64Neg(f1, f2, g1, g2));
        };

        _proto46.pushTrue = function pushTrue() {
          this._push(this.createTrue());
        };

        _proto46.pushFalse = function pushFalse() {
          this._push(this.createFalse());
        };

        _proto46.pushNull = function pushNull() {
          this._push(this.createNull());
        };

        _proto46.pushUndefined = function pushUndefined() {
          this._push(this.createUndefined());
        };

        _proto46.pushInfinity = function pushInfinity() {
          this._push(this.createInfinity());
        };

        _proto46.pushInfinityNeg = function pushInfinityNeg() {
          this._push(this.createInfinityNeg());
        };

        _proto46.pushNaN = function pushNaN() {
          this._push(this.createNaN());
        };

        _proto46.pushNaNNeg = function pushNaNNeg() {
          this._push(this.createNaNNeg());
        };

        _proto46.pushArrayStart = function pushArrayStart() {
          this._createParent([], c.PARENT.ARRAY, -1);
        };

        _proto46.pushArrayStartFixed = function pushArrayStartFixed(len) {
          this._createArrayStartFixed(len);
        };

        _proto46.pushArrayStartFixed32 = function pushArrayStartFixed32(len1, len2) {
          var len = utils.buildInt32(len1, len2);

          this._createArrayStartFixed(len);
        };

        _proto46.pushArrayStartFixed64 = function pushArrayStartFixed64(len1, len2, len3, len4) {
          var len = utils.buildInt64(len1, len2, len3, len4);

          this._createArrayStartFixed(len);
        };

        _proto46.pushObjectStart = function pushObjectStart() {
          this._createObjectStartFixed(-1);
        };

        _proto46.pushObjectStartFixed = function pushObjectStartFixed(len) {
          this._createObjectStartFixed(len);
        };

        _proto46.pushObjectStartFixed32 = function pushObjectStartFixed32(len1, len2) {
          var len = utils.buildInt32(len1, len2);

          this._createObjectStartFixed(len);
        };

        _proto46.pushObjectStartFixed64 = function pushObjectStartFixed64(len1, len2, len3, len4) {
          var len = utils.buildInt64(len1, len2, len3, len4);

          this._createObjectStartFixed(len);
        };

        _proto46.pushByteStringStart = function pushByteStringStart() {
          this._parents[this._depth] = {
            type: c.PARENT.BYTE_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          };
        };

        _proto46.pushByteString = function pushByteString(start, end) {
          this._push(this.createByteStringFromHeap(start, end));
        };

        _proto46.pushUtf8StringStart = function pushUtf8StringStart() {
          this._parents[this._depth] = {
            type: c.PARENT.UTF8_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          };
        };

        _proto46.pushUtf8String = function pushUtf8String(start, end) {
          this._push(this.createUtf8StringFromHeap(start, end));
        };

        _proto46.pushSimpleUnassigned = function pushSimpleUnassigned(val) {
          this._push(this.createSimpleUnassigned(val));
        };

        _proto46.pushTagStart = function pushTagStart(tag) {
          this._parents[this._depth] = {
            type: c.PARENT.TAG,
            length: 1,
            ref: [tag]
          };
        };

        _proto46.pushTagStart4 = function pushTagStart4(f, g) {
          this.pushTagStart(utils.buildInt32(f, g));
        };

        _proto46.pushTagStart8 = function pushTagStart8(f1, f2, g1, g2) {
          this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
        };

        _proto46.pushTagUnassigned = function pushTagUnassigned(tagNumber) {
          this._push(this.createTag(tagNumber));
        };

        _proto46.pushBreak = function pushBreak() {
          if (this._currentParent.length > -1) {
            throw new Error("Unexpected break");
          }

          this._closeParent();
        };

        _proto46._createObjectStartFixed = function _createObjectStartFixed(len) {
          if (len === 0) {
            this._push(this.createObject({}));

            return;
          }

          this._createParent({}, c.PARENT.OBJECT, len);
        };

        _proto46._createArrayStartFixed = function _createArrayStartFixed(len) {
          if (len === 0) {
            this._push(this.createArray([]));

            return;
          }

          this._createParent(new Array(len), c.PARENT.ARRAY, len);
        };

        _proto46._decode = function _decode(input) {
          if (input.byteLength === 0) {
            throw new Error("Input too short");
          }

          this._reset();

          this._heap8.set(input);

          var code = this.parser.parse(input.byteLength);

          if (this._depth > 1) {
            while (this._currentParent.length === 0) {
              this._closeParent();
            }

            if (this._depth > 1) {
              throw new Error("Undeterminated nesting");
            }
          }

          if (code > 0) {
            throw new Error("Failed to parse");
          }

          if (this._res.length === 0) {
            throw new Error("No valid result");
          }
        } // -- Public Interface
        ;

        _proto46.decodeFirst = function decodeFirst(input) {
          this._decode(input);

          return this._res[0];
        };

        _proto46.decodeAll = function decodeAll(input) {
          this._decode(input);

          return this._res;
        }
        /**
         * Decode the first cbor object.
         *
         * @param {Buffer|string} input
         * @param {string} [enc='hex'] - Encoding used if a string is passed.
         * @returns {*}
         */
        ;

        _Decoder.decode = function decode(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Decoder({
            size: input.length
          });
          return dec.decodeFirst(input);
        }
        /**
         * Decode all cbor objects.
         *
         * @param {Buffer|string} input
         * @param {string} [enc='hex'] - Encoding used if a string is passed.
         * @returns {Array<*>}
         */
        ;

        _Decoder.decodeAll = function decodeAll(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Decoder({
            size: input.length
          });
          return dec.decodeAll(input);
        };

        _createClass(_Decoder, [{
          key: "_depth",
          get: function get() {
            return this._parents.length;
          }
        }, {
          key: "_currentParent",
          get: function get() {
            return this._parents[this._depth - 1];
          }
        }, {
          key: "_ref",
          get: function get() {
            return this._currentParent.ref;
          }
        }]);

        return _Decoder;
      }();

      Decoder.decodeFirst = Decoder.decode;
      module.exports = Decoder;
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/diagnose.js


  var require_diagnose = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/diagnose.js": function node_modulesDfinityAgentNode_modulesBorcSrcDiagnoseJs(exports, module) {
      "use strict";

      var _require_buffer3 = require_buffer4(),
          Buffer2 = _require_buffer3.Buffer;

      var Decoder = require_decoder();
      var utils = require_utils2();

      var Diagnose = /*#__PURE__*/function (_Decoder2) {
        _inheritsLoose(_Diagnose, _Decoder2);

        function _Diagnose() {
          return _Decoder2.apply(this, arguments) || this;
        }

        var _proto47 = _Diagnose.prototype;

        _proto47.createTag = function createTag(tagNumber, value) {
          return tagNumber + "(" + value + ")";
        };

        _proto47.createInt = function createInt(val) {
          return _Decoder2.prototype.createInt.call(this, val).toString();
        };

        _proto47.createInt32 = function createInt32(f, g) {
          return _Decoder2.prototype.createInt32.call(this, f, g).toString();
        };

        _proto47.createInt64 = function createInt64(f1, f2, g1, g2) {
          return _Decoder2.prototype.createInt64.call(this, f1, f2, g1, g2).toString();
        };

        _proto47.createInt32Neg = function createInt32Neg(f, g) {
          return _Decoder2.prototype.createInt32Neg.call(this, f, g).toString();
        };

        _proto47.createInt64Neg = function createInt64Neg(f1, f2, g1, g2) {
          return _Decoder2.prototype.createInt64Neg.call(this, f1, f2, g1, g2).toString();
        };

        _proto47.createTrue = function createTrue() {
          return "true";
        };

        _proto47.createFalse = function createFalse() {
          return "false";
        };

        _proto47.createFloat = function createFloat(val) {
          var fl = _Decoder2.prototype.createFloat.call(this, val);

          if (utils.isNegativeZero(val)) {
            return "-0_1";
          }

          return fl + "_1";
        };

        _proto47.createFloatSingle = function createFloatSingle(a, b, c, d) {
          var fl = _Decoder2.prototype.createFloatSingle.call(this, a, b, c, d);

          return fl + "_2";
        };

        _proto47.createFloatDouble = function createFloatDouble(a, b, c, d, e, f, g, h) {
          var fl = _Decoder2.prototype.createFloatDouble.call(this, a, b, c, d, e, f, g, h);

          return fl + "_3";
        };

        _proto47.createByteString = function createByteString(raw, len) {
          var val = raw.join(", ");

          if (len === -1) {
            return "(_ " + val + ")";
          }

          return "h'" + val;
        };

        _proto47.createByteStringFromHeap = function createByteStringFromHeap(start, end) {
          var val = Buffer2.from(_Decoder2.prototype.createByteStringFromHeap.call(this, start, end)).toString("hex");
          return "h'" + val + "'";
        };

        _proto47.createInfinity = function createInfinity() {
          return "Infinity_1";
        };

        _proto47.createInfinityNeg = function createInfinityNeg() {
          return "-Infinity_1";
        };

        _proto47.createNaN = function createNaN() {
          return "NaN_1";
        };

        _proto47.createNaNNeg = function createNaNNeg() {
          return "-NaN_1";
        };

        _proto47.createNull = function createNull() {
          return "null";
        };

        _proto47.createUndefined = function createUndefined() {
          return "undefined";
        };

        _proto47.createSimpleUnassigned = function createSimpleUnassigned(val) {
          return "simple(" + val + ")";
        };

        _proto47.createArray = function createArray(arr, len) {
          var val = _Decoder2.prototype.createArray.call(this, arr, len);

          if (len === -1) {
            return "[_ " + val.join(", ") + "]";
          }

          return "[" + val.join(", ") + "]";
        };

        _proto47.createMap = function createMap(map, len) {
          var val = _Decoder2.prototype.createMap.call(this, map);

          var list = Array.from(val.keys()).reduce(collectObject(val), "");

          if (len === -1) {
            return "{_ " + list + "}";
          }

          return "{" + list + "}";
        };

        _proto47.createObject = function createObject(obj, len) {
          var val = _Decoder2.prototype.createObject.call(this, obj);

          var map = Object.keys(val).reduce(collectObject(val), "");

          if (len === -1) {
            return "{_ " + map + "}";
          }

          return "{" + map + "}";
        };

        _proto47.createUtf8String = function createUtf8String(raw, len) {
          var val = raw.join(", ");

          if (len === -1) {
            return "(_ " + val + ")";
          }

          return "\"" + val + "\"";
        };

        _proto47.createUtf8StringFromHeap = function createUtf8StringFromHeap(start, end) {
          var val = Buffer2.from(_Decoder2.prototype.createUtf8StringFromHeap.call(this, start, end)).toString("utf8");
          return "\"" + val + "\"";
        };

        _Diagnose.diagnose = function diagnose(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Diagnose();
          return dec.decodeFirst(input);
        };

        return _Diagnose;
      }(Decoder);

      module.exports = Diagnose;

      function collectObject(val) {
        return function (acc, key) {
          if (acc) {
            return acc + ", " + key + ": " + val[key];
          }

          return key + ": " + val[key];
        };
      }
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/encoder.js


  var require_encoder = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/encoder.js": function node_modulesDfinityAgentNode_modulesBorcSrcEncoderJs(exports, module) {
      "use strict";

      var _require_buffer4 = require_buffer4(),
          Buffer2 = _require_buffer4.Buffer;

      var _require_iso_url2 = require_iso_url(),
          URL2 = _require_iso_url2.URL;

      var Bignumber = require_bignumber().BigNumber;
      var utils = require_utils2();
      var constants = require_constants();
      var MT = constants.MT;
      var NUMBYTES = constants.NUMBYTES;
      var SHIFT32 = constants.SHIFT32;
      var SYMS = constants.SYMS;
      var TAG = constants.TAG;
      var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
      var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
      var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
      var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
      var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
      var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
      var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
      var MAXINT_BN = new Bignumber("0x20000000000000");
      var BUF_NAN = Buffer2.from("f97e00", "hex");
      var BUF_INF_NEG = Buffer2.from("f9fc00", "hex");
      var BUF_INF_POS = Buffer2.from("f97c00", "hex");

      function toType(obj) {
        return {}.toString.call(obj).slice(8, -1);
      }

      var Encoder = /*#__PURE__*/function () {
        /**
         * @param {Object} [options={}]
         * @param {function(Buffer)} options.stream
         */
        function _Encoder(options) {
          options = options || {};
          this.streaming = typeof options.stream === "function";
          this.onData = options.stream;
          this.semanticTypes = [[URL2, this._pushUrl], [Bignumber, this._pushBigNumber]];
          var addTypes = options.genTypes || [];
          var len = addTypes.length;

          for (var i = 0; i < len; i++) {
            this.addSemanticType(addTypes[i][0], addTypes[i][1]);
          }

          this._reset();
        }

        var _proto48 = _Encoder.prototype;

        _proto48.addSemanticType = function addSemanticType(type, fun) {
          var len = this.semanticTypes.length;

          for (var i = 0; i < len; i++) {
            var typ = this.semanticTypes[i][0];

            if (typ === type) {
              var old = this.semanticTypes[i][1];
              this.semanticTypes[i][1] = fun;
              return old;
            }
          }

          this.semanticTypes.push([type, fun]);
          return null;
        };

        _proto48.push = function push(val) {
          if (!val) {
            return true;
          }

          this.result[this.offset] = val;
          this.resultMethod[this.offset] = 0;
          this.resultLength[this.offset] = val.length;
          this.offset++;

          if (this.streaming) {
            this.onData(this.finalize());
          }

          return true;
        };

        _proto48.pushWrite = function pushWrite(val, method, len) {
          this.result[this.offset] = val;
          this.resultMethod[this.offset] = method;
          this.resultLength[this.offset] = len;
          this.offset++;

          if (this.streaming) {
            this.onData(this.finalize());
          }

          return true;
        };

        _proto48._pushUInt8 = function _pushUInt8(val) {
          return this.pushWrite(val, 1, 1);
        };

        _proto48._pushUInt16BE = function _pushUInt16BE(val) {
          return this.pushWrite(val, 2, 2);
        };

        _proto48._pushUInt32BE = function _pushUInt32BE(val) {
          return this.pushWrite(val, 3, 4);
        };

        _proto48._pushDoubleBE = function _pushDoubleBE(val) {
          return this.pushWrite(val, 4, 8);
        };

        _proto48._pushNaN = function _pushNaN() {
          return this.push(BUF_NAN);
        };

        _proto48._pushInfinity = function _pushInfinity(obj) {
          var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
          return this.push(half);
        };

        _proto48._pushFloat = function _pushFloat(obj) {
          var b2 = Buffer2.allocUnsafe(2);

          if (utils.writeHalf(b2, obj)) {
            if (utils.parseHalf(b2) === obj) {
              return this._pushUInt8(HALF) && this.push(b2);
            }
          }

          var b4 = Buffer2.allocUnsafe(4);
          b4.writeFloatBE(obj, 0);

          if (b4.readFloatBE(0) === obj) {
            return this._pushUInt8(FLOAT) && this.push(b4);
          }

          return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
        };

        _proto48._pushInt = function _pushInt(obj, mt, orig) {
          var m = mt << 5;

          if (obj < 24) {
            return this._pushUInt8(m | obj);
          }

          if (obj <= 255) {
            return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
          }

          if (obj <= 65535) {
            return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
          }

          if (obj <= 4294967295) {
            return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
          }

          if (obj <= Number.MAX_SAFE_INTEGER) {
            return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
          }

          if (mt === MT.NEG_INT) {
            return this._pushFloat(orig);
          }

          return this._pushFloat(obj);
        };

        _proto48._pushIntNum = function _pushIntNum(obj) {
          if (obj < 0) {
            return this._pushInt(-obj - 1, MT.NEG_INT, obj);
          } else {
            return this._pushInt(obj, MT.POS_INT);
          }
        };

        _proto48._pushNumber = function _pushNumber(obj) {
          switch (false) {
            case obj === obj:
              return this._pushNaN(obj);

            case isFinite(obj):
              return this._pushInfinity(obj);

            case obj % 1 !== 0:
              return this._pushIntNum(obj);

            default:
              return this._pushFloat(obj);
          }
        };

        _proto48._pushString = function _pushString(obj) {
          var len = Buffer2.byteLength(obj, "utf8");
          return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
        };

        _proto48._pushBoolean = function _pushBoolean(obj) {
          return this._pushUInt8(obj ? TRUE : FALSE);
        };

        _proto48._pushUndefined = function _pushUndefined(obj) {
          return this._pushUInt8(UNDEFINED);
        };

        _proto48._pushArray = function _pushArray(gen, obj) {
          var len = obj.length;

          if (!gen._pushInt(len, MT.ARRAY)) {
            return false;
          }

          for (var j = 0; j < len; j++) {
            if (!gen.pushAny(obj[j])) {
              return false;
            }
          }

          return true;
        };

        _proto48._pushTag = function _pushTag(tag) {
          return this._pushInt(tag, MT.TAG);
        };

        _proto48._pushDate = function _pushDate(gen, obj) {
          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
        };

        _proto48._pushBuffer = function _pushBuffer(gen, obj) {
          return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
        };

        _proto48._pushNoFilter = function _pushNoFilter(gen, obj) {
          return gen._pushBuffer(gen, obj.slice());
        };

        _proto48._pushRegexp = function _pushRegexp(gen, obj) {
          return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
        };

        _proto48._pushSet = function _pushSet(gen, obj) {
          if (!gen._pushInt(obj.size, MT.ARRAY)) {
            return false;
          }

          for (var _iterator13 = _createForOfIteratorHelperLoose(obj), _step13; !(_step13 = _iterator13()).done;) {
            var x = _step13.value;

            if (!gen.pushAny(x)) {
              return false;
            }
          }

          return true;
        };

        _proto48._pushUrl = function _pushUrl(gen, obj) {
          return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
        };

        _proto48._pushBigint = function _pushBigint(obj) {
          var tag = TAG.POS_BIGINT;

          if (obj.isNegative()) {
            obj = obj.negated().minus(1);
            tag = TAG.NEG_BIGINT;
          }

          var str = obj.toString(16);

          if (str.length % 2) {
            str = "0" + str;
          }

          var buf = Buffer2.from(str, "hex");
          return this._pushTag(tag) && this._pushBuffer(this, buf);
        };

        _proto48._pushBigNumber = function _pushBigNumber(gen, obj) {
          if (obj.isNaN()) {
            return gen._pushNaN();
          }

          if (!obj.isFinite()) {
            return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
          }

          if (obj.isInteger()) {
            return gen._pushBigint(obj);
          }

          if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
            return false;
          }

          var dec = obj.decimalPlaces();
          var slide = obj.multipliedBy(new Bignumber(10).pow(dec));

          if (!gen._pushIntNum(-dec)) {
            return false;
          }

          if (slide.abs().isLessThan(MAXINT_BN)) {
            return gen._pushIntNum(slide.toNumber());
          } else {
            return gen._pushBigint(slide);
          }
        };

        _proto48._pushMap = function _pushMap(gen, obj) {
          if (!gen._pushInt(obj.size, MT.MAP)) {
            return false;
          }

          return this._pushRawMap(obj.size, Array.from(obj));
        };

        _proto48._pushObject = function _pushObject(obj) {
          if (!obj) {
            return this._pushUInt8(NULL);
          }

          var len = this.semanticTypes.length;

          for (var i = 0; i < len; i++) {
            if (obj instanceof this.semanticTypes[i][0]) {
              return this.semanticTypes[i][1].call(obj, this, obj);
            }
          }

          var f = obj.encodeCBOR;

          if (typeof f === "function") {
            return f.call(obj, this);
          }

          var keys = Object.keys(obj);
          var keyLength = keys.length;

          if (!this._pushInt(keyLength, MT.MAP)) {
            return false;
          }

          return this._pushRawMap(keyLength, keys.map(function (k) {
            return [k, obj[k]];
          }));
        };

        _proto48._pushRawMap = function _pushRawMap(len, map) {
          map = map.map(function (a) {
            a[0] = _Encoder.encode(a[0]);
            return a;
          }).sort(utils.keySorter);

          for (var j = 0; j < len; j++) {
            if (!this.push(map[j][0])) {
              return false;
            }

            if (!this.pushAny(map[j][1])) {
              return false;
            }
          }

          return true;
        }
        /**
         * Alias for `.pushAny`
         *
         * @param {*} obj
         * @returns {boolean} true on success
         */
        ;

        _proto48.write = function write(obj) {
          return this.pushAny(obj);
        }
        /**
         * Push any supported type onto the encoded stream
         *
         * @param {any} obj
         * @returns {boolean} true on success
         */
        ;

        _proto48.pushAny = function pushAny(obj) {
          var typ = toType(obj);

          switch (typ) {
            case "Number":
              return this._pushNumber(obj);

            case "String":
              return this._pushString(obj);

            case "Boolean":
              return this._pushBoolean(obj);

            case "Object":
              return this._pushObject(obj);

            case "Array":
              return this._pushArray(this, obj);

            case "Uint8Array":
              return this._pushBuffer(this, Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj));

            case "Null":
              return this._pushUInt8(NULL);

            case "Undefined":
              return this._pushUndefined(obj);

            case "Map":
              return this._pushMap(this, obj);

            case "Set":
              return this._pushSet(this, obj);

            case "URL":
              return this._pushUrl(this, obj);

            case "BigNumber":
              return this._pushBigNumber(this, obj);

            case "Date":
              return this._pushDate(this, obj);

            case "RegExp":
              return this._pushRegexp(this, obj);

            case "Symbol":
              switch (obj) {
                case SYMS.NULL:
                  return this._pushObject(null);

                case SYMS.UNDEFINED:
                  return this._pushUndefined(void 0);

                default:
                  throw new Error("Unknown symbol: " + obj.toString());
              }

            default:
              throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
          }
        };

        _proto48.finalize = function finalize() {
          if (this.offset === 0) {
            return null;
          }

          var result = this.result;
          var resultLength = this.resultLength;
          var resultMethod = this.resultMethod;
          var offset = this.offset;
          var size = 0;
          var i = 0;

          for (; i < offset; i++) {
            size += resultLength[i];
          }

          var res = Buffer2.allocUnsafe(size);
          var index = 0;
          var length = 0;

          for (i = 0; i < offset; i++) {
            length = resultLength[i];

            switch (resultMethod[i]) {
              case 0:
                result[i].copy(res, index);
                break;

              case 1:
                res.writeUInt8(result[i], index, true);
                break;

              case 2:
                res.writeUInt16BE(result[i], index, true);
                break;

              case 3:
                res.writeUInt32BE(result[i], index, true);
                break;

              case 4:
                res.writeDoubleBE(result[i], index, true);
                break;

              case 5:
                res.write(result[i], index, length, "utf8");
                break;

              default:
                throw new Error("unkown method");
            }

            index += length;
          }

          var tmp = res;

          this._reset();

          return tmp;
        };

        _proto48._reset = function _reset() {
          this.result = [];
          this.resultMethod = [];
          this.resultLength = [];
          this.offset = 0;
        }
        /**
         * Encode the given value
         * @param {*} o
         * @returns {Buffer}
         */
        ;

        _Encoder.encode = function encode(o) {
          var enc = new _Encoder();
          var ret = enc.pushAny(o);

          if (!ret) {
            throw new Error("Failed to encode input");
          }

          return enc.finalize();
        };

        return _Encoder;
      }();

      module.exports = Encoder;
    }
  }); // node_modules/@dfinity/agent/node_modules/borc/src/index.js


  var require_src = __commonJS({
    "node_modules/@dfinity/agent/node_modules/borc/src/index.js": function node_modulesDfinityAgentNode_modulesBorcSrcIndexJs(exports) {
      "use strict";

      exports.Diagnose = require_diagnose();
      exports.Decoder = require_decoder();
      exports.Encoder = require_encoder();
      exports.Simple = require_simple();
      exports.Tagged = require_tagged();
      exports.decodeAll = exports.Decoder.decodeAll;
      exports.decodeFirst = exports.Decoder.decodeFirst;
      exports.diagnose = exports.Diagnose.diagnose;
      exports.encode = exports.Encoder.encode;
      exports.decode = exports.Decoder.decode;
      exports.leveldb = {
        decode: exports.Decoder.decodeAll,
        encode: exports.Encoder.encode,
        buffer: true,
        name: "cbor"
      };
    }
  }); // node_modules/@dfinity/agent/lib/cjs/request_id.js


  var require_request_id = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/request_id.js": function node_modulesDfinityAgentLibCjsRequest_idJs(exports) {
      "use strict";

      var __importDefault = exports && exports.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hashOfMap = exports.requestIdOf = exports.hashValue = exports.hash = void 0;
      var candid_1 = require_cjs2();

      var borc_1 = __importDefault(require_src());

      var sha256_1 = require_sha256();
      var buffer_1 = require_buffer2();

      function hash(data) {
        return (0, buffer_1.uint8ToBuf)(sha256_1.sha256.create().update(new Uint8Array(data)).digest());
      }

      exports.hash = hash;

      function hashValue(value) {
        if (value instanceof borc_1["default"].Tagged) {
          return hashValue(value.value);
        } else if (typeof value === "string") {
          return hashString(value);
        } else if (typeof value === "number") {
          return hash((0, candid_1.lebEncode)(value));
        } else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
          return hash(value);
        } else if (Array.isArray(value)) {
          var vals = value.map(hashValue);
          return hash((0, buffer_1.concat).apply(void 0, vals));
        } else if (value && typeof value === "object" && value._isPrincipal) {
          return hash(value.toUint8Array());
        } else if (typeof value === "object" && value !== null && typeof value.toHash === "function") {
          return hashValue(value.toHash());
        } else if (typeof value === "object") {
          return hashOfMap(value);
        } else if (typeof value === "bigint") {
          return hash((0, candid_1.lebEncode)(value));
        }

        throw Object.assign(new Error("Attempt to hash a value of unsupported type: " + value), {
          // include so logs/callers can understand the confusing value.
          // (when stringified in error message, prototype info is lost)
          value: value
        });
      }

      exports.hashValue = hashValue;

      var hashString = function hashString(value) {
        var encoded = new TextEncoder().encode(value);
        return hash(encoded);
      };

      function requestIdOf(request) {
        return hashOfMap(request);
      }

      exports.requestIdOf = requestIdOf;

      function hashOfMap(map) {
        var hashed = Object.entries(map).filter(function (_ref28) {
          var value = _ref28[1];
          return value !== void 0;
        }).map(function (_ref29) {
          var key = _ref29[0],
              value = _ref29[1];
          var hashedKey = hashString(key);
          var hashedValue = hashValue(value);
          return [hashedKey, hashedValue];
        });
        var traversed = hashed;
        var sorted = traversed.sort(function (_ref30, _ref31) {
          var k1 = _ref30[0];
          var k2 = _ref31[0];
          return (0, buffer_1.compare)(k1, k2);
        });
        var concatenated = (0, buffer_1.concat).apply(void 0, sorted.map(function (x) {
          return (0, buffer_1.concat).apply(void 0, x);
        }));
        var result = hash(concatenated);
        return result;
      }

      exports.hashOfMap = hashOfMap;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/auth.js


  var require_auth = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/auth.js": function node_modulesDfinityAgentLibCjsAuthJs(exports) {
      "use strict";

      var __rest = exports && exports.__rest || function (s, e) {
        var t = {};

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        }

        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIdentityDescriptor = exports.AnonymousIdentity = exports.SignIdentity = void 0;
      var principal_1 = require_cjs();
      var request_id_1 = require_request_id();
      var buffer_1 = require_buffer2();
      var domainSeparator = new TextEncoder().encode("\nic-request");

      var SignIdentity = /*#__PURE__*/function () {
        function SignIdentity() {}

        var _proto49 = SignIdentity.prototype;

        /**
         * Get the principal represented by this identity. Normally should be a
         * `Principal.selfAuthenticating()`.
         */
        _proto49.getPrincipal = function getPrincipal() {
          if (!this._principal) {
            this._principal = principal_1.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
          }

          return this._principal;
        }
        /**
         * Transform a request into a signed version of the request. This is done last
         * after the transforms on the body of a request. The returned object can be
         * anything, but must be serializable to CBOR.
         * @param request - internet computer request to transform
         */
        ;

        _proto49.transformRequest =
        /*#__PURE__*/
        function () {
          var _transformRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
            var body, fields, requestId;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    body = request.body, fields = __rest(request, ["body"]);
                    requestId = (0, request_id_1.requestIdOf)(body);
                    _context3.t0 = Object;
                    _context3.t1 = Object.assign({}, fields);
                    _context3.t2 = body;
                    _context3.t3 = this.getPublicKey().toDer();
                    _context3.next = 8;
                    return this.sign((0, buffer_1.concat)(domainSeparator, requestId));

                  case 8:
                    _context3.t4 = _context3.sent;
                    _context3.t5 = {
                      content: _context3.t2,
                      sender_pubkey: _context3.t3,
                      sender_sig: _context3.t4
                    };
                    _context3.t6 = {
                      body: _context3.t5
                    };
                    return _context3.abrupt("return", _context3.t0.assign.call(_context3.t0, _context3.t1, _context3.t6));

                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function transformRequest(_x5) {
            return _transformRequest.apply(this, arguments);
          }

          return transformRequest;
        }();

        return SignIdentity;
      }();

      exports.SignIdentity = SignIdentity;

      var AnonymousIdentity = /*#__PURE__*/function () {
        function AnonymousIdentity() {}

        var _proto50 = AnonymousIdentity.prototype;

        _proto50.getPrincipal = function getPrincipal() {
          return principal_1.Principal.anonymous();
        };

        _proto50.transformRequest = /*#__PURE__*/function () {
          var _transformRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", Object.assign(Object.assign({}, request), {
                      body: {
                        content: request.body
                      }
                    }));

                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function transformRequest(_x6) {
            return _transformRequest2.apply(this, arguments);
          }

          return transformRequest;
        }();

        return AnonymousIdentity;
      }();

      exports.AnonymousIdentity = AnonymousIdentity;

      function createIdentityDescriptor(identity) {
        var identityIndicator = "getPublicKey" in identity ? {
          type: "PublicKeyIdentity",
          publicKey: (0, buffer_1.toHex)(identity.getPublicKey().toDer())
        } : {
          type: "AnonymousIdentity"
        };
        return identityIndicator;
      }

      exports.createIdentityDescriptor = createIdentityDescriptor;
    }
  }); // node_modules/simple-cbor/src/value.js


  var require_value = __commonJS({
    "node_modules/simple-cbor/src/value.js": function node_modulesSimpleCborSrcValueJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var MAX_U64_NUMBER = 9007199254740992;

      function _concat(a) {
        for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {
          args[_key7 - 1] = arguments[_key7];
        }

        var newBuffer = new Uint8Array(a.byteLength + args.reduce(function (acc, b) {
          return acc + b.byteLength;
        }, 0));
        newBuffer.set(new Uint8Array(a), 0);
        var i = a.byteLength;

        for (var _i9 = 0, _args5 = args; _i9 < _args5.length; _i9++) {
          var b = _args5[_i9];
          newBuffer.set(new Uint8Array(b), i);
          i += b.byteLength;
        }

        return newBuffer.buffer;
      }

      function _serializeValue(major, minor, value) {
        value = value.replace(/[^0-9a-fA-F]/g, "");
        var length = Math.pow(2, minor - 24);
        value = value.slice(-length * 2).padStart(length * 2, "0");
        var bytes2 = [(major << 5) + minor].concat(value.match(/../g).map(function (_byte12) {
          return parseInt(_byte12, 16);
        }));
        return new Uint8Array(bytes2).buffer;
      }

      function _serializeNumber(major, value) {
        if (value < 24) {
          return new Uint8Array([(major << 5) + value]).buffer;
        } else {
          var minor = value <= 255 ? 24 : value <= 65535 ? 25 : value <= 4294967295 ? 26 : 27;
          return _serializeValue(major, minor, value.toString(16));
        }
      }

      function _serializeString(str) {
        var utf8 = [];

        for (var i = 0; i < str.length; i++) {
          var charcode = str.charCodeAt(i);

          if (charcode < 128) {
            utf8.push(charcode);
          } else if (charcode < 2048) {
            utf8.push(192 | charcode >> 6, 128 | charcode & 63);
          } else if (charcode < 55296 || charcode >= 57344) {
            utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
          } else {
            i++;
            charcode = (charcode & 1023) << 10 | str.charCodeAt(i) & 1023;
            utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
          }
        }

        return _concat(new Uint8Array(_serializeNumber(3, str.length)), new Uint8Array(utf8));
      }

      function tagged(tag, value) {
        if (tag == 14277111) {
          return _concat(new Uint8Array([217, 217, 247]), value);
        }

        if (tag < 24) {
          return _concat(new Uint8Array([(6 << 5) + tag]), value);
        } else {
          var minor = tag <= 255 ? 24 : tag <= 65535 ? 25 : tag <= 4294967295 ? 26 : 27;
          var length = Math.pow(2, minor - 24);
          var value2 = tag.toString(16).slice(-length * 2).padStart(length * 2, "0");
          var bytes2 = [(6 << 5) + minor].concat(value2.match(/../g).map(function (_byte13) {
            return parseInt(_byte13, 16);
          }));
          return new Uint8Array(bytes2).buffer;
        }
      }

      exports.tagged = tagged;

      function raw(bytes2) {
        return new Uint8Array(bytes2).buffer;
      }

      exports.raw = raw;

      function uSmall(n) {
        if (isNaN(n)) {
          throw new RangeError("Invalid number.");
        }

        n = Math.min(Math.max(0, n), 23);
        var bytes2 = [(0 << 5) + n];
        return new Uint8Array(bytes2).buffer;
      }

      exports.uSmall = uSmall;

      function u8(u82, radix) {
        u82 = parseInt("" + u82, radix);

        if (isNaN(u82)) {
          throw new RangeError("Invalid number.");
        }

        u82 = Math.min(Math.max(0, u82), 255);
        u82 = u82.toString(16);
        return _serializeValue(0, 24, u82);
      }

      exports.u8 = u8;

      function u16(u162, radix) {
        u162 = parseInt("" + u162, radix);

        if (isNaN(u162)) {
          throw new RangeError("Invalid number.");
        }

        u162 = Math.min(Math.max(0, u162), 65535);
        u162 = u162.toString(16);
        return _serializeValue(0, 25, u162);
      }

      exports.u16 = u16;

      function u32(u322, radix) {
        u322 = parseInt("" + u322, radix);

        if (isNaN(u322)) {
          throw new RangeError("Invalid number.");
        }

        u322 = Math.min(Math.max(0, u322), 4294967295);
        u322 = u322.toString(16);
        return _serializeValue(0, 26, u322);
      }

      exports.u32 = u32;

      function u64(u642, radix) {
        if (typeof u642 == "string" && radix == 16) {
          if (u642.match(/[^0-9a-fA-F]/)) {
            throw new RangeError("Invalid number.");
          }

          return _serializeValue(0, 27, u642);
        }

        u642 = parseInt("" + u642, radix);

        if (isNaN(u642)) {
          throw new RangeError("Invalid number.");
        }

        u642 = Math.min(Math.max(0, u642), MAX_U64_NUMBER);
        u642 = u642.toString(16);
        return _serializeValue(0, 27, u642);
      }

      exports.u64 = u64;

      function iSmall(n) {
        if (isNaN(n)) {
          throw new RangeError("Invalid number.");
        }

        if (n === 0) {
          return uSmall(0);
        }

        n = Math.min(Math.max(0, -n), 24) - 1;
        var bytes2 = [(1 << 5) + n];
        return new Uint8Array(bytes2).buffer;
      }

      exports.iSmall = iSmall;

      function i8(i82, radix) {
        i82 = parseInt("" + i82, radix);

        if (isNaN(i82)) {
          throw new RangeError("Invalid number.");
        }

        i82 = Math.min(Math.max(0, -i82 - 1), 255);
        i82 = i82.toString(16);
        return _serializeValue(1, 24, i82);
      }

      exports.i8 = i8;

      function i16(i162, radix) {
        i162 = parseInt("" + i162, radix);

        if (isNaN(i162)) {
          throw new RangeError("Invalid number.");
        }

        i162 = Math.min(Math.max(0, -i162 - 1), 65535);
        i162 = i162.toString(16);
        return _serializeValue(1, 25, i162);
      }

      exports.i16 = i16;

      function i32(i322, radix) {
        i322 = parseInt("" + i322, radix);

        if (isNaN(i322)) {
          throw new RangeError("Invalid number.");
        }

        i322 = Math.min(Math.max(0, -i322 - 1), 4294967295);
        i322 = i322.toString(16);
        return _serializeValue(1, 26, i322);
      }

      exports.i32 = i32;

      function i64(i642, radix) {
        if (typeof i642 == "string" && radix == 16) {
          if (i642.startsWith("-")) {
            i642 = i642.slice(1);
          } else {
            i642 = "0";
          }

          if (i642.match(/[^0-9a-fA-F]/) || i642.length > 16) {
            throw new RangeError("Invalid number.");
          }

          var done = false;
          var newI64 = i642.split("").reduceRight(function (acc, x) {
            if (done) {
              return x + acc;
            }

            var n = parseInt(x, 16) - 1;

            if (n >= 0) {
              done = true;
              return n.toString(16) + acc;
            } else {
              return "f" + acc;
            }
          }, "");

          if (!done) {
            return u64(0);
          }

          return _serializeValue(1, 27, newI64);
        }

        i642 = parseInt("" + i642, radix);

        if (isNaN(i642)) {
          throw new RangeError("Invalid number.");
        }

        i642 = Math.min(Math.max(0, -i642 - 1), 9007199254740992);
        i642 = i642.toString(16);
        return _serializeValue(1, 27, i642);
      }

      exports.i64 = i64;

      function number(n) {
        if (n >= 0) {
          if (n < 24) {
            return uSmall(n);
          } else if (n <= 255) {
            return u8(n);
          } else if (n <= 65535) {
            return u16(n);
          } else if (n <= 4294967295) {
            return u32(n);
          } else {
            return u64(n);
          }
        } else {
          if (n >= -24) {
            return iSmall(n);
          } else if (n >= -255) {
            return i8(n);
          } else if (n >= -65535) {
            return i16(n);
          } else if (n >= -4294967295) {
            return i32(n);
          } else {
            return i64(n);
          }
        }
      }

      exports.number = number;

      function bytes(bytes2) {
        return _concat(_serializeNumber(2, bytes2.byteLength), bytes2);
      }

      exports.bytes = bytes;

      function string(str) {
        return _serializeString(str);
      }

      exports.string = string;

      function array(items) {
        return _concat.apply(void 0, [_serializeNumber(4, items.length)].concat(items));
      }

      exports.array = array;

      function map(items, stable) {
        if (stable === void 0) {
          stable = false;
        }

        if (!(items instanceof Map)) {
          items = new Map(Object.entries(items));
        }

        var entries = Array.from(items.entries());

        if (stable) {
          entries = entries.sort(function (_ref32, _ref33) {
            var keyA = _ref32[0];
            var keyB = _ref33[0];
            return keyA.localeCompare(keyB);
          });
        }

        return _concat.apply(void 0, [_serializeNumber(5, items.size)].concat(entries.map(function (_ref34) {
          var k = _ref34[0],
              v = _ref34[1];
          return _concat(_serializeString(k), v);
        })));
      }

      exports.map = map;

      function singleFloat(f) {
        var single = new Float32Array([f]);
        return _concat(new Uint8Array([(7 << 5) + 26]), new Uint8Array(single.buffer));
      }

      exports.singleFloat = singleFloat;

      function doubleFloat(f) {
        var single = new Float64Array([f]);
        return _concat(new Uint8Array([(7 << 5) + 27]), new Uint8Array(single.buffer));
      }

      exports.doubleFloat = doubleFloat;

      function bool(v) {
        return v ? true_() : false_();
      }

      exports.bool = bool;

      function true_() {
        return raw(new Uint8Array([(7 << 5) + 21]));
      }

      exports.true_ = true_;

      function false_() {
        return raw(new Uint8Array([(7 << 5) + 20]));
      }

      exports.false_ = false_;

      function null_() {
        return raw(new Uint8Array([(7 << 5) + 22]));
      }

      exports.null_ = null_;

      function undefined_() {
        return raw(new Uint8Array([(7 << 5) + 23]));
      }

      exports.undefined_ = undefined_;
    }
  }); // node_modules/simple-cbor/src/serializer.js


  var require_serializer = __commonJS({
    "node_modules/simple-cbor/src/serializer.js": function node_modulesSimpleCborSrcSerializerJs(exports) {
      "use strict";

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          }
        }

        result["default"] = mod;
        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var cbor = __importStar(require_value());

      var BufferClasses = [ArrayBuffer, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array];

      var JsonDefaultCborEncoder = /*#__PURE__*/function () {
        // @param _serializer The CBOR Serializer to use.
        // @param _stable Whether or not keys from objects should be sorted (stable). This is
        //     particularly useful when testing encodings between JSON objects.
        function JsonDefaultCborEncoder(_serializer, _stable) {
          if (_stable === void 0) {
            _stable = false;
          }

          this._serializer = _serializer;
          this._stable = _stable;
          this.name = "jsonDefault";
          this.priority = -100;
        }

        var _proto51 = JsonDefaultCborEncoder.prototype;

        _proto51.match = function match(value) {
          return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value) != -1;
        };

        _proto51.encode = function encode(value) {
          var _this41 = this;

          switch (typeof value) {
            case "undefined":
              return cbor.undefined_();

            case "boolean":
              return cbor.bool(value);

            case "number":
              if (Math.floor(value) === value) {
                return cbor.number(value);
              } else {
                return cbor.doubleFloat(value);
              }

            case "string":
              return cbor.string(value);

            case "object":
              if (value === null) {
                return cbor.null_();
              } else if (Array.isArray(value)) {
                return cbor.array(value.map(function (x) {
                  return _this41._serializer.serializeValue(x);
                }));
              } else if (BufferClasses.find(function (x) {
                return value instanceof x;
              })) {
                return cbor.bytes(value.buffer || value);
              } else if (Object.getOwnPropertyNames(value).indexOf("toJSON") !== -1) {
                return this.encode(value.toJSON());
              } else if (value instanceof Map) {
                var m = /* @__PURE__ */new Map();

                for (var _iterator14 = _createForOfIteratorHelperLoose(value.entries()), _step14; !(_step14 = _iterator14()).done;) {
                  var _step14$value = _step14.value,
                      key = _step14$value[0],
                      item = _step14$value[1];
                  m.set(key, this._serializer.serializeValue(item));
                }

                return cbor.map(m, this._stable);
              } else {
                var _m = /* @__PURE__ */new Map();

                for (var _i10 = 0, _Object$entries = Object.entries(value); _i10 < _Object$entries.length; _i10++) {
                  var _Object$entries$_i = _Object$entries[_i10],
                      _key8 = _Object$entries$_i[0],
                      _item = _Object$entries$_i[1];

                  _m.set(_key8, this._serializer.serializeValue(_item));
                }

                return cbor.map(_m, this._stable);
              }

            default:
              throw new Error("Invalid value.");
          }
        };

        return JsonDefaultCborEncoder;
      }();

      exports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;

      var ToCborEncoder = /*#__PURE__*/function () {
        function ToCborEncoder() {
          this.name = "cborEncoder";
          this.priority = -90;
        }

        var _proto52 = ToCborEncoder.prototype;

        _proto52.match = function match(value) {
          return typeof value == "object" && typeof value["toCBOR"] == "function";
        };

        _proto52.encode = function encode(value) {
          return value.toCBOR();
        };

        return ToCborEncoder;
      }();

      exports.ToCborEncoder = ToCborEncoder;

      var CborSerializer = /*#__PURE__*/function () {
        function CborSerializer() {
          this._encoders = /* @__PURE__ */new Set();
        }

        CborSerializer.withDefaultEncoders = function withDefaultEncoders(stable) {
          if (stable === void 0) {
            stable = false;
          }

          var s = new this();
          s.addEncoder(new JsonDefaultCborEncoder(s, stable));
          s.addEncoder(new ToCborEncoder());
          return s;
        };

        var _proto53 = CborSerializer.prototype;

        _proto53.removeEncoder = function removeEncoder(name) {
          for (var _iterator15 = _createForOfIteratorHelperLoose(this._encoders.values()), _step15; !(_step15 = _iterator15()).done;) {
            var encoder = _step15.value;

            if (encoder.name == name) {
              this._encoders["delete"](encoder);
            }
          }
        };

        _proto53.addEncoder = function addEncoder(encoder) {
          this._encoders.add(encoder);
        };

        _proto53.getEncoderFor = function getEncoderFor(value) {
          var chosenEncoder = null;

          for (var _iterator16 = _createForOfIteratorHelperLoose(this._encoders), _step16; !(_step16 = _iterator16()).done;) {
            var encoder = _step16.value;

            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {
              if (encoder.match(value)) {
                chosenEncoder = encoder;
              }
            }
          }

          if (chosenEncoder === null) {
            throw new Error("Could not find an encoder for value.");
          }

          return chosenEncoder;
        };

        _proto53.serializeValue = function serializeValue(value) {
          return this.getEncoderFor(value).encode(value);
        };

        _proto53.serialize = function serialize(value) {
          return this.serializeValue(value);
        };

        return CborSerializer;
      }();

      exports.CborSerializer = CborSerializer;

      var SelfDescribeCborSerializer = /*#__PURE__*/function (_CborSerializer) {
        _inheritsLoose(SelfDescribeCborSerializer, _CborSerializer);

        function SelfDescribeCborSerializer() {
          return _CborSerializer.apply(this, arguments) || this;
        }

        var _proto54 = SelfDescribeCborSerializer.prototype;

        _proto54.serialize = function serialize(value) {
          return cbor.raw(new Uint8Array([].concat(new Uint8Array([217, 217, 247]), new Uint8Array(_CborSerializer.prototype.serializeValue.call(this, value)))));
        };

        return SelfDescribeCborSerializer;
      }(CborSerializer);

      exports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
    }
  }); // node_modules/simple-cbor/src/index.js


  var require_src2 = __commonJS({
    "node_modules/simple-cbor/src/index.js": function node_modulesSimpleCborSrcIndexJs(exports) {
      "use strict";

      function __export2(m) {
        for (var p in m) {
          if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
      }

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          }
        }

        result["default"] = mod;
        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      __export2(require_serializer());

      var value = __importStar(require_value());

      exports.value = value;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/cbor.js


  var require_cbor = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/cbor.js": function node_modulesDfinityAgentLibCjsCborJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      var __importDefault = exports && exports.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decode = exports.encode = exports.CborTag = void 0;

      var borc_1 = __importDefault(require_src());

      var cbor = __importStar(require_src2());

      var simple_cbor_1 = require_src2();
      var buffer_1 = require_buffer2();

      var PrincipalEncoder = /*#__PURE__*/function () {
        function PrincipalEncoder() {}

        var _proto55 = PrincipalEncoder.prototype;

        _proto55.match = function match(value) {
          return value && value._isPrincipal === true;
        };

        _proto55.encode = function encode(v) {
          return cbor.value.bytes(v.toUint8Array());
        };

        _createClass(PrincipalEncoder, [{
          key: "name",
          get: function get() {
            return "Principal";
          }
        }, {
          key: "priority",
          get: function get() {
            return 0;
          }
        }]);

        return PrincipalEncoder;
      }();

      var BufferEncoder = /*#__PURE__*/function () {
        function BufferEncoder() {}

        var _proto56 = BufferEncoder.prototype;

        _proto56.match = function match(value) {
          return value instanceof ArrayBuffer || ArrayBuffer.isView(value);
        };

        _proto56.encode = function encode(v) {
          return cbor.value.bytes(new Uint8Array(v));
        };

        _createClass(BufferEncoder, [{
          key: "name",
          get: function get() {
            return "Buffer";
          }
        }, {
          key: "priority",
          get: function get() {
            return 1;
          }
        }]);

        return BufferEncoder;
      }();

      var BigIntEncoder = /*#__PURE__*/function () {
        function BigIntEncoder() {}

        var _proto57 = BigIntEncoder.prototype;

        _proto57.match = function match(value) {
          return typeof value === "bigint";
        };

        _proto57.encode = function encode(v) {
          if (v > BigInt(0)) {
            return cbor.value.tagged(2, cbor.value.bytes((0, buffer_1.fromHex)(v.toString(16))));
          } else {
            return cbor.value.tagged(3, cbor.value.bytes((0, buffer_1.fromHex)((BigInt("-1") * v).toString(16))));
          }
        };

        _createClass(BigIntEncoder, [{
          key: "name",
          get: function get() {
            return "BigInt";
          }
        }, {
          key: "priority",
          get: function get() {
            return 1;
          }
        }]);

        return BigIntEncoder;
      }();

      var serializer = simple_cbor_1.SelfDescribeCborSerializer.withDefaultEncoders(true);
      serializer.addEncoder(new PrincipalEncoder());
      serializer.addEncoder(new BufferEncoder());
      serializer.addEncoder(new BigIntEncoder());
      var CborTag;

      (function (CborTag2) {
        CborTag2[CborTag2["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
        CborTag2[CborTag2["Semantic"] = 55799] = "Semantic";
      })(CborTag = exports.CborTag || (exports.CborTag = {}));

      function encode(value) {
        return serializer.serialize(value);
      }

      exports.encode = encode;

      function decodePositiveBigInt(buf) {
        var len = buf.byteLength;
        var res = BigInt(0);

        for (var i = 0; i < len; i++) {
          res = res * BigInt(256) + BigInt(buf[i]);
        }

        return res;
      }

      var Uint8ArrayDecoder = /*#__PURE__*/function (_borc_1$default$Decod) {
        _inheritsLoose(Uint8ArrayDecoder, _borc_1$default$Decod);

        function Uint8ArrayDecoder() {
          return _borc_1$default$Decod.apply(this, arguments) || this;
        }

        var _proto58 = Uint8ArrayDecoder.prototype;

        _proto58.createByteString = function createByteString(raw) {
          return (0, buffer_1.concat).apply(void 0, raw);
        };

        _proto58.createByteStringFromHeap = function createByteStringFromHeap(start, end) {
          if (start === end) {
            return new ArrayBuffer(0);
          }

          return new Uint8Array(this._heap.slice(start, end));
        };

        return Uint8ArrayDecoder;
      }(borc_1["default"].Decoder);

      function decode(input) {
        var _tags;

        var buffer = new Uint8Array(input);
        var decoder = new Uint8ArrayDecoder({
          size: buffer.byteLength,
          tags: (_tags = {
            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).
            2: function _(val) {
              return decodePositiveBigInt(val);
            },
            3: function _(val) {
              return -decodePositiveBigInt(val);
            }
          }, _tags[CborTag.Semantic] = function (value) {
            return value;
          }, _tags)
        });

        try {
          return decoder.decodeFirst(buffer);
        } catch (e) {
          throw new Error("Failed to decode CBOR: " + e + ", input: " + (0, buffer_1.toHex)(buffer));
        }
      }

      exports.decode = decode;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/utils/random.js


  var require_random = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/utils/random.js": function node_modulesDfinityAgentLibCjsUtilsRandomJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomNumber = void 0;

      var randomNumber = function randomNumber() {
        if (typeof window !== "undefined" && !!window.crypto && !!window.crypto.getRandomValues) {
          var array = new Uint32Array(1);
          window.crypto.getRandomValues(array);
          return array[0];
        }

        if (typeof crypto !== "undefined" && crypto.getRandomValues) {
          var _array = new Uint32Array(1);

          crypto.getRandomValues(_array);
          return _array[0];
        }

        if (typeof crypto !== "undefined" && crypto.randomInt) {
          return crypto.randomInt(0, 4294967295);
        }

        return Math.floor(Math.random() * 4294967295);
      };

      exports.randomNumber = randomNumber;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/http/types.js


  var require_types2 = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/http/types.js": function node_modulesDfinityAgentLibCjsAgentHttpTypesJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.makeNonce = exports.SubmitRequestType = void 0;
      var random_1 = require_random();
      var SubmitRequestType;

      (function (SubmitRequestType2) {
        SubmitRequestType2["Call"] = "call";
      })(SubmitRequestType = exports.SubmitRequestType || (exports.SubmitRequestType = {}));

      function makeNonce() {
        var buffer = new ArrayBuffer(16);
        var view = new DataView(buffer);
        var rand1 = (0, random_1.randomNumber)();
        var rand2 = (0, random_1.randomNumber)();
        var rand3 = (0, random_1.randomNumber)();
        var rand4 = (0, random_1.randomNumber)();
        view.setUint32(0, rand1);
        view.setUint32(4, rand2);
        view.setUint32(8, rand3);
        view.setUint32(12, rand4);
        return buffer;
      }

      exports.makeNonce = makeNonce;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/http/transforms.js


  var require_transforms = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/http/transforms.js": function node_modulesDfinityAgentLibCjsAgentHttpTransformsJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.httpHeadersTransform = exports.makeExpiryTransform = exports.makeNonceTransform = exports.Expiry = void 0;
      var candid_1 = require_cjs2();

      var cbor = __importStar(require_src2());

      var types_1 = require_types2();
      var NANOSECONDS_PER_MILLISECONDS = BigInt(1e6);
      var REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1e3;

      var Expiry = /*#__PURE__*/function () {
        function Expiry(deltaInMSec) {
          if (deltaInMSec < 90 * 1e3) {
            var raw_value2 = BigInt(Date.now() + deltaInMSec) * NANOSECONDS_PER_MILLISECONDS;
            var ingress_as_seconds2 = raw_value2 / BigInt(1e9);
            this._value = ingress_as_seconds2 * BigInt(1e9);
            return;
          }

          var raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) * NANOSECONDS_PER_MILLISECONDS;
          var ingress_as_seconds = raw_value / BigInt(1e9);
          var ingress_as_minutes = ingress_as_seconds / BigInt(60);
          var rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1e9);
          this._value = rounded_down_nanos;
        }

        var _proto59 = Expiry.prototype;

        _proto59.toCBOR = function toCBOR() {
          return cbor.value.u64(this._value.toString(16), 16);
        };

        _proto59.toHash = function toHash() {
          return (0, candid_1.lebEncode)(this._value);
        };

        return Expiry;
      }();

      exports.Expiry = Expiry;

      function makeNonceTransform(nonceFn) {
        if (nonceFn === void 0) {
          nonceFn = types_1.makeNonce;
        }

        return /*#__PURE__*/function () {
          var _ref35 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
            var headers;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    headers = request.request.headers;
                    request.request.headers = headers;

                    if (request.endpoint === "call") {
                      request.body.nonce = nonceFn();
                    }

                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          return function (_x7) {
            return _ref35.apply(this, arguments);
          };
        }();
      }

      exports.makeNonceTransform = makeNonceTransform;

      function makeExpiryTransform(delayInMilliseconds) {
        return /*#__PURE__*/function () {
          var _ref36 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    request.body.ingress_expiry = new Expiry(delayInMilliseconds);

                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          return function (_x8) {
            return _ref36.apply(this, arguments);
          };
        }();
      }

      exports.makeExpiryTransform = makeExpiryTransform;

      function httpHeadersTransform(headers) {
        var headerFields = [];
        headers.forEach(function (value, key) {
          headerFields.push([key, value]);
        });
        return headerFields;
      }

      exports.httpHeadersTransform = httpHeadersTransform;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/http/errors.js


  var require_errors2 = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/http/errors.js": function node_modulesDfinityAgentLibCjsAgentHttpErrorsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AgentReadStateError = exports.AgentQueryError = exports.AgentCallError = exports.AgentHTTPResponseError = void 0;
      var errors_1 = require_errors();

      var AgentHTTPResponseError = /*#__PURE__*/function (_errors_1$AgentError) {
        _inheritsLoose(AgentHTTPResponseError, _errors_1$AgentError);

        function AgentHTTPResponseError(message, response) {
          var _this42;

          _this42 = _errors_1$AgentError.call(this, message) || this;
          _this42.response = response;
          _this42.name = _this42.constructor.name;
          Object.setPrototypeOf(_assertThisInitialized(_this42), (this instanceof AgentHTTPResponseError ? this.constructor : void 0).prototype);
          return _this42;
        }

        return AgentHTTPResponseError;
      }(errors_1.AgentError);

      exports.AgentHTTPResponseError = AgentHTTPResponseError;

      var AgentCallError = /*#__PURE__*/function (_errors_1$AgentError2) {
        _inheritsLoose(AgentCallError, _errors_1$AgentError2);

        function AgentCallError(message, response, requestId, senderPubkey, senderSig, ingressExpiry) {
          var _this43;

          _this43 = _errors_1$AgentError2.call(this, message) || this;
          _this43.response = response;
          _this43.requestId = requestId;
          _this43.senderPubkey = senderPubkey;
          _this43.senderSig = senderSig;
          _this43.ingressExpiry = ingressExpiry;
          _this43.name = "AgentCallError";
          Object.setPrototypeOf(_assertThisInitialized(_this43), (this instanceof AgentCallError ? this.constructor : void 0).prototype);
          return _this43;
        }

        return AgentCallError;
      }(errors_1.AgentError);

      exports.AgentCallError = AgentCallError;

      var AgentQueryError = /*#__PURE__*/function (_errors_1$AgentError3) {
        _inheritsLoose(AgentQueryError, _errors_1$AgentError3);

        function AgentQueryError(message, response, requestId, senderPubkey, senderSig, ingressExpiry) {
          var _this44;

          _this44 = _errors_1$AgentError3.call(this, message) || this;
          _this44.response = response;
          _this44.requestId = requestId;
          _this44.senderPubkey = senderPubkey;
          _this44.senderSig = senderSig;
          _this44.ingressExpiry = ingressExpiry;
          _this44.name = "AgentQueryError";
          Object.setPrototypeOf(_assertThisInitialized(_this44), (this instanceof AgentQueryError ? this.constructor : void 0).prototype);
          return _this44;
        }

        return AgentQueryError;
      }(errors_1.AgentError);

      exports.AgentQueryError = AgentQueryError;

      var AgentReadStateError = /*#__PURE__*/function (_errors_1$AgentError4) {
        _inheritsLoose(AgentReadStateError, _errors_1$AgentError4);

        function AgentReadStateError(message, response, requestId, senderPubkey, senderSig, ingressExpiry) {
          var _this45;

          _this45 = _errors_1$AgentError4.call(this, message) || this;
          _this45.response = response;
          _this45.requestId = requestId;
          _this45.senderPubkey = senderPubkey;
          _this45.senderSig = senderSig;
          _this45.ingressExpiry = ingressExpiry;
          _this45.name = "AgentReadStateError";
          Object.setPrototypeOf(_assertThisInitialized(_this45), (this instanceof AgentReadStateError ? this.constructor : void 0).prototype);
          return _this45;
        }

        return AgentReadStateError;
      }(errors_1.AgentError);

      exports.AgentReadStateError = AgentReadStateError;
    }
  }); // node_modules/@noble/curves/utils.js


  var require_utils3 = __commonJS({
    "node_modules/@noble/curves/utils.js": function node_modulesNobleCurvesUtilsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
      exports.abool = abool;
      exports._abool2 = _abool2;
      exports._abytes2 = _abytes2;
      exports.numberToHexUnpadded = numberToHexUnpadded;
      exports.hexToNumber = hexToNumber;
      exports.bytesToNumberBE = bytesToNumberBE;
      exports.bytesToNumberLE = bytesToNumberLE;
      exports.numberToBytesBE = numberToBytesBE;
      exports.numberToBytesLE = numberToBytesLE;
      exports.numberToVarBytesBE = numberToVarBytesBE;
      exports.ensureBytes = ensureBytes;
      exports.equalBytes = equalBytes;
      exports.copyBytes = copyBytes;
      exports.asciiToBytes = asciiToBytes;
      exports.inRange = inRange;
      exports.aInRange = aInRange;
      exports.bitLen = bitLen;
      exports.bitGet = bitGet;
      exports.bitSet = bitSet;
      exports.createHmacDrbg = createHmacDrbg;
      exports.validateObject = validateObject;
      exports.isHash = isHash;
      exports._validateObject = _validateObject;
      exports.memoized = memoized;
      var utils_js_1 = require_utils();
      var utils_js_2 = require_utils();
      Object.defineProperty(exports, "abytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.abytes;
        }
      });
      Object.defineProperty(exports, "anumber", {
        enumerable: true,
        get: function get() {
          return utils_js_2.anumber;
        }
      });
      Object.defineProperty(exports, "bytesToHex", {
        enumerable: true,
        get: function get() {
          return utils_js_2.bytesToHex;
        }
      });
      Object.defineProperty(exports, "bytesToUtf8", {
        enumerable: true,
        get: function get() {
          return utils_js_2.bytesToUtf8;
        }
      });
      Object.defineProperty(exports, "concatBytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.concatBytes;
        }
      });
      Object.defineProperty(exports, "hexToBytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.hexToBytes;
        }
      });
      Object.defineProperty(exports, "isBytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.isBytes;
        }
      });
      Object.defineProperty(exports, "randomBytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.randomBytes;
        }
      });
      Object.defineProperty(exports, "utf8ToBytes", {
        enumerable: true,
        get: function get() {
          return utils_js_2.utf8ToBytes;
        }
      });

      var _0n = /* @__PURE__ */BigInt(0);

      var _1n = /* @__PURE__ */BigInt(1);

      function abool(title, value) {
        if (typeof value !== "boolean") throw new Error(title + " boolean expected, got " + value);
      }

      function _abool2(value, title) {
        if (title === void 0) {
          title = "";
        }

        if (typeof value !== "boolean") {
          var prefix = title && "\"" + title + "\"";
          throw new Error(prefix + "expected boolean, got type=" + typeof value);
        }

        return value;
      }

      function _abytes2(value, length, title) {
        if (title === void 0) {
          title = "";
        }

        var bytes = (0, utils_js_1.isBytes)(value);
        var len = value == null ? void 0 : value.length;
        var needsLen = length !== void 0;

        if (!bytes || needsLen && len !== length) {
          var prefix = title && "\"" + title + "\" ";
          var ofLen = needsLen ? " of length " + length : "";
          var got = bytes ? "length=" + len : "type=" + typeof value;
          throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
        }

        return value;
      }

      function numberToHexUnpadded(num) {
        var hex = num.toString(16);
        return hex.length & 1 ? "0" + hex : hex;
      }

      function hexToNumber(hex) {
        if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
        return hex === "" ? _0n : BigInt("0x" + hex);
      }

      function bytesToNumberBE(bytes) {
        return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
      }

      function bytesToNumberLE(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
      }

      function numberToBytesBE(n, len) {
        return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
      }

      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }

      function numberToVarBytesBE(n) {
        return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
      }

      function ensureBytes(title, hex, expectedLength) {
        var res;

        if (typeof hex === "string") {
          try {
            res = (0, utils_js_1.hexToBytes)(hex);
          } catch (e) {
            throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
          }
        } else if ((0, utils_js_1.isBytes)(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(title + " must be hex string or Uint8Array");
        }

        var len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(title + " of length " + expectedLength + " expected, got " + len);
        return res;
      }

      function equalBytes(a, b) {
        if (a.length !== b.length) return false;
        var diff = 0;

        for (var i = 0; i < a.length; i++) {
          diff |= a[i] ^ b[i];
        }

        return diff === 0;
      }

      function copyBytes(bytes) {
        return Uint8Array.from(bytes);
      }

      function asciiToBytes(ascii) {
        return Uint8Array.from(ascii, function (c, i) {
          var charCode = c.charCodeAt(0);

          if (c.length !== 1 || charCode > 127) {
            throw new Error("string contains non-ASCII character \"" + ascii[i] + "\" with code " + charCode + " at position " + i);
          }

          return charCode;
        });
      }

      var isPosBig = function isPosBig(n) {
        return typeof n === "bigint" && _0n <= n;
      };

      function inRange(n, min, max) {
        return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
      }

      function aInRange(title, n, min, max) {
        if (!inRange(n, min, max)) throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
      }

      function bitLen(n) {
        var len;

        for (len = 0; n > _0n; n >>= _1n, len += 1) {
          ;
        }

        return len;
      }

      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }

      function bitSet(n, pos, value) {
        return n | (value ? _1n : _0n) << BigInt(pos);
      }

      var bitMask = function bitMask(n) {
        return (_1n << BigInt(n)) - _1n;
      };

      exports.bitMask = bitMask;

      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");

        var u8n = function u8n(len) {
          return new Uint8Array(len);
        };

        var u8of = function u8of(_byte14) {
          return Uint8Array.of(_byte14);
        };

        var v = u8n(hashLen);
        var k = u8n(hashLen);
        var i = 0;

        var reset = function reset() {
          v.fill(1);
          k.fill(0);
          i = 0;
        };

        var h = function h() {
          for (var _len7 = arguments.length, b = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {
            b[_key9] = arguments[_key9];
          }

          return hmacFn.apply(void 0, [k, v].concat(b));
        };

        var reseed = function reseed(seed) {
          if (seed === void 0) {
            seed = u8n(0);
          }

          k = h(u8of(0), seed);
          v = h();
          if (seed.length === 0) return;
          k = h(u8of(1), seed);
          v = h();
        };

        var gen = function gen() {
          if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
          var len = 0;
          var out = [];

          while (len < qByteLen) {
            v = h();
            var sl = v.slice();
            out.push(sl);
            len += v.length;
          }

          return (0, utils_js_1.concatBytes).apply(void 0, out);
        };

        var genUntil = function genUntil(seed, pred) {
          reset();
          reseed(seed);
          var res = void 0;

          while (!(res = pred(gen()))) {
            reseed();
          }

          reset();
          return res;
        };

        return genUntil;
      }

      var validatorFns = {
        bigint: function bigint(val) {
          return typeof val === "bigint";
        },
        "function": function _function(val) {
          return typeof val === "function";
        },
        "boolean": function boolean(val) {
          return typeof val === "boolean";
        },
        string: function string(val) {
          return typeof val === "string";
        },
        stringOrUint8Array: function stringOrUint8Array(val) {
          return typeof val === "string" || (0, utils_js_1.isBytes)(val);
        },
        isSafeInteger: function isSafeInteger(val) {
          return Number.isSafeInteger(val);
        },
        array: function array(val) {
          return Array.isArray(val);
        },
        field: function field(val, object) {
          return object.Fp.isValid(val);
        },
        hash: function hash(val) {
          return typeof val === "function" && Number.isSafeInteger(val.outputLen);
        }
      };

      function validateObject(object, validators, optValidators) {
        if (optValidators === void 0) {
          optValidators = {};
        }

        var checkField = function checkField(fieldName, type, isOptional) {
          var checkVal = validatorFns[type];
          if (typeof checkVal !== "function") throw new Error("invalid validator function");
          var val = object[fieldName];
          if (isOptional && val === void 0) return;

          if (!checkVal(val, object)) {
            throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
          }
        };

        for (var _i11 = 0, _Object$entries2 = Object.entries(validators); _i11 < _Object$entries2.length; _i11++) {
          var _Object$entries2$_i = _Object$entries2[_i11],
              fieldName = _Object$entries2$_i[0],
              type = _Object$entries2$_i[1];
          checkField(fieldName, type, false);
        }

        for (var _i12 = 0, _Object$entries3 = Object.entries(optValidators); _i12 < _Object$entries3.length; _i12++) {
          var _Object$entries3$_i = _Object$entries3[_i12],
              _fieldName = _Object$entries3$_i[0],
              _type2 = _Object$entries3$_i[1];
          checkField(_fieldName, _type2, true);
        }

        return object;
      }

      function isHash(val) {
        return typeof val === "function" && Number.isSafeInteger(val.outputLen);
      }

      function _validateObject(object, fields, optFields) {
        if (optFields === void 0) {
          optFields = {};
        }

        if (!object || typeof object !== "object") throw new Error("expected valid options object");

        function checkField(fieldName, expectedType, isOpt) {
          var val = object[fieldName];
          if (isOpt && val === void 0) return;
          var current = typeof val;
          if (current !== expectedType || val === null) throw new Error("param \"" + fieldName + "\" is invalid: expected " + expectedType + ", got " + current);
        }

        Object.entries(fields).forEach(function (_ref37) {
          var k = _ref37[0],
              v = _ref37[1];
          return checkField(k, v, false);
        });
        Object.entries(optFields).forEach(function (_ref38) {
          var k = _ref38[0],
              v = _ref38[1];
          return checkField(k, v, true);
        });
      }

      var notImplemented = function notImplemented() {
        throw new Error("not implemented");
      };

      exports.notImplemented = notImplemented;

      function memoized(fn) {
        var map = /* @__PURE__ */new WeakMap();
        return function (arg) {
          var val = map.get(arg);
          if (val !== void 0) return val;

          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key10 = 1; _key10 < _len8; _key10++) {
            args[_key10 - 1] = arguments[_key10];
          }

          var computed = fn.apply(void 0, [arg].concat(args));
          map.set(arg, computed);
          return computed;
        };
      }
    }
  }); // node_modules/@noble/curves/abstract/modular.js


  var require_modular = __commonJS({
    "node_modules/@noble/curves/abstract/modular.js": function node_modulesNobleCurvesAbstractModularJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNegativeLE = void 0;
      exports.mod = mod;
      exports.pow = pow;
      exports.pow2 = pow2;
      exports.invert = invert;
      exports.tonelliShanks = tonelliShanks;
      exports.FpSqrt = FpSqrt;
      exports.validateField = validateField;
      exports.FpPow = FpPow;
      exports.FpInvertBatch = FpInvertBatch;
      exports.FpDiv = FpDiv;
      exports.FpLegendre = FpLegendre;
      exports.FpIsSquare = FpIsSquare;
      exports.nLength = nLength;
      exports.Field = Field;
      exports.FpSqrtOdd = FpSqrtOdd;
      exports.FpSqrtEven = FpSqrtEven;
      exports.hashToPrivateScalar = hashToPrivateScalar;
      exports.getFieldBytesLength = getFieldBytesLength;
      exports.getMinHashLength = getMinHashLength;
      exports.mapHashToField = mapHashToField;
      var utils_ts_1 = require_utils3();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = /* @__PURE__ */BigInt(2);

      var _3n = /* @__PURE__ */BigInt(3);

      var _4n = /* @__PURE__ */BigInt(4);

      var _5n = /* @__PURE__ */BigInt(5);

      var _7n = /* @__PURE__ */BigInt(7);

      var _8n = /* @__PURE__ */BigInt(8);

      var _9n = /* @__PURE__ */BigInt(9);

      var _16n = /* @__PURE__ */BigInt(16);

      function mod(a, b) {
        var result = a % b;
        return result >= _0n ? result : b + result;
      }

      function pow(num, power, modulo) {
        return FpPow(Field(modulo), num, power);
      }

      function pow2(x, power, modulo) {
        var res = x;

        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }

        return res;
      }

      function invert(number, modulo) {
        if (number === _0n) throw new Error("invert: expected non-zero number");
        if (modulo <= _0n) throw new Error("invert: expected positive modulus, got " + modulo);
        var a = mod(number, modulo);
        var b = modulo;
        var x = _0n,
            y = _1n,
            u = _1n,
            v = _0n;

        while (a !== _0n) {
          var q = b / a;
          var r = b % a;
          var m = x - u * q;
          var n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }

        var gcd = b;
        if (gcd !== _1n) throw new Error("invert: does not exist");
        return mod(x, modulo);
      }

      function assertIsSquare(Fp, root, n) {
        if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
      }

      function sqrt3mod4(Fp, n) {
        var p1div4 = (Fp.ORDER + _1n) / _4n;
        var root = Fp.pow(n, p1div4);
        assertIsSquare(Fp, root, n);
        return root;
      }

      function sqrt5mod8(Fp, n) {
        var p5div8 = (Fp.ORDER - _5n) / _8n;
        var n2 = Fp.mul(n, _2n);
        var v = Fp.pow(n2, p5div8);
        var nv = Fp.mul(n, v);
        var i = Fp.mul(Fp.mul(nv, _2n), v);
        var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        assertIsSquare(Fp, root, n);
        return root;
      }

      function sqrt9mod16(P) {
        var Fp_ = Field(P);
        var tn = tonelliShanks(P);
        var c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
        var c2 = tn(Fp_, c1);
        var c3 = tn(Fp_, Fp_.neg(c1));
        var c4 = (P + _7n) / _16n;
        return function (Fp, n) {
          var tv1 = Fp.pow(n, c4);
          var tv2 = Fp.mul(tv1, c1);
          var tv3 = Fp.mul(tv1, c2);
          var tv4 = Fp.mul(tv1, c3);
          var e1 = Fp.eql(Fp.sqr(tv2), n);
          var e2 = Fp.eql(Fp.sqr(tv3), n);
          tv1 = Fp.cmov(tv1, tv2, e1);
          tv2 = Fp.cmov(tv4, tv3, e2);
          var e3 = Fp.eql(Fp.sqr(tv2), n);
          var root = Fp.cmov(tv1, tv2, e3);
          assertIsSquare(Fp, root, n);
          return root;
        };
      }

      function tonelliShanks(P) {
        if (P < _3n) throw new Error("sqrt is not defined for small field");
        var Q = P - _1n;
        var S = 0;

        while (Q % _2n === _0n) {
          Q /= _2n;
          S++;
        }

        var Z = _2n;

        var _Fp = Field(P);

        while (FpLegendre(_Fp, Z) === 1) {
          if (Z++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
        }

        if (S === 1) return sqrt3mod4;

        var cc = _Fp.pow(Z, Q);

        var Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.is0(n)) return n;
          if (FpLegendre(Fp, n) !== 1) throw new Error("Cannot find square root");
          var M = S;
          var c = Fp.mul(Fp.ONE, cc);
          var t = Fp.pow(n, Q);
          var R = Fp.pow(n, Q1div2);

          while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t)) return Fp.ZERO;
            var i = 1;
            var t_tmp = Fp.sqr(t);

            while (!Fp.eql(t_tmp, Fp.ONE)) {
              i++;
              t_tmp = Fp.sqr(t_tmp);
              if (i === M) throw new Error("Cannot find square root");
            }

            var exponent = _1n << BigInt(M - i - 1);

            var b = Fp.pow(c, exponent);
            M = i;
            c = Fp.sqr(b);
            t = Fp.mul(t, c);
            R = Fp.mul(R, b);
          }

          return R;
        };
      }

      function FpSqrt(P) {
        if (P % _4n === _3n) return sqrt3mod4;
        if (P % _8n === _5n) return sqrt5mod8;
        if (P % _16n === _9n) return sqrt9mod16(P);
        return tonelliShanks(P);
      }

      var isNegativeLE = function isNegativeLE(num, modulo) {
        return (mod(num, modulo) & _1n) === _1n;
      };

      exports.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

      function validateField(field) {
        var initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "number",
          BITS: "number"
        };
        var opts = FIELD_FIELDS.reduce(function (map, val) {
          map[val] = "function";
          return map;
        }, initial);
        (0, utils_ts_1._validateObject)(field, opts);
        return field;
      }

      function FpPow(Fp, num, power) {
        if (power < _0n) throw new Error("invalid exponent, negatives unsupported");
        if (power === _0n) return Fp.ONE;
        if (power === _1n) return num;
        var p = Fp.ONE;
        var d = num;

        while (power > _0n) {
          if (power & _1n) p = Fp.mul(p, d);
          d = Fp.sqr(d);
          power >>= _1n;
        }

        return p;
      }

      function FpInvertBatch(Fp, nums, passZero) {
        if (passZero === void 0) {
          passZero = false;
        }

        var inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
        var multipliedAcc = nums.reduce(function (acc, num, i) {
          if (Fp.is0(num)) return acc;
          inverted[i] = acc;
          return Fp.mul(acc, num);
        }, Fp.ONE);
        var invertedAcc = Fp.inv(multipliedAcc);
        nums.reduceRight(function (acc, num, i) {
          if (Fp.is0(num)) return acc;
          inverted[i] = Fp.mul(acc, inverted[i]);
          return Fp.mul(acc, num);
        }, invertedAcc);
        return inverted;
      }

      function FpDiv(Fp, lhs, rhs) {
        return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
      }

      function FpLegendre(Fp, n) {
        var p1mod2 = (Fp.ORDER - _1n) / _2n;
        var powered = Fp.pow(n, p1mod2);
        var yes = Fp.eql(powered, Fp.ONE);
        var zero = Fp.eql(powered, Fp.ZERO);
        var no = Fp.eql(powered, Fp.neg(Fp.ONE));
        if (!yes && !zero && !no) throw new Error("invalid Legendre symbol result");
        return yes ? 1 : zero ? 0 : -1;
      }

      function FpIsSquare(Fp, n) {
        var l = FpLegendre(Fp, n);
        return l === 1;
      }

      function nLength(n, nBitLength) {
        if (nBitLength !== void 0) (0, utils_ts_1.anumber)(nBitLength);

        var _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;

        var nByteLength = Math.ceil(_nBitLength / 8);
        return {
          nBitLength: _nBitLength,
          nByteLength: nByteLength
        };
      }

      function Field(ORDER, bitLenOrOpts, isLE, opts) {
        if (isLE === void 0) {
          isLE = false;
        }

        if (opts === void 0) {
          opts = {};
        }

        if (ORDER <= _0n) throw new Error("invalid field: expected ORDER > 0, got " + ORDER);

        var _nbitLength = void 0;

        var _sqrt = void 0;

        var modFromBytes = false;
        var allowedLengths = void 0;

        if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
          if (opts.sqrt || isLE) throw new Error("cannot specify opts in two arguments");
          var _opts = bitLenOrOpts;
          if (_opts.BITS) _nbitLength = _opts.BITS;
          if (_opts.sqrt) _sqrt = _opts.sqrt;
          if (typeof _opts.isLE === "boolean") isLE = _opts.isLE;
          if (typeof _opts.modFromBytes === "boolean") modFromBytes = _opts.modFromBytes;
          allowedLengths = _opts.allowedLengths;
        } else {
          if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
          if (opts.sqrt) _sqrt = opts.sqrt;
        }

        var _nLength = nLength(ORDER, _nbitLength),
            BITS = _nLength.nBitLength,
            BYTES = _nLength.nByteLength;

        if (BYTES > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
        var sqrtP;
        var f = Object.freeze({
          ORDER: ORDER,
          isLE: isLE,
          BITS: BITS,
          BYTES: BYTES,
          MASK: (0, utils_ts_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          allowedLengths: allowedLengths,
          create: function create(num) {
            return mod(num, ORDER);
          },
          isValid: function isValid(num) {
            if (typeof num !== "bigint") throw new Error("invalid field element: expected bigint, got " + typeof num);
            return _0n <= num && num < ORDER;
          },
          is0: function is0(num) {
            return num === _0n;
          },
          // is valid and invertible
          isValidNot0: function isValidNot0(num) {
            return !f.is0(num) && f.isValid(num);
          },
          isOdd: function isOdd(num) {
            return (num & _1n) === _1n;
          },
          neg: function neg(num) {
            return mod(-num, ORDER);
          },
          eql: function eql(lhs, rhs) {
            return lhs === rhs;
          },
          sqr: function sqr(num) {
            return mod(num * num, ORDER);
          },
          add: function add(lhs, rhs) {
            return mod(lhs + rhs, ORDER);
          },
          sub: function sub(lhs, rhs) {
            return mod(lhs - rhs, ORDER);
          },
          mul: function mul(lhs, rhs) {
            return mod(lhs * rhs, ORDER);
          },
          pow: function pow(num, power) {
            return FpPow(f, num, power);
          },
          div: function div(lhs, rhs) {
            return mod(lhs * invert(rhs, ORDER), ORDER);
          },
          // Same as above, but doesn't normalize
          sqrN: function sqrN(num) {
            return num * num;
          },
          addN: function addN(lhs, rhs) {
            return lhs + rhs;
          },
          subN: function subN(lhs, rhs) {
            return lhs - rhs;
          },
          mulN: function mulN(lhs, rhs) {
            return lhs * rhs;
          },
          inv: function inv(num) {
            return invert(num, ORDER);
          },
          sqrt: _sqrt || function (n) {
            if (!sqrtP) sqrtP = FpSqrt(ORDER);
            return sqrtP(f, n);
          },
          toBytes: function toBytes(num) {
            return isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES);
          },
          fromBytes: function fromBytes(bytes, skipValidation) {
            if (skipValidation === void 0) {
              skipValidation = true;
            }

            if (allowedLengths) {
              if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
              }

              var padded = new Uint8Array(BYTES);
              padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
              bytes = padded;
            }

            if (bytes.length !== BYTES) throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
            var scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes) scalar = mod(scalar, ORDER);

            if (!skipValidation) {
              if (!f.isValid(scalar)) throw new Error("invalid field element: outside of range 0..ORDER");
            }

            return scalar;
          },
          // TODO: we don't need it here, move out to separate fn
          invertBatch: function invertBatch(lst) {
            return FpInvertBatch(f, lst);
          },
          // We can't move this out because Fp6, Fp12 implement it
          // and it's unclear what to return in there.
          cmov: function cmov(a, b, c) {
            return c ? b : a;
          }
        });
        return Object.freeze(f);
      }

      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
        var root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
      }

      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
        var root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
      }

      function hashToPrivateScalar(hash, groupOrder, isLE) {
        if (isLE === void 0) {
          isLE = false;
        }

        hash = (0, utils_ts_1.ensureBytes)("privateHash", hash);
        var hashLen = hash.length;
        var minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
        var num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
        return mod(num, groupOrder - _1n) + _1n;
      }

      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
        var bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }

      function getMinHashLength(fieldOrder) {
        var length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }

      function mapHashToField(key, fieldOrder, isLE) {
        if (isLE === void 0) {
          isLE = false;
        }

        var len = key.length;
        var fieldLen = getFieldBytesLength(fieldOrder);
        var minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024) throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
        var num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);

        var reduced = mod(num, fieldOrder - _1n) + _1n;

        return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
      }
    }
  }); // node_modules/@noble/curves/abstract/curve.js


  var require_curve = __commonJS({
    "node_modules/@noble/curves/abstract/curve.js": function node_modulesNobleCurvesAbstractCurveJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wNAF = void 0;
      exports.negateCt = negateCt;
      exports.normalizeZ = normalizeZ;
      exports.mulEndoUnsafe = mulEndoUnsafe;
      exports.pippenger = pippenger;
      exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
      exports.validateBasic = validateBasic;
      exports._createCurveFields = _createCurveFields;
      var utils_ts_1 = require_utils3();
      var modular_ts_1 = require_modular();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      function negateCt(condition, item) {
        var neg = item.negate();
        return condition ? neg : item;
      }

      function normalizeZ(c, points) {
        var invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(function (p) {
          return p.Z;
        }));
        return points.map(function (p, i) {
          return c.fromAffine(p.toAffine(invertedZs[i]));
        });
      }

      function validateW(W, bits) {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
      }

      function calcWOpts(W, scalarBits) {
        validateW(W, scalarBits);
        var windows = Math.ceil(scalarBits / W) + 1;
        var windowSize = Math.pow(2, W - 1);
        var maxNumber = Math.pow(2, W);
        var mask = (0, utils_ts_1.bitMask)(W);
        var shiftBy = BigInt(W);
        return {
          windows: windows,
          windowSize: windowSize,
          mask: mask,
          maxNumber: maxNumber,
          shiftBy: shiftBy
        };
      }

      function calcOffsets(n, window2, wOpts) {
        var windowSize = wOpts.windowSize,
            mask = wOpts.mask,
            maxNumber = wOpts.maxNumber,
            shiftBy = wOpts.shiftBy;
        var wbits = Number(n & mask);
        var nextN = n >> shiftBy;

        if (wbits > windowSize) {
          wbits -= maxNumber;
          nextN += _1n;
        }

        var offsetStart = window2 * windowSize;
        var offset = offsetStart + Math.abs(wbits) - 1;
        var isZero = wbits === 0;
        var isNeg = wbits < 0;
        var isNegF = window2 % 2 !== 0;
        var offsetF = offsetStart;
        return {
          nextN: nextN,
          offset: offset,
          isZero: isZero,
          isNeg: isNeg,
          isNegF: isNegF,
          offsetF: offsetF
        };
      }

      function validateMSMPoints(points, c) {
        if (!Array.isArray(points)) throw new Error("array expected");
        points.forEach(function (p, i) {
          if (!(p instanceof c)) throw new Error("invalid point at index " + i);
        });
      }

      function validateMSMScalars(scalars, field) {
        if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
        scalars.forEach(function (s, i) {
          if (!field.isValid(s)) throw new Error("invalid scalar at index " + i);
        });
      }

      var pointPrecomputes = /* @__PURE__ */new WeakMap();
      var pointWindowSizes = /* @__PURE__ */new WeakMap();

      function getW(P) {
        return pointWindowSizes.get(P) || 1;
      }

      function assert0(n) {
        if (n !== _0n) throw new Error("invalid wNAF");
      }

      var wNAF = /*#__PURE__*/function () {
        // Parametrized with a given Point class (not individual point)
        function wNAF(Point, bits) {
          this.BASE = Point.BASE;
          this.ZERO = Point.ZERO;
          this.Fn = Point.Fn;
          this.bits = bits;
        } // non-const time multiplication ladder


        var _proto60 = wNAF.prototype;

        _proto60._unsafeLadder = function _unsafeLadder(elm, n, p) {
          if (p === void 0) {
            p = this.ZERO;
          }

          var d = elm;

          while (n > _0n) {
            if (n & _1n) p = p.add(d);
            d = d["double"]();
            n >>= _1n;
          }

          return p;
        }
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param point Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        ;

        _proto60.precomputeWindow = function precomputeWindow(point, W) {
          var _calcWOpts = calcWOpts(W, this.bits),
              windows = _calcWOpts.windows,
              windowSize = _calcWOpts.windowSize;

          var points = [];
          var p = point;
          var base = p;

          for (var window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);

            for (var i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }

            p = base["double"]();
          }

          return points;
        }
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * More compact implementation:
         * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
         * @returns real and fake (for const-time) points
         */
        ;

        _proto60.wNAF = function wNAF(W, precomputes, n) {
          if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
          var p = this.ZERO;
          var f = this.BASE;
          var wo = calcWOpts(W, this.bits);

          for (var window2 = 0; window2 < wo.windows; window2++) {
            var _calcOffsets = calcOffsets(n, window2, wo),
                nextN = _calcOffsets.nextN,
                offset = _calcOffsets.offset,
                isZero = _calcOffsets.isZero,
                isNeg = _calcOffsets.isNeg,
                isNegF = _calcOffsets.isNegF,
                offsetF = _calcOffsets.offsetF;

            n = nextN;

            if (isZero) {
              f = f.add(negateCt(isNegF, precomputes[offsetF]));
            } else {
              p = p.add(negateCt(isNeg, precomputes[offset]));
            }
          }

          assert0(n);
          return {
            p: p,
            f: f
          };
        }
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        ;

        _proto60.wNAFUnsafe = function wNAFUnsafe(W, precomputes, n, acc) {
          if (acc === void 0) {
            acc = this.ZERO;
          }

          var wo = calcWOpts(W, this.bits);

          for (var window2 = 0; window2 < wo.windows; window2++) {
            if (n === _0n) break;

            var _calcOffsets2 = calcOffsets(n, window2, wo),
                nextN = _calcOffsets2.nextN,
                offset = _calcOffsets2.offset,
                isZero = _calcOffsets2.isZero,
                isNeg = _calcOffsets2.isNeg;

            n = nextN;

            if (isZero) {
              continue;
            } else {
              var item = precomputes[offset];
              acc = acc.add(isNeg ? item.negate() : item);
            }
          }

          assert0(n);
          return acc;
        };

        _proto60.getPrecomputes = function getPrecomputes(W, point, transform) {
          var comp = pointPrecomputes.get(point);

          if (!comp) {
            comp = this.precomputeWindow(point, W);

            if (W !== 1) {
              if (typeof transform === "function") comp = transform(comp);
              pointPrecomputes.set(point, comp);
            }
          }

          return comp;
        };

        _proto60.cached = function cached(point, scalar, transform) {
          var W = getW(point);
          return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
        };

        _proto60.unsafe = function unsafe(point, scalar, transform, prev) {
          var W = getW(point);
          if (W === 1) return this._unsafeLadder(point, scalar, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
        } // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        ;

        _proto60.createCache = function createCache(P, W) {
          validateW(W, this.bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes["delete"](P);
        };

        _proto60.hasCache = function hasCache(elm) {
          return getW(elm) !== 1;
        };

        return wNAF;
      }();

      exports.wNAF = wNAF;

      function mulEndoUnsafe(Point, point, k1, k2) {
        var acc = point;
        var p1 = Point.ZERO;
        var p2 = Point.ZERO;

        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n) p1 = p1.add(acc);
          if (k2 & _1n) p2 = p2.add(acc);
          acc = acc["double"]();
          k1 >>= _1n;
          k2 >>= _1n;
        }

        return {
          p1: p1,
          p2: p2
        };
      }

      function pippenger(c, fieldN, points, scalars) {
        validateMSMPoints(points, c);
        validateMSMScalars(scalars, fieldN);
        var plength = points.length;
        var slength = scalars.length;
        if (plength !== slength) throw new Error("arrays of points and scalars must have equal length");
        var zero = c.ZERO;
        var wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
        var windowSize = 1;
        if (wbits > 12) windowSize = wbits - 3;else if (wbits > 4) windowSize = wbits - 2;else if (wbits > 0) windowSize = 2;
        var MASK = (0, utils_ts_1.bitMask)(windowSize);
        var buckets = new Array(Number(MASK) + 1).fill(zero);
        var lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
        var sum = zero;

        for (var i = lastBits; i >= 0; i -= windowSize) {
          buckets.fill(zero);

          for (var j = 0; j < slength; j++) {
            var scalar = scalars[j];
            var wbits2 = Number(scalar >> BigInt(i) & MASK);
            buckets[wbits2] = buckets[wbits2].add(points[j]);
          }

          var resI = zero;

          for (var _j = buckets.length - 1, sumI = zero; _j > 0; _j--) {
            sumI = sumI.add(buckets[_j]);
            resI = resI.add(sumI);
          }

          sum = sum.add(resI);
          if (i !== 0) for (var _j2 = 0; _j2 < windowSize; _j2++) {
            sum = sum["double"]();
          }
        }

        return sum;
      }

      function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
        validateW(windowSize, fieldN.BITS);
        validateMSMPoints(points, c);
        var zero = c.ZERO;
        var tableSize = Math.pow(2, windowSize) - 1;
        var chunks = Math.ceil(fieldN.BITS / windowSize);
        var MASK = (0, utils_ts_1.bitMask)(windowSize);
        var tables = points.map(function (p) {
          var res = [];

          for (var i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
          }

          return res;
        });
        return function (scalars) {
          validateMSMScalars(scalars, fieldN);
          if (scalars.length > points.length) throw new Error("array of scalars must be smaller than array of points");
          var res = zero;

          for (var i = 0; i < chunks; i++) {
            if (res !== zero) for (var j = 0; j < windowSize; j++) {
              res = res["double"]();
            }
            var shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);

            for (var _j3 = 0; _j3 < scalars.length; _j3++) {
              var n = scalars[_j3];
              var curr = Number(n >> shiftBy & MASK);
              if (!curr) continue;
              res = res.add(tables[_j3][curr - 1]);
            }
          }

          return res;
        };
      }

      function validateBasic(curve) {
        (0, modular_ts_1.validateField)(curve.Fp);
        (0, utils_ts_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze(_extends({}, (0, modular_ts_1.nLength)(curve.n, curve.nBitLength), curve, {
          p: curve.Fp.ORDER
        }));
      }

      function createField(order, field, isLE) {
        if (field) {
          if (field.ORDER !== order) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
          (0, modular_ts_1.validateField)(field);
          return field;
        } else {
          return (0, modular_ts_1.Field)(order, {
            isLE: isLE
          });
        }
      }

      function _createCurveFields(type, CURVE, curveOpts, FpFnLE) {
        if (curveOpts === void 0) {
          curveOpts = {};
        }

        if (FpFnLE === void 0) FpFnLE = type === "edwards";
        if (!CURVE || typeof CURVE !== "object") throw new Error("expected valid " + type + " CURVE object");

        for (var _i13 = 0, _arr2 = ["p", "n", "h"]; _i13 < _arr2.length; _i13++) {
          var p = _arr2[_i13];
          var val = CURVE[p];
          if (!(typeof val === "bigint" && val > _0n)) throw new Error("CURVE." + p + " must be positive bigint");
        }

        var Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
        var Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);

        var _b = type === "weierstrass" ? "b" : "d";

        var params = ["Gx", "Gy", "a", _b];

        for (var _i14 = 0, _params = params; _i14 < _params.length; _i14++) {
          var _p = _params[_i14];
          if (!Fp.isValid(CURVE[_p])) throw new Error("CURVE." + _p + " must be valid field element of CURVE.Fp");
        }

        CURVE = Object.freeze(Object.assign({}, CURVE));
        return {
          CURVE: CURVE,
          Fp: Fp,
          Fn: Fn
        };
      }
    }
  }); // node_modules/@noble/curves/abstract/hash-to-curve.js


  var require_hash_to_curve = __commonJS({
    "node_modules/@noble/curves/abstract/hash-to-curve.js": function node_modulesNobleCurvesAbstractHashToCurveJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._DST_scalar = void 0;
      exports.expand_message_xmd = expand_message_xmd;
      exports.expand_message_xof = expand_message_xof;
      exports.hash_to_field = hash_to_field;
      exports.isogenyMap = isogenyMap;
      exports.createHasher = createHasher;
      var utils_ts_1 = require_utils3();
      var modular_ts_1 = require_modular();
      var os2ip = utils_ts_1.bytesToNumberBE;

      function i2osp(value, length) {
        anum(value);
        anum(length);
        if (value < 0 || value >= 1 << 8 * length) throw new Error("invalid I2OSP input: " + value);
        var res = Array.from({
          length: length
        }).fill(0);

        for (var i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }

        return new Uint8Array(res);
      }

      function strxor(a, b) {
        var arr = new Uint8Array(a.length);

        for (var i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }

        return arr;
      }

      function anum(item) {
        if (!Number.isSafeInteger(item)) throw new Error("number expected");
      }

      function normDST(DST) {
        if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string") throw new Error("DST must be Uint8Array or string");
        return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
      }

      function expand_message_xmd(msg, DST, lenInBytes, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);
        if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        var b_in_bytes = H.outputLen,
            r_in_bytes = H.blockLen;
        var ell = Math.ceil(lenInBytes / b_in_bytes);
        if (lenInBytes > 65535 || ell > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
        var DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
        var Z_pad = i2osp(0, r_in_bytes);
        var l_i_b_str = i2osp(lenInBytes, 2);
        var b = new Array(ell);
        var b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));

        for (var i = 1; i <= ell; i++) {
          var args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_ts_1.concatBytes).apply(void 0, args));
        }

        var pseudo_random_bytes = (0, utils_ts_1.concatBytes).apply(void 0, b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }

      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);

        if (DST.length > 255) {
          var dkLen = Math.ceil(2 * k / 8);
          DST = H.create({
            dkLen: dkLen
          }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }

        if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({
          dkLen: lenInBytes
        }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }

      function hash_to_field(msg, count, options) {
        (0, utils_ts_1._validateObject)(options, {
          p: "bigint",
          m: "number",
          k: "number",
          hash: "function"
        });
        var p = options.p,
            k = options.k,
            m = options.m,
            hash = options.hash,
            expand = options.expand,
            DST = options.DST;
        if (!(0, utils_ts_1.isHash)(options.hash)) throw new Error("expected valid hash");
        (0, utils_ts_1.abytes)(msg);
        anum(count);
        var log2p = p.toString(2).length;
        var L = Math.ceil((log2p + k) / 8);
        var len_in_bytes = count * m * L;
        var prb;

        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }

        var u = new Array(count);

        for (var i = 0; i < count; i++) {
          var e = new Array(m);

          for (var j = 0; j < m; j++) {
            var elm_offset = L * (j + i * m);
            var tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
          }

          u[i] = e;
        }

        return u;
      }

      function isogenyMap(field, map) {
        var coeff = map.map(function (i) {
          return Array.from(i).reverse();
        });
        return function (x, y) {
          var _coeff$map = coeff.map(function (val) {
            return val.reduce(function (acc, i) {
              return field.add(field.mul(acc, x), i);
            });
          }),
              xn = _coeff$map[0],
              xd = _coeff$map[1],
              yn = _coeff$map[2],
              yd = _coeff$map[3];

          var _ref39 = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true),
              xd_inv = _ref39[0],
              yd_inv = _ref39[1];

          x = field.mul(xn, xd_inv);
          y = field.mul(y, field.mul(yn, yd_inv));
          return {
            x: x,
            y: y
          };
        };
      }

      exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");

      function createHasher(Point, mapToCurve, defaults) {
        if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");

        function map(num) {
          return Point.fromAffine(mapToCurve(num));
        }

        function clear(initial) {
          var P = initial.clearCofactor();
          if (P.equals(Point.ZERO)) return Point.ZERO;
          P.assertValidity();
          return P;
        }

        return {
          defaults: defaults,
          hashToCurve: function hashToCurve(msg, options) {
            var opts = Object.assign({}, defaults, options);
            var u = hash_to_field(msg, 2, opts);
            var u0 = map(u[0]);
            var u1 = map(u[1]);
            return clear(u0.add(u1));
          },
          encodeToCurve: function encodeToCurve(msg, options) {
            var optsDst = defaults.encodeDST ? {
              DST: defaults.encodeDST
            } : {};
            var opts = Object.assign({}, defaults, optsDst, options);
            var u = hash_to_field(msg, 1, opts);
            var u0 = map(u[0]);
            return clear(u0);
          },

          /** See {@link H2CHasher} */
          mapToCurve: function mapToCurve(scalars) {
            if (!Array.isArray(scalars)) throw new Error("expected array of bigints");

            for (var _iterator17 = _createForOfIteratorHelperLoose(scalars), _step17; !(_step17 = _iterator17()).done;) {
              var i = _step17.value;
              if (typeof i !== "bigint") throw new Error("expected array of bigints");
            }

            return clear(map(scalars));
          },
          // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
          // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
          hashToScalar: function hashToScalar(msg, options) {
            var N = Point.Fn.ORDER;
            var opts = Object.assign({}, defaults, {
              p: N,
              m: 1,
              DST: exports._DST_scalar
            }, options);
            return hash_to_field(msg, 1, opts)[0][0];
          }
        };
      }
    }
  }); // node_modules/@noble/hashes/hmac.js


  var require_hmac = __commonJS({
    "node_modules/@noble/hashes/hmac.js": function node_modulesNobleHashesHmacJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hmac = exports.HMAC = void 0;
      var utils_ts_1 = require_utils();

      var HMAC = /*#__PURE__*/function (_utils_ts_1$Hash2) {
        _inheritsLoose(HMAC, _utils_ts_1$Hash2);

        function HMAC(hash, _key) {
          var _this46;

          _this46 = _utils_ts_1$Hash2.call(this) || this;
          _this46.finished = false;
          _this46.destroyed = false;
          (0, utils_ts_1.ahash)(hash);
          var key = (0, utils_ts_1.toBytes)(_key);
          _this46.iHash = hash.create();
          if (typeof _this46.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
          _this46.blockLen = _this46.iHash.blockLen;
          _this46.outputLen = _this46.iHash.outputLen;
          var blockLen = _this46.blockLen;
          var pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);

          for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 54;
          }

          _this46.iHash.update(pad);

          _this46.oHash = hash.create();

          for (var _i15 = 0; _i15 < pad.length; _i15++) {
            pad[_i15] ^= 54 ^ 92;
          }

          _this46.oHash.update(pad);

          (0, utils_ts_1.clean)(pad);
          return _this46;
        }

        var _proto61 = HMAC.prototype;

        _proto61.update = function update(buf) {
          (0, utils_ts_1.aexists)(this);
          this.iHash.update(buf);
          return this;
        };

        _proto61.digestInto = function digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.abytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        };

        _proto61.digest = function digest() {
          var out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        };

        _proto61._cloneInto = function _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          var oHash = this.oHash,
              iHash = this.iHash,
              finished = this.finished,
              destroyed = this.destroyed,
              blockLen = this.blockLen,
              outputLen = this.outputLen;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        };

        _proto61.clone = function clone() {
          return this._cloneInto();
        };

        _proto61.destroy = function destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        };

        return HMAC;
      }(utils_ts_1.Hash);

      exports.HMAC = HMAC;

      var hmac = function hmac(hash, key, message) {
        return new HMAC(hash, key).update(message).digest();
      };

      exports.hmac = hmac;

      exports.hmac.create = function (hash, key) {
        return new HMAC(hash, key);
      };
    }
  }); // node_modules/@noble/curves/abstract/weierstrass.js


  var require_weierstrass = __commonJS({
    "node_modules/@noble/curves/abstract/weierstrass.js": function node_modulesNobleCurvesAbstractWeierstrassJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DER = exports.DERErr = void 0;
      exports._splitEndoScalar = _splitEndoScalar;
      exports._normFnElement = _normFnElement;
      exports.weierstrassN = weierstrassN;
      exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
      exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
      exports.ecdh = ecdh;
      exports.ecdsa = ecdsa;
      exports.weierstrassPoints = weierstrassPoints;
      exports._legacyHelperEquat = _legacyHelperEquat;
      exports.weierstrass = weierstrass;
      var hmac_js_1 = require_hmac();
      var utils_1 = require_utils();
      var utils_ts_1 = require_utils3();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();

      var divNearest = function divNearest(num, den) {
        return (num + (num >= 0 ? den : -den) / _2n) / den;
      };

      function _splitEndoScalar(k, basis, n) {
        var _basis$ = basis[0],
            a1 = _basis$[0],
            b1 = _basis$[1],
            _basis$2 = basis[1],
            a2 = _basis$2[0],
            b2 = _basis$2[1];
        var c1 = divNearest(b2 * k, n);
        var c2 = divNearest(-b1 * k, n);
        var k1 = k - c1 * a1 - c2 * a2;
        var k2 = -c1 * b1 - c2 * b2;
        var k1neg = k1 < _0n;
        var k2neg = k2 < _0n;
        if (k1neg) k1 = -k1;
        if (k2neg) k2 = -k2;

        var MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;

        if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
          throw new Error("splitScalar (endomorphism): failed, k=" + k);
        }

        return {
          k1neg: k1neg,
          k1: k1,
          k2neg: k2neg,
          k2: k2
        };
      }

      function validateSigFormat(format) {
        if (!["compact", "recovered", "der"].includes(format)) throw new Error('Signature format must be "compact", "recovered", or "der"');
        return format;
      }

      function validateSigOpts(opts, def) {
        var optsn = {};

        for (var _i16 = 0, _Object$keys = Object.keys(def); _i16 < _Object$keys.length; _i16++) {
          var optName = _Object$keys[_i16];
          optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
        }

        (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
        (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
        if (optsn.format !== void 0) validateSigFormat(optsn.format);
        return optsn;
      }

      var DERErr = /*#__PURE__*/function (_Error2) {
        _inheritsLoose(DERErr, _Error2);

        function DERErr(m) {
          if (m === void 0) {
            m = "";
          }

          return _Error2.call(this, m) || this;
        }

        return DERErr;
      }( /*#__PURE__*/_wrapNativeSuper(Error));

      exports.DERErr = DERErr;
      exports.DER = {
        // asn.1 DER encoding utils
        Err: DERErr,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: function encode(tag, data) {
            var E = exports.DER.Err;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (data.length & 1) throw new E("tlv.encode: unpadded data");
            var dataLen = data.length / 2;
            var len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
            var lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
            var t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode: function decode(tag, data) {
            var E = exports.DER.Err;
            var pos = 0;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
            var first = data[pos++];
            var isLong = !!(first & 128);
            var length = 0;
            if (!isLong) length = first;else {
              var lenLen = first & 127;
              if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
              var lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");

              for (var _iterator18 = _createForOfIteratorHelperLoose(lengthBytes), _step18; !(_step18 = _iterator18()).done;) {
                var b = _step18.value;
                length = length << 8 | b;
              }

              pos += lenLen;
              if (length < 128) throw new E("tlv.decode(long): not minimal encoding");
            }
            var v = data.subarray(pos, pos + length);
            if (v.length !== length) throw new E("tlv.decode: wrong value length");
            return {
              v: v,
              l: data.subarray(pos + length)
            };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode: function encode(num) {
            var E = exports.DER.Err;
            if (num < _0n) throw new E("integer: negative integers are not allowed");
            var hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
            if (hex.length & 1) throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex;
          },
          decode: function decode(data) {
            var E = exports.DER.Err;
            if (data[0] & 128) throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128)) throw new E("invalid signature integer: unnecessary leading zero");
            return (0, utils_ts_1.bytesToNumberBE)(data);
          }
        },
        toSig: function toSig(hex) {
          var _exports$DER = exports.DER,
              E = _exports$DER.Err,
              _int = _exports$DER._int,
              tlv = _exports$DER._tlv;
          var data = (0, utils_ts_1.ensureBytes)("signature", hex);

          var _tlv$decode = tlv.decode(48, data),
              seqBytes = _tlv$decode.v,
              seqLeftBytes = _tlv$decode.l;

          if (seqLeftBytes.length) throw new E("invalid signature: left bytes after parsing");

          var _tlv$decode2 = tlv.decode(2, seqBytes),
              rBytes = _tlv$decode2.v,
              rLeftBytes = _tlv$decode2.l;

          var _tlv$decode3 = tlv.decode(2, rLeftBytes),
              sBytes = _tlv$decode3.v,
              sLeftBytes = _tlv$decode3.l;

          if (sLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
          return {
            r: _int.decode(rBytes),
            s: _int.decode(sBytes)
          };
        },
        hexFromSig: function hexFromSig(sig) {
          var _exports$DER2 = exports.DER,
              tlv = _exports$DER2._tlv,
              _int2 = _exports$DER2._int;
          var rs = tlv.encode(2, _int2.encode(sig.r));
          var ss = tlv.encode(2, _int2.encode(sig.s));
          var seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _3n = BigInt(3);

      var _4n = BigInt(4);

      function _normFnElement(Fn, key) {
        var expected = Fn.BYTES;
        var num;

        if (typeof key === "bigint") {
          num = key;
        } else {
          var bytes = (0, utils_ts_1.ensureBytes)("private key", key);

          try {
            num = Fn.fromBytes(bytes);
          } catch (error) {
            throw new Error("invalid private key: expected ui8a of size " + expected + ", got " + typeof key);
          }
        }

        if (!Fn.isValidNot0(num)) throw new Error("invalid private key: out of range [1..N-1]");
        return num;
      }

      function weierstrassN(params, extraOpts) {
        if (extraOpts === void 0) {
          extraOpts = {};
        }

        var validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
        var Fp = validated.Fp,
            Fn = validated.Fn;
        var _CURVE = validated.CURVE;
        var cofactor = _CURVE.h,
            CURVE_ORDER = _CURVE.n;
        (0, utils_ts_1._validateObject)(extraOpts, {}, {
          allowInfinityPoint: "boolean",
          clearCofactor: "function",
          isTorsionFree: "function",
          fromBytes: "function",
          toBytes: "function",
          endo: "object",
          wrapPrivateKey: "boolean"
        });
        var _extraOpts = extraOpts,
            endo = _extraOpts.endo;

        if (endo) {
          if (!Fp.is0(_CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
          }
        }

        var lengths = getWLengths(Fp, Fn);

        function assertCompressionIsSupported() {
          if (!Fp.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
        }

        function pointToBytes(_c, point, isCompressed) {
          var _point$toAffine = point.toAffine(),
              x = _point$toAffine.x,
              y = _point$toAffine.y;

          var bx = Fp.toBytes(x);
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");

          if (isCompressed) {
            assertCompressionIsSupported();
            var hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
          } else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
          }
        }

        function pointFromBytes(bytes) {
          (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
          var comp = lengths.publicKey,
              uncomp = lengths.publicKeyUncompressed;
          var length = bytes.length;
          var head = bytes[0];
          var tail = bytes.subarray(1);

          if (length === comp && (head === 2 || head === 3)) {
            var x = Fp.fromBytes(tail);
            if (!Fp.isValid(x)) throw new Error("bad point: is not on curve, wrong x");
            var y2 = weierstrassEquation(x);
            var y;

            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              var err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + err);
            }

            assertCompressionIsSupported();
            var isYOdd = Fp.isOdd(y);
            var isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd) y = Fp.neg(y);
            return {
              x: x,
              y: y
            };
          } else if (length === uncomp && head === 4) {
            var L = Fp.BYTES;

            var _x9 = Fp.fromBytes(tail.subarray(0, L));

            var _y2 = Fp.fromBytes(tail.subarray(L, L * 2));

            if (!isValidXY(_x9, _y2)) throw new Error("bad point: is not on curve");
            return {
              x: _x9,
              y: _y2
            };
          } else {
            throw new Error("bad point: got length " + length + ", expected compressed=" + comp + " or uncompressed=" + uncomp);
          }
        }

        var encodePoint = extraOpts.toBytes || pointToBytes;
        var decodePoint = extraOpts.fromBytes || pointFromBytes;

        function weierstrassEquation(x) {
          var x2 = Fp.sqr(x);
          var x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, _CURVE.a)), _CURVE.b);
        }

        function isValidXY(x, y) {
          var left = Fp.sqr(y);
          var right = weierstrassEquation(x);
          return Fp.eql(left, right);
        }

        if (!isValidXY(_CURVE.Gx, _CURVE.Gy)) throw new Error("bad curve params: generator point");

        var _4a3 = Fp.mul(Fp.pow(_CURVE.a, _3n), _4n);

        var _27b2 = Fp.mul(Fp.sqr(_CURVE.b), BigInt(27));

        if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error("bad curve params: a or b");

        function acoord(title, n, banZero) {
          if (banZero === void 0) {
            banZero = false;
          }

          if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error("bad point coordinate " + title);
          return n;
        }

        function aprjpoint(other) {
          if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
        }

        function splitEndoScalarN(k) {
          if (!endo || !endo.basises) throw new Error("no endo");
          return _splitEndoScalar(k, endo.basises, Fn.ORDER);
        }

        var toAffineMemo = (0, utils_ts_1.memoized)(function (p, iz) {
          var X = p.X,
              Y = p.Y,
              Z = p.Z;
          if (Fp.eql(Z, Fp.ONE)) return {
            x: X,
            y: Y
          };
          var is0 = p.is0();
          if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);
          var x = Fp.mul(X, iz);
          var y = Fp.mul(Y, iz);
          var zz = Fp.mul(Z, iz);
          if (is0) return {
            x: Fp.ZERO,
            y: Fp.ZERO
          };
          if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
          return {
            x: x,
            y: y
          };
        });
        var assertValidMemo = (0, utils_ts_1.memoized)(function (p) {
          if (p.is0()) {
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;
            throw new Error("bad point: ZERO");
          }

          var _p$toAffine = p.toAffine(),
              x = _p$toAffine.x,
              y = _p$toAffine.y;

          if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error("bad point: x or y not field elements");
          if (!isValidXY(x, y)) throw new Error("bad point: equation left != right");
          if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
          return true;
        });

        function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
          k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
          k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
          k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
          return k1p.add(k2p);
        }

        var Point = /*#__PURE__*/function () {
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          function Point(X, Y, Z) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y, true);
            this.Z = acoord("z", Z);
            Object.freeze(this);
          }

          Point.CURVE = function CURVE() {
            return _CURVE;
          }
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          ;

          Point.fromAffine = function fromAffine(p) {
            var _ref40 = p || {},
                x = _ref40.x,
                y = _ref40.y;

            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error("invalid affine point");
            if (p instanceof Point) throw new Error("projective point not allowed");
            if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          };

          Point.fromBytes = function fromBytes(bytes) {
            var P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
            P.assertValidity();
            return P;
          };

          Point.fromHex = function fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex));
          };

          var _proto62 = Point.prototype;

          /**
           *
           * @param windowSize
           * @param isLazy true will defer table computation until the first multiplication
           * @returns
           */
          _proto62.precompute = function precompute(windowSize, isLazy) {
            if (windowSize === void 0) {
              windowSize = 8;
            }

            if (isLazy === void 0) {
              isLazy = true;
            }

            wnaf.createCache(this, windowSize);
            if (!isLazy) this.multiply(_3n);
            return this;
          } // TODO: return `this`

          /** A point on curve is valid if it conforms to equation. */
          ;

          _proto62.assertValidity = function assertValidity() {
            assertValidMemo(this);
          };

          _proto62.hasEvenY = function hasEvenY() {
            var _this$toAffine = this.toAffine(),
                y = _this$toAffine.y;

            if (!Fp.isOdd) throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
          }
          /** Compare one point to another. */
          ;

          _proto62.equals = function equals(other) {
            aprjpoint(other);
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z;
            var X2 = other.X,
                Y2 = other.Y,
                Z2 = other.Z;
            var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
          ;

          _proto62.negate = function negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
          } // Renes-Costello-Batina exception-free doubling formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 3
          // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
          ;

          _proto62["double"] = function double() {
            var a = _CURVE.a,
                b = _CURVE.b;
            var b3 = Fp.mul(b, _3n);
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z;
            var X3 = Fp.ZERO,
                Y3 = Fp.ZERO,
                Z3 = Fp.ZERO;
            var t0 = Fp.mul(X1, X1);
            var t1 = Fp.mul(Y1, Y1);
            var t2 = Fp.mul(Z1, Z1);
            var t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3);
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3);
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3);
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0);
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1);
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3);
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          } // Renes-Costello-Batina exception-free addition formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 1
          // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
          ;

          _proto62.add = function add(other) {
            aprjpoint(other);
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z;
            var X2 = other.X,
                Y2 = other.Y,
                Z2 = other.Z;
            var X3 = Fp.ZERO,
                Y3 = Fp.ZERO,
                Z3 = Fp.ZERO;
            var a = _CURVE.a;
            var b3 = Fp.mul(_CURVE.b, _3n);
            var t0 = Fp.mul(X1, X2);
            var t1 = Fp.mul(Y1, Y2);
            var t2 = Fp.mul(Z1, Z2);
            var t3 = Fp.add(X1, Y1);
            var t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            var t5 = Fp.add(X2, Z2);
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2);
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2);
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0);
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2);
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4);
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0);
            return new Point(X3, Y3, Z3);
          };

          _proto62.subtract = function subtract(other) {
            return this.add(other.negate());
          };

          _proto62.is0 = function is0() {
            return this.equals(Point.ZERO);
          }
          /**
           * Constant time multiplication.
           * Uses wNAF method. Windowed method may be 10% faster,
           * but takes 2x longer to generate and consumes 2x memory.
           * Uses precomputes when available.
           * Uses endomorphism for Koblitz curves.
           * @param scalar by which the point would be multiplied
           * @returns New point
           */
          ;

          _proto62.multiply = function multiply(scalar) {
            var _this47 = this;

            var _extraOpts2 = extraOpts,
                endo2 = _extraOpts2.endo;
            if (!Fn.isValidNot0(scalar)) throw new Error("invalid scalar: out of range");
            var point, fake;

            var mul = function mul(n) {
              return wnaf.cached(_this47, n, function (p) {
                return (0, curve_ts_1.normalizeZ)(Point, p);
              });
            };

            if (endo2) {
              var _splitEndoScalarN = splitEndoScalarN(scalar),
                  k1neg = _splitEndoScalarN.k1neg,
                  k1 = _splitEndoScalarN.k1,
                  k2neg = _splitEndoScalarN.k2neg,
                  k2 = _splitEndoScalarN.k2;

              var _mul = mul(k1),
                  k1p = _mul.p,
                  k1f = _mul.f;

              var _mul2 = mul(k2),
                  k2p = _mul2.p,
                  k2f = _mul2.f;

              fake = k1f.add(k2f);
              point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
            } else {
              var _mul3 = mul(scalar),
                  p = _mul3.p,
                  f = _mul3.f;

              point = p;
              fake = f;
            }

            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
          }
          /**
           * Non-constant-time multiplication. Uses double-and-add algorithm.
           * It's faster, but should only be used when you don't care about
           * an exposed secret key e.g. sig verification, which works over *public* keys.
           */
          ;

          _proto62.multiplyUnsafe = function multiplyUnsafe(sc) {
            var _extraOpts3 = extraOpts,
                endo2 = _extraOpts3.endo;
            var p = this;
            if (!Fn.isValid(sc)) throw new Error("invalid scalar: out of range");
            if (sc === _0n || p.is0()) return Point.ZERO;
            if (sc === _1n) return p;
            if (wnaf.hasCache(this)) return this.multiply(sc);

            if (endo2) {
              var _splitEndoScalarN2 = splitEndoScalarN(sc),
                  k1neg = _splitEndoScalarN2.k1neg,
                  k1 = _splitEndoScalarN2.k1,
                  k2neg = _splitEndoScalarN2.k2neg,
                  k2 = _splitEndoScalarN2.k2;

              var _ref41 = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2),
                  p1 = _ref41.p1,
                  p2 = _ref41.p2;

              return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
            } else {
              return wnaf.unsafe(p, sc);
            }
          };

          _proto62.multiplyAndAddUnsafe = function multiplyAndAddUnsafe(Q, a, b) {
            var sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? void 0 : sum;
          }
          /**
           * Converts Projective point to affine (x, y) coordinates.
           * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
           */
          ;

          _proto62.toAffine = function toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          }
          /**
           * Checks whether Point is free of torsion elements (is in prime subgroup).
           * Always torsion-free for cofactor=1 curves.
           */
          ;

          _proto62.isTorsionFree = function isTorsionFree() {
            var _extraOpts4 = extraOpts,
                isTorsionFree = _extraOpts4.isTorsionFree;
            if (cofactor === _1n) return true;
            if (isTorsionFree) return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
          };

          _proto62.clearCofactor = function clearCofactor() {
            var _extraOpts5 = extraOpts,
                clearCofactor = _extraOpts5.clearCofactor;
            if (cofactor === _1n) return this;
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
          };

          _proto62.isSmallOrder = function isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          };

          _proto62.toBytes = function toBytes(isCompressed) {
            if (isCompressed === void 0) {
              isCompressed = true;
            }

            (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
          };

          _proto62.toHex = function toHex(isCompressed) {
            if (isCompressed === void 0) {
              isCompressed = true;
            }

            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
          };

          _proto62.toString = function toString() {
            return "<Point " + (this.is0() ? "ZERO" : this.toHex()) + ">";
          } // TODO: remove
          ;

          _proto62.toRawBytes = function toRawBytes(isCompressed) {
            if (isCompressed === void 0) {
              isCompressed = true;
            }

            return this.toBytes(isCompressed);
          };

          _proto62._setWindowSize = function _setWindowSize(windowSize) {
            this.precompute(windowSize);
          };

          Point.normalizeZ = function normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          };

          Point.msm = function msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          };

          Point.fromPrivateKey = function fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
          };

          _createClass(Point, [{
            key: "x",
            get: function get() {
              return this.toAffine().x;
            }
          }, {
            key: "y",
            get: function get() {
              return this.toAffine().y;
            }
          }, {
            key: "px",
            get: function get() {
              return this.X;
            }
          }, {
            key: "py",
            get: function get() {
              return this.X;
            }
          }, {
            key: "pz",
            get: function get() {
              return this.Z;
            }
          }]);

          return Point;
        }();

        Point.BASE = new Point(_CURVE.Gx, _CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        Point.Fp = Fp;
        Point.Fn = Fn;
        var bits = Fn.BITS;
        var wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
        Point.BASE.precompute(8);
        return Point;
      }

      function pprefix(hasEvenY) {
        return Uint8Array.of(hasEvenY ? 2 : 3);
      }

      function SWUFpSqrtRatio(Fp, Z) {
        var q = Fp.ORDER;
        var l = _0n;

        for (var o = q - _1n; o % _2n === _0n; o /= _2n) {
          l += _1n;
        }

        var c1 = l;

        var _2n_pow_c1_1 = _2n << c1 - _1n - _1n;

        var _2n_pow_c1 = _2n_pow_c1_1 * _2n;

        var c2 = (q - _1n) / _2n_pow_c1;
        var c3 = (c2 - _1n) / _2n;
        var c4 = _2n_pow_c1 - _1n;
        var c5 = _2n_pow_c1_1;
        var c6 = Fp.pow(Z, c2);
        var c7 = Fp.pow(Z, (c2 + _1n) / _2n);

        var sqrtRatio = function sqrtRatio(u, v) {
          var tv1 = c6;
          var tv2 = Fp.pow(v, c4);
          var tv3 = Fp.sqr(tv2);
          tv3 = Fp.mul(tv3, v);
          var tv5 = Fp.mul(u, tv3);
          tv5 = Fp.pow(tv5, c3);
          tv5 = Fp.mul(tv5, tv2);
          tv2 = Fp.mul(tv5, v);
          tv3 = Fp.mul(tv5, u);
          var tv4 = Fp.mul(tv3, tv2);
          tv5 = Fp.pow(tv4, c5);
          var isQR = Fp.eql(tv5, Fp.ONE);
          tv2 = Fp.mul(tv3, c7);
          tv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, isQR);
          tv4 = Fp.cmov(tv5, tv4, isQR);

          for (var i = c1; i > _1n; i--) {
            var tv52 = i - _2n;
            tv52 = _2n << tv52 - _1n;
            var tvv5 = Fp.pow(tv4, tv52);
            var e1 = Fp.eql(tvv5, Fp.ONE);
            tv2 = Fp.mul(tv3, tv1);
            tv1 = Fp.mul(tv1, tv1);
            tvv5 = Fp.mul(tv4, tv1);
            tv3 = Fp.cmov(tv2, tv3, e1);
            tv4 = Fp.cmov(tvv5, tv4, e1);
          }

          return {
            isValid: isQR,
            value: tv3
          };
        };

        if (Fp.ORDER % _4n === _3n) {
          var c12 = (Fp.ORDER - _3n) / _4n;
          var c22 = Fp.sqrt(Fp.neg(Z));

          sqrtRatio = function sqrtRatio(u, v) {
            var tv1 = Fp.sqr(v);
            var tv2 = Fp.mul(u, v);
            tv1 = Fp.mul(tv1, tv2);
            var y1 = Fp.pow(tv1, c12);
            y1 = Fp.mul(y1, tv2);
            var y2 = Fp.mul(y1, c22);
            var tv3 = Fp.mul(Fp.sqr(y1), v);
            var isQR = Fp.eql(tv3, u);
            var y = Fp.cmov(y2, y1, isQR);
            return {
              isValid: isQR,
              value: y
            };
          };
        }

        return sqrtRatio;
      }

      function mapToCurveSimpleSWU(Fp, opts) {
        (0, modular_ts_1.validateField)(Fp);
        var A = opts.A,
            B = opts.B,
            Z = opts.Z;
        if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
        var sqrtRatio = SWUFpSqrtRatio(Fp, Z);
        if (!Fp.isOdd) throw new Error("Field does not have .isOdd()");
        return function (u) {
          var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
          tv1 = Fp.sqr(u);
          tv1 = Fp.mul(tv1, Z);
          tv2 = Fp.sqr(tv1);
          tv2 = Fp.add(tv2, tv1);
          tv3 = Fp.add(tv2, Fp.ONE);
          tv3 = Fp.mul(tv3, B);
          tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
          tv4 = Fp.mul(tv4, A);
          tv2 = Fp.sqr(tv3);
          tv6 = Fp.sqr(tv4);
          tv5 = Fp.mul(tv6, A);
          tv2 = Fp.add(tv2, tv5);
          tv2 = Fp.mul(tv2, tv3);
          tv6 = Fp.mul(tv6, tv4);
          tv5 = Fp.mul(tv6, B);
          tv2 = Fp.add(tv2, tv5);
          x = Fp.mul(tv1, tv3);

          var _sqrtRatio = sqrtRatio(tv2, tv6),
              isValid = _sqrtRatio.isValid,
              value = _sqrtRatio.value;

          y = Fp.mul(tv1, u);
          y = Fp.mul(y, value);
          x = Fp.cmov(x, tv3, isValid);
          y = Fp.cmov(y, value, isValid);
          var e1 = Fp.isOdd(u) === Fp.isOdd(y);
          y = Fp.cmov(Fp.neg(y), y, e1);
          var tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
          x = Fp.mul(x, tv4_inv);
          return {
            x: x,
            y: y
          };
        };
      }

      function getWLengths(Fp, Fn) {
        return {
          secretKey: Fn.BYTES,
          publicKey: 1 + Fp.BYTES,
          publicKeyUncompressed: 1 + 2 * Fp.BYTES,
          publicKeyHasPrefix: true,
          signature: 2 * Fn.BYTES
        };
      }

      function ecdh(Point, ecdhOpts) {
        if (ecdhOpts === void 0) {
          ecdhOpts = {};
        }

        var Fn = Point.Fn;
        var randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
        var lengths = Object.assign(getWLengths(Point.Fp, Fn), {
          seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER)
        });

        function isValidSecretKey(secretKey) {
          try {
            return !!_normFnElement(Fn, secretKey);
          } catch (error) {
            return false;
          }
        }

        function isValidPublicKey(publicKey, isCompressed) {
          var comp = lengths.publicKey,
              publicKeyUncompressed = lengths.publicKeyUncompressed;

          try {
            var l = publicKey.length;
            if (isCompressed === true && l !== comp) return false;
            if (isCompressed === false && l !== publicKeyUncompressed) return false;
            return !!Point.fromBytes(publicKey);
          } catch (error) {
            return false;
          }
        }

        function randomSecretKey(seed) {
          if (seed === void 0) {
            seed = randomBytes_(lengths.seed);
          }

          return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"), Fn.ORDER);
        }

        function getPublicKey(secretKey, isCompressed) {
          if (isCompressed === void 0) {
            isCompressed = true;
          }

          return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
        }

        function keygen(seed) {
          var secretKey = randomSecretKey(seed);
          return {
            secretKey: secretKey,
            publicKey: getPublicKey(secretKey)
          };
        }

        function isProbPub(item) {
          if (typeof item === "bigint") return false;
          if (item instanceof Point) return true;
          var secretKey = lengths.secretKey,
              publicKey = lengths.publicKey,
              publicKeyUncompressed = lengths.publicKeyUncompressed;
          if (Fn.allowedLengths || secretKey === publicKey) return void 0;
          var l = (0, utils_ts_1.ensureBytes)("key", item).length;
          return l === publicKey || l === publicKeyUncompressed;
        }

        function getSharedSecret(secretKeyA, publicKeyB, isCompressed) {
          if (isCompressed === void 0) {
            isCompressed = true;
          }

          if (isProbPub(secretKeyA) === true) throw new Error("first arg must be private key");
          if (isProbPub(publicKeyB) === false) throw new Error("second arg must be public key");

          var s = _normFnElement(Fn, secretKeyA);

          var b = Point.fromHex(publicKeyB);
          return b.multiply(s).toBytes(isCompressed);
        }

        var utils = {
          isValidSecretKey: isValidSecretKey,
          isValidPublicKey: isValidPublicKey,
          randomSecretKey: randomSecretKey,
          // TODO: remove
          isValidPrivateKey: isValidSecretKey,
          randomPrivateKey: randomSecretKey,
          normPrivateKeyToScalar: function normPrivateKeyToScalar(key) {
            return _normFnElement(Fn, key);
          },
          precompute: function precompute(windowSize, point) {
            if (windowSize === void 0) {
              windowSize = 8;
            }

            if (point === void 0) {
              point = Point.BASE;
            }

            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({
          getPublicKey: getPublicKey,
          getSharedSecret: getSharedSecret,
          keygen: keygen,
          Point: Point,
          utils: utils,
          lengths: lengths
        });
      }

      function ecdsa(Point, hash, ecdsaOpts) {
        if (ecdsaOpts === void 0) {
          ecdsaOpts = {};
        }

        (0, utils_1.ahash)(hash);
        (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
          hmac: "function",
          lowS: "boolean",
          randomBytes: "function",
          bits2int: "function",
          bits2int_modN: "function"
        });
        var randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;

        var hmac = ecdsaOpts.hmac || function (key) {
          for (var _len9 = arguments.length, msgs = new Array(_len9 > 1 ? _len9 - 1 : 0), _key11 = 1; _key11 < _len9; _key11++) {
            msgs[_key11 - 1] = arguments[_key11];
          }

          return (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes).apply(void 0, msgs));
        };

        var Fp = Point.Fp,
            Fn = Point.Fn;
        var CURVE_ORDER = Fn.ORDER,
            fnBits = Fn.BITS;

        var _ecdh = ecdh(Point, ecdsaOpts),
            keygen = _ecdh.keygen,
            getPublicKey = _ecdh.getPublicKey,
            getSharedSecret = _ecdh.getSharedSecret,
            utils = _ecdh.utils,
            lengths = _ecdh.lengths;

        var defaultSigOpts = {
          prehash: false,
          lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
          format: void 0,
          //'compact' as ECDSASigFormat,
          extraEntropy: false
        };
        var defaultSigOpts_format = "compact";

        function isBiggerThanHalfOrder(number) {
          var HALF = CURVE_ORDER >> _1n;
          return number > HALF;
        }

        function validateRS(title, num) {
          if (!Fn.isValidNot0(num)) throw new Error("invalid signature " + title + ": out of range 1..Point.Fn.ORDER");
          return num;
        }

        function validateSigLength(bytes, format) {
          validateSigFormat(format);
          var size = lengths.signature;
          var sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
          return (0, utils_ts_1._abytes2)(bytes, sizer, format + " signature");
        }

        var Signature = /*#__PURE__*/function () {
          function Signature(r, s, recovery) {
            this.r = validateRS("r", r);
            this.s = validateRS("s", s);
            if (recovery != null) this.recovery = recovery;
            Object.freeze(this);
          }

          Signature.fromBytes = function fromBytes(bytes, format) {
            if (format === void 0) {
              format = defaultSigOpts_format;
            }

            validateSigLength(bytes, format);
            var recid;

            if (format === "der") {
              var _exports$DER$toSig = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes)),
                  r2 = _exports$DER$toSig.r,
                  s2 = _exports$DER$toSig.s;

              return new Signature(r2, s2);
            }

            if (format === "recovered") {
              recid = bytes[0];
              format = "compact";
              bytes = bytes.subarray(1);
            }

            var L = Fn.BYTES;
            var r = bytes.subarray(0, L);
            var s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
          };

          Signature.fromHex = function fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
          };

          var _proto63 = Signature.prototype;

          _proto63.addRecoveryBit = function addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          };

          _proto63.recoverPublicKey = function recoverPublicKey(messageHash) {
            var FIELD_ORDER = Fp.ORDER;
            var r = this.r,
                s = this.s,
                rec = this.recovery;
            if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error("recovery id invalid");
            var hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            var radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj)) throw new Error("recovery id 2 or 3 invalid");
            var x = Fp.toBytes(radj);
            var R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            var ir = Fn.inv(radj);
            var h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
            var u1 = Fn.create(-h * ir);
            var u2 = Fn.create(s * ir);
            var Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0()) throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          } // Signatures should be low-s, to prevent malleability.
          ;

          _proto63.hasHighS = function hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          };

          _proto63.toBytes = function toBytes(format) {
            if (format === void 0) {
              format = defaultSigOpts_format;
            }

            validateSigFormat(format);
            if (format === "der") return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            var r = Fn.toBytes(this.r);
            var s = Fn.toBytes(this.s);

            if (format === "recovered") {
              if (this.recovery == null) throw new Error("recovery bit must be present");
              return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }

            return (0, utils_ts_1.concatBytes)(r, s);
          };

          _proto63.toHex = function toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
          } // TODO: remove
          ;

          _proto63.assertValidity = function assertValidity() {};

          Signature.fromCompact = function fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "compact");
          };

          Signature.fromDER = function fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "der");
          };

          _proto63.normalizeS = function normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
          };

          _proto63.toDERRawBytes = function toDERRawBytes() {
            return this.toBytes("der");
          };

          _proto63.toDERHex = function toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
          };

          _proto63.toCompactRawBytes = function toCompactRawBytes() {
            return this.toBytes("compact");
          };

          _proto63.toCompactHex = function toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
          };

          return Signature;
        }();

        var bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
          if (bytes.length > 8192) throw new Error("input is too large");
          var num = (0, utils_ts_1.bytesToNumberBE)(bytes);
          var delta = bytes.length * 8 - fnBits;
          return delta > 0 ? num >> BigInt(delta) : num;
        };

        var bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
          return Fn.create(bits2int(bytes));
        };

        var ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);

        function int2octets(num) {
          (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
          return Fn.toBytes(num);
        }

        function validateMsgAndHash(message, prehash) {
          (0, utils_ts_1._abytes2)(message, void 0, "message");
          return prehash ? (0, utils_ts_1._abytes2)(hash(message), void 0, "prehashed message") : message;
        }

        function prepSig(message, privateKey, opts) {
          if (["recovered", "canonical"].some(function (k) {
            return k in opts;
          })) throw new Error("sign() legacy options not supported");

          var _validateSigOpts = validateSigOpts(opts, defaultSigOpts),
              lowS = _validateSigOpts.lowS,
              prehash = _validateSigOpts.prehash,
              extraEntropy = _validateSigOpts.extraEntropy;

          message = validateMsgAndHash(message, prehash);
          var h1int = bits2int_modN(message);

          var d = _normFnElement(Fn, privateKey);

          var seedArgs = [int2octets(d), int2octets(h1int)];

          if (extraEntropy != null && extraEntropy !== false) {
            var e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
          }

          var seed = (0, utils_ts_1.concatBytes).apply(void 0, seedArgs);
          var m = h1int;

          function k2sig(kBytes) {
            var k = bits2int(kBytes);
            if (!Fn.isValidNot0(k)) return;
            var ik = Fn.inv(k);
            var q = Point.BASE.multiply(k).toAffine();
            var r = Fn.create(q.x);
            if (r === _0n) return;
            var s = Fn.create(ik * Fn.create(m + r * d));
            if (s === _0n) return;
            var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
            var normS = s;

            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = Fn.neg(s);
              recovery ^= 1;
            }

            return new Signature(r, normS, recovery);
          }

          return {
            seed: seed,
            k2sig: k2sig
          };
        }

        function sign(message, secretKey, opts) {
          if (opts === void 0) {
            opts = {};
          }

          message = (0, utils_ts_1.ensureBytes)("message", message);

          var _prepSig = prepSig(message, secretKey, opts),
              seed = _prepSig.seed,
              k2sig = _prepSig.k2sig;

          var drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
          var sig = drbg(seed, k2sig);
          return sig;
        }

        function tryParsingSig(sg) {
          var sig = void 0;
          var isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
          var isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
          if (!isHex && !isObj) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");

          if (isObj) {
            sig = new Signature(sg.r, sg.s);
          } else if (isHex) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err)) throw derError;
            }

            if (!sig) {
              try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
              } catch (error) {
                return false;
              }
            }
          }

          if (!sig) return false;
          return sig;
        }

        function verify(signature, message, publicKey, opts) {
          if (opts === void 0) {
            opts = {};
          }

          var _validateSigOpts2 = validateSigOpts(opts, defaultSigOpts),
              lowS = _validateSigOpts2.lowS,
              prehash = _validateSigOpts2.prehash,
              format = _validateSigOpts2.format;

          publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
          message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
          if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
          var sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
          if (sig === false) return false;

          try {
            var P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS()) return false;
            var r = sig.r,
                s = sig.s;
            var h = bits2int_modN(message);
            var is = Fn.inv(s);
            var u1 = Fn.create(h * is);
            var u2 = Fn.create(r * is);
            var R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
            if (R.is0()) return false;
            var v = Fn.create(R.x);
            return v === r;
          } catch (e) {
            return false;
          }
        }

        function recoverPublicKey(signature, message, opts) {
          if (opts === void 0) {
            opts = {};
          }

          var _validateSigOpts3 = validateSigOpts(opts, defaultSigOpts),
              prehash = _validateSigOpts3.prehash;

          message = validateMsgAndHash(message, prehash);
          return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
        }

        return Object.freeze({
          keygen: keygen,
          getPublicKey: getPublicKey,
          getSharedSecret: getSharedSecret,
          utils: utils,
          lengths: lengths,
          Point: Point,
          sign: sign,
          verify: verify,
          recoverPublicKey: recoverPublicKey,
          Signature: Signature,
          hash: hash
        });
      }

      function weierstrassPoints(c) {
        var _weierstrass_legacy_o = _weierstrass_legacy_opts_to_new(c),
            CURVE = _weierstrass_legacy_o.CURVE,
            curveOpts = _weierstrass_legacy_o.curveOpts;

        var Point = weierstrassN(CURVE, curveOpts);
        return _weierstrass_new_output_to_legacy(c, Point);
      }

      function _weierstrass_legacy_opts_to_new(c) {
        var CURVE = {
          a: c.a,
          b: c.b,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        var Fp = c.Fp;
        var allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map(function (l) {
          return Math.ceil(l / 2);
        }))) : void 0;
        var Fn = (0, modular_ts_1.Field)(CURVE.n, {
          BITS: c.nBitLength,
          allowedLengths: allowedLengths,
          modFromBytes: c.wrapPrivateKey
        });
        var curveOpts = {
          Fp: Fp,
          Fn: Fn,
          allowInfinityPoint: c.allowInfinityPoint,
          endo: c.endo,
          isTorsionFree: c.isTorsionFree,
          clearCofactor: c.clearCofactor,
          fromBytes: c.fromBytes,
          toBytes: c.toBytes
        };
        return {
          CURVE: CURVE,
          curveOpts: curveOpts
        };
      }

      function _ecdsa_legacy_opts_to_new(c) {
        var _weierstrass_legacy_o2 = _weierstrass_legacy_opts_to_new(c),
            CURVE = _weierstrass_legacy_o2.CURVE,
            curveOpts = _weierstrass_legacy_o2.curveOpts;

        var ecdsaOpts = {
          hmac: c.hmac,
          randomBytes: c.randomBytes,
          lowS: c.lowS,
          bits2int: c.bits2int,
          bits2int_modN: c.bits2int_modN
        };
        return {
          CURVE: CURVE,
          curveOpts: curveOpts,
          hash: c.hash,
          ecdsaOpts: ecdsaOpts
        };
      }

      function _legacyHelperEquat(Fp, a, b) {
        function weierstrassEquation(x) {
          var x2 = Fp.sqr(x);
          var x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
        }

        return weierstrassEquation;
      }

      function _weierstrass_new_output_to_legacy(c, Point) {
        var Fp = Point.Fp,
            Fn = Point.Fn;

        function isWithinCurveOrder(num) {
          return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
        }

        var weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);

        return Object.assign({}, {
          CURVE: c,
          Point: Point,
          ProjectivePoint: Point,
          normPrivateKeyToScalar: function normPrivateKeyToScalar(key) {
            return _normFnElement(Fn, key);
          },
          weierstrassEquation: weierstrassEquation,
          isWithinCurveOrder: isWithinCurveOrder
        });
      }

      function _ecdsa_new_output_to_legacy(c, _ecdsa) {
        var Point = _ecdsa.Point;
        return Object.assign({}, _ecdsa, {
          ProjectivePoint: Point,
          CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
        });
      }

      function weierstrass(c) {
        var _ecdsa_legacy_opts_to = _ecdsa_legacy_opts_to_new(c),
            CURVE = _ecdsa_legacy_opts_to.CURVE,
            curveOpts = _ecdsa_legacy_opts_to.curveOpts,
            hash = _ecdsa_legacy_opts_to.hash,
            ecdsaOpts = _ecdsa_legacy_opts_to.ecdsaOpts;

        var Point = weierstrassN(CURVE, curveOpts);
        var signs = ecdsa(Point, hash, ecdsaOpts);
        return _ecdsa_new_output_to_legacy(c, signs);
      }
    }
  }); // node_modules/@noble/curves/abstract/bls.js


  var require_bls = __commonJS({
    "node_modules/@noble/curves/abstract/bls.js": function node_modulesNobleCurvesAbstractBlsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bls = bls;
      var utils_ts_1 = require_utils3();
      var curve_ts_1 = require_curve();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var weierstrass_ts_1 = require_weierstrass();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _3n = BigInt(3);

      function NAfDecomposition(a) {
        var res = [];

        for (; a > _1n; a >>= _1n) {
          if ((a & _1n) === _0n) res.unshift(0);else if ((a & _3n) === _3n) {
            res.unshift(-1);
            a += _1n;
          } else res.unshift(1);
        }

        return res;
      }

      function aNonEmpty(arr) {
        if (!Array.isArray(arr) || arr.length === 0) throw new Error("expected non-empty array");
      }

      function createBlsPairing(fields, G1, G2, params) {
        var Fp2 = fields.Fp2,
            Fp12 = fields.Fp12;
        var twistType = params.twistType,
            ateLoopSize = params.ateLoopSize,
            xNegative = params.xNegative,
            postPrecompute = params.postPrecompute;
        var lineFunction;

        if (twistType === "multiplicative") {
          lineFunction = function lineFunction(c0, c1, c2, f, Px, Py) {
            return Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));
          };
        } else if (twistType === "divisive") {
          lineFunction = function lineFunction(c0, c1, c2, f, Px, Py) {
            return Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);
          };
        } else throw new Error("bls: unknown twist type");

        var Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));

        function pointDouble(ell, Rx, Ry, Rz) {
          var t0 = Fp2.sqr(Ry);
          var t1 = Fp2.sqr(Rz);
          var t2 = Fp2.mulByB(Fp2.mul(t1, _3n));
          var t3 = Fp2.mul(t2, _3n);
          var t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0);
          var c0 = Fp2.sub(t2, t0);
          var c1 = Fp2.mul(Fp2.sqr(Rx), _3n);
          var c2 = Fp2.neg(t4);
          ell.push([c0, c1, c2]);
          Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2);
          Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n));
          Rz = Fp2.mul(t0, t4);
          return {
            Rx: Rx,
            Ry: Ry,
            Rz: Rz
          };
        }

        function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
          var t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz));
          var t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz));
          var c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy));
          var c1 = Fp2.neg(t0);
          var c2 = t1;
          ell.push([c0, c1, c2]);
          var t2 = Fp2.sqr(t1);
          var t3 = Fp2.mul(t2, t1);
          var t4 = Fp2.mul(t2, Rx);
          var t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz));
          Rx = Fp2.mul(t1, t5);
          Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry));
          Rz = Fp2.mul(Rz, t3);
          return {
            Rx: Rx,
            Ry: Ry,
            Rz: Rz
          };
        }

        var ATE_NAF = NAfDecomposition(ateLoopSize);
        var calcPairingPrecomputes = (0, utils_ts_1.memoized)(function (point) {
          var p = point;

          var _p$toAffine2 = p.toAffine(),
              x = _p$toAffine2.x,
              y = _p$toAffine2.y;

          var Qx = x,
              Qy = y,
              negQy = Fp2.neg(y);
          var Rx = Qx,
              Ry = Qy,
              Rz = Fp2.ONE;
          var ell = [];

          for (var _iterator19 = _createForOfIteratorHelperLoose(ATE_NAF), _step19; !(_step19 = _iterator19()).done;) {
            var bit = _step19.value;
            var cur = [];

            var _pointDouble = pointDouble(cur, Rx, Ry, Rz);

            Rx = _pointDouble.Rx;
            Ry = _pointDouble.Ry;
            Rz = _pointDouble.Rz;

            if (bit) {
              var _pointAdd = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy);

              Rx = _pointAdd.Rx;
              Ry = _pointAdd.Ry;
              Rz = _pointAdd.Rz;
            }

            ell.push(cur);
          }

          if (postPrecompute) {
            var last = ell[ell.length - 1];
            postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));
          }

          return ell;
        });

        function millerLoopBatch(pairs, withFinalExponent) {
          if (withFinalExponent === void 0) {
            withFinalExponent = false;
          }

          var f12 = Fp12.ONE;

          if (pairs.length) {
            var ellLen = pairs[0][0].length;

            for (var i = 0; i < ellLen; i++) {
              f12 = Fp12.sqr(f12);

              for (var _iterator20 = _createForOfIteratorHelperLoose(pairs), _step20; !(_step20 = _iterator20()).done;) {
                var _step20$value = _step20.value,
                    ell = _step20$value[0],
                    Px = _step20$value[1],
                    Py = _step20$value[2];

                for (var _iterator21 = _createForOfIteratorHelperLoose(ell[i]), _step21; !(_step21 = _iterator21()).done;) {
                  var _step21$value = _step21.value,
                      c0 = _step21$value[0],
                      c1 = _step21$value[1],
                      c2 = _step21$value[2];
                  f12 = lineFunction(c0, c1, c2, f12, Px, Py);
                }
              }
            }
          }

          if (xNegative) f12 = Fp12.conjugate(f12);
          return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;
        }

        function pairingBatch(pairs, withFinalExponent) {
          if (withFinalExponent === void 0) {
            withFinalExponent = true;
          }

          var res = [];
          (0, curve_ts_1.normalizeZ)(G1, pairs.map(function (_ref42) {
            var g1 = _ref42.g1;
            return g1;
          }));
          (0, curve_ts_1.normalizeZ)(G2, pairs.map(function (_ref43) {
            var g2 = _ref43.g2;
            return g2;
          }));

          for (var _iterator22 = _createForOfIteratorHelperLoose(pairs), _step22; !(_step22 = _iterator22()).done;) {
            var _step22$value = _step22.value,
                g1 = _step22$value.g1,
                g2 = _step22$value.g2;
            if (g1.is0() || g2.is0()) throw new Error("pairing is not available for ZERO point");
            g1.assertValidity();
            g2.assertValidity();
            var Qa = g1.toAffine();
            res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);
          }

          return millerLoopBatch(res, withFinalExponent);
        }

        function pairing(Q, P, withFinalExponent) {
          if (withFinalExponent === void 0) {
            withFinalExponent = true;
          }

          return pairingBatch([{
            g1: Q,
            g2: P
          }], withFinalExponent);
        }

        return {
          Fp12: Fp12,
          // NOTE: we re-export Fp12 here because pairing results are Fp12!
          millerLoopBatch: millerLoopBatch,
          pairing: pairing,
          pairingBatch: pairingBatch,
          calcPairingPrecomputes: calcPairingPrecomputes
        };
      }

      function createBlsSig(blsPairing, PubCurve, SigCurve, SignatureCoder, isSigG1) {
        var Fp12 = blsPairing.Fp12,
            pairingBatch = blsPairing.pairingBatch;

        function normPub(point) {
          return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);
        }

        function normSig(point) {
          return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);
        }

        function amsg(m) {
          if (!(m instanceof SigCurve.Point)) throw new Error("expected valid message hashed to " + (!isSigG1 ? "G2" : "G1") + " curve");
          return m;
        }

        var pair = !isSigG1 ? function (a, b) {
          return {
            g1: a,
            g2: b
          };
        } : function (a, b) {
          return {
            g1: b,
            g2: a
          };
        };
        return {
          // P = pk x G
          getPublicKey: function getPublicKey(secretKey) {
            var sec = (0, weierstrass_ts_1._normFnElement)(PubCurve.Point.Fn, secretKey);
            return PubCurve.Point.BASE.multiply(sec);
          },
          // S = pk x H(m)
          sign: function sign(message, secretKey, unusedArg) {
            if (unusedArg != null) throw new Error("sign() expects 2 arguments");
            var sec = (0, weierstrass_ts_1._normFnElement)(PubCurve.Point.Fn, secretKey);
            amsg(message).assertValidity();
            return message.multiply(sec);
          },
          // Checks if pairing of public key & hash is equal to pairing of generator & signature.
          // e(P, H(m)) == e(G, S)
          // e(S, G) == e(H(m), P)
          verify: function verify(signature, message, publicKey, unusedArg) {
            if (unusedArg != null) throw new Error("verify() expects 3 arguments");
            signature = normSig(signature);
            publicKey = normPub(publicKey);
            var P = publicKey.negate();
            var G = PubCurve.Point.BASE;
            var Hm = amsg(message);
            var S = signature;
            var exp = pairingBatch([pair(P, Hm), pair(G, S)]);
            return Fp12.eql(exp, Fp12.ONE);
          },
          // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
          // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
          // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?
          verifyBatch: function verifyBatch(signature, messages, publicKeys) {
            aNonEmpty(messages);
            if (publicKeys.length !== messages.length) throw new Error("amount of public keys and messages should be equal");
            var sig = normSig(signature);
            var nMessages = messages;
            var nPublicKeys = publicKeys.map(normPub);
            var messagePubKeyMap = /* @__PURE__ */new Map();

            for (var i = 0; i < nPublicKeys.length; i++) {
              var pub = nPublicKeys[i];
              var msg = nMessages[i];
              var keys = messagePubKeyMap.get(msg);

              if (keys === void 0) {
                keys = [];
                messagePubKeyMap.set(msg, keys);
              }

              keys.push(pub);
            }

            var paired = [];
            var G = PubCurve.Point.BASE;

            try {
              for (var _iterator23 = _createForOfIteratorHelperLoose(messagePubKeyMap), _step23; !(_step23 = _iterator23()).done;) {
                var _step23$value = _step23.value,
                    _msg = _step23$value[0],
                    _keys = _step23$value[1];

                var groupPublicKey = _keys.reduce(function (acc, msg2) {
                  return acc.add(msg2);
                });

                paired.push(pair(groupPublicKey, _msg));
              }

              paired.push(pair(G.negate(), sig));
              return Fp12.eql(pairingBatch(paired), Fp12.ONE);
            } catch (e) {
              return false;
            }
          },
          // Adds a bunch of public key points together.
          // pk1 + pk2 + pk3 = pkA
          aggregatePublicKeys: function aggregatePublicKeys(publicKeys) {
            aNonEmpty(publicKeys);
            publicKeys = publicKeys.map(function (pub) {
              return normPub(pub);
            });
            var agg = publicKeys.reduce(function (sum, p) {
              return sum.add(p);
            }, PubCurve.Point.ZERO);
            agg.assertValidity();
            return agg;
          },
          // Adds a bunch of signature points together.
          // pk1 + pk2 + pk3 = pkA
          aggregateSignatures: function aggregateSignatures(signatures) {
            aNonEmpty(signatures);
            signatures = signatures.map(function (sig) {
              return normSig(sig);
            });
            var agg = signatures.reduce(function (sum, s) {
              return sum.add(s);
            }, SigCurve.Point.ZERO);
            agg.assertValidity();
            return agg;
          },
          hash: function hash(messageBytes, DST) {
            (0, utils_ts_1.abytes)(messageBytes);
            var opts = DST ? {
              DST: DST
            } : void 0;
            return SigCurve.hashToCurve(messageBytes, opts);
          },
          Signature: SignatureCoder
        };
      }

      function bls(CURVE) {
        var _CURVE$fields = CURVE.fields,
            Fp = _CURVE$fields.Fp,
            Fr = _CURVE$fields.Fr,
            Fp2 = _CURVE$fields.Fp2,
            Fp6 = _CURVE$fields.Fp6,
            Fp12 = _CURVE$fields.Fp12;
        var G1_ = (0, weierstrass_ts_1.weierstrassPoints)(CURVE.G1);
        var G1 = Object.assign(G1_, (0, hash_to_curve_ts_1.createHasher)(G1_.Point, CURVE.G1.mapToCurve, _extends({}, CURVE.htfDefaults, CURVE.G1.htfDefaults)));
        var G2_ = (0, weierstrass_ts_1.weierstrassPoints)(CURVE.G2);
        var G2 = Object.assign(G2_, (0, hash_to_curve_ts_1.createHasher)(G2_.Point, CURVE.G2.mapToCurve, _extends({}, CURVE.htfDefaults, CURVE.G2.htfDefaults)));
        var pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, _extends({}, CURVE.params, {
          postPrecompute: CURVE.postPrecompute
        }));
        var millerLoopBatch = pairingRes.millerLoopBatch,
            pairing = pairingRes.pairing,
            pairingBatch = pairingRes.pairingBatch,
            calcPairingPrecomputes = pairingRes.calcPairingPrecomputes;
        var longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);
        var shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);
        var rand = CURVE.randomBytes || utils_ts_1.randomBytes;

        var randomSecretKey = function randomSecretKey() {
          var length = (0, modular_ts_1.getMinHashLength)(Fr.ORDER);
          return (0, modular_ts_1.mapHashToField)(rand(length), Fr.ORDER);
        };

        var utils = {
          randomSecretKey: randomSecretKey,
          randomPrivateKey: randomSecretKey,
          calcPairingPrecomputes: calcPairingPrecomputes
        };
        var ShortSignature = CURVE.G1.ShortSignature;
        var Signature = CURVE.G2.Signature;

        function normP1Hash(point, htfOpts) {
          return point instanceof G1.Point ? point : shortSignatures.hash((0, utils_ts_1.ensureBytes)("point", point), htfOpts == null ? void 0 : htfOpts.DST);
        }

        function normP2Hash(point, htfOpts) {
          return point instanceof G2.Point ? point : longSignatures.hash((0, utils_ts_1.ensureBytes)("point", point), htfOpts == null ? void 0 : htfOpts.DST);
        }

        function getPublicKey(privateKey) {
          return longSignatures.getPublicKey(privateKey).toBytes(true);
        }

        function getPublicKeyForShortSignatures(privateKey) {
          return shortSignatures.getPublicKey(privateKey).toBytes(true);
        }

        function sign(message, privateKey, htfOpts) {
          var Hm = normP2Hash(message, htfOpts);
          var S = longSignatures.sign(Hm, privateKey);
          return message instanceof G2.Point ? S : Signature.toBytes(S);
        }

        function signShortSignature(message, privateKey, htfOpts) {
          var Hm = normP1Hash(message, htfOpts);
          var S = shortSignatures.sign(Hm, privateKey);
          return message instanceof G1.Point ? S : ShortSignature.toBytes(S);
        }

        function verify(signature, message, publicKey, htfOpts) {
          var Hm = normP2Hash(message, htfOpts);
          return longSignatures.verify(signature, Hm, publicKey);
        }

        function verifyShortSignature(signature, message, publicKey, htfOpts) {
          var Hm = normP1Hash(message, htfOpts);
          return shortSignatures.verify(signature, Hm, publicKey);
        }

        function aggregatePublicKeys(publicKeys) {
          var agg = longSignatures.aggregatePublicKeys(publicKeys);
          return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);
        }

        function aggregateSignatures(signatures) {
          var agg = longSignatures.aggregateSignatures(signatures);
          return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);
        }

        function aggregateShortSignatures(signatures) {
          var agg = shortSignatures.aggregateSignatures(signatures);
          return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);
        }

        function verifyBatch(signature, messages, publicKeys, htfOpts) {
          var Hm = messages.map(function (m) {
            return normP2Hash(m, htfOpts);
          });
          return longSignatures.verifyBatch(signature, Hm, publicKeys);
        }

        G1.Point.BASE.precompute(4);
        return {
          longSignatures: longSignatures,
          shortSignatures: shortSignatures,
          millerLoopBatch: millerLoopBatch,
          pairing: pairing,
          pairingBatch: pairingBatch,
          verifyBatch: verifyBatch,
          fields: {
            Fr: Fr,
            Fp: Fp,
            Fp2: Fp2,
            Fp6: Fp6,
            Fp12: Fp12
          },
          params: {
            ateLoopSize: CURVE.params.ateLoopSize,
            twistType: CURVE.params.twistType,
            // deprecated
            r: CURVE.params.r,
            G1b: CURVE.G1.b,
            G2b: CURVE.G2.b
          },
          utils: utils,
          // deprecated
          getPublicKey: getPublicKey,
          getPublicKeyForShortSignatures: getPublicKeyForShortSignatures,
          sign: sign,
          signShortSignature: signShortSignature,
          verify: verify,
          verifyShortSignature: verifyShortSignature,
          aggregatePublicKeys: aggregatePublicKeys,
          aggregateSignatures: aggregateSignatures,
          aggregateShortSignatures: aggregateShortSignatures,
          G1: G1,
          G2: G2,
          Signature: Signature,
          ShortSignature: ShortSignature
        };
      }
    }
  }); // node_modules/@noble/curves/abstract/tower.js


  var require_tower = __commonJS({
    "node_modules/@noble/curves/abstract/tower.js": function node_modulesNobleCurvesAbstractTowerJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.psiFrobenius = psiFrobenius;
      exports.tower12 = tower12;
      var utils_ts_1 = require_utils3();
      var mod = require_modular();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _3n = BigInt(3);

      function calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num, divisor) {
        if (num === void 0) {
          num = 1;
        }

        var _divisor = BigInt(divisor === void 0 ? degree : divisor);

        var towerModulus = function (b, e) {
          var r = BigInt(1);

          for (var i = 0; i < e; i++) {
            r *= b;
          }

          return r;
        }(modulus, degree);

        var res = [];

        for (var i = 0; i < num; i++) {
          var a = BigInt(i + 1);
          var powers = [];

          for (var j = 0, qPower = _1n; j < degree; j++) {
            var power = (a * qPower - a) / _divisor % towerModulus;
            powers.push(Fp.pow(nonResidue, power));
            qPower *= modulus;
          }

          res.push(powers);
        }

        return res;
      }

      function psiFrobenius(Fp, Fp2, base) {
        var PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n);
        var PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n);

        function psi(x, y) {
          var x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);
          var y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);
          return [x2, y2];
        }

        var PSI2_X = Fp2.pow(base, (Fp.ORDER * Fp.ORDER - _1n) / _3n);
        var PSI2_Y = Fp2.pow(base, (Fp.ORDER * Fp.ORDER - _1n) / _2n);
        if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error("psiFrobenius: PSI2_Y!==-1");

        function psi2(x, y) {
          return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];
        }

        var mapAffine = function mapAffine(fn) {
          return function (c, P) {
            var affine = P.toAffine();
            var p = fn(affine.x, affine.y);
            return c.fromAffine({
              x: p[0],
              y: p[1]
            });
          };
        };

        var G2psi = mapAffine(psi);
        var G2psi2 = mapAffine(psi2);
        return {
          psi: psi,
          psi2: psi2,
          G2psi: G2psi,
          G2psi2: G2psi2,
          PSI_X: PSI_X,
          PSI_Y: PSI_Y,
          PSI2_X: PSI2_X,
          PSI2_Y: PSI2_Y
        };
      }

      var Fp2fromBigTuple = function Fp2fromBigTuple(Fp, tuple) {
        if (tuple.length !== 2) throw new Error("invalid tuple");
        var fps = tuple.map(function (n) {
          return Fp.create(n);
        });
        return {
          c0: fps[0],
          c1: fps[1]
        };
      };

      var _Field2 = /*#__PURE__*/function () {
        function _Field2(Fp, opts) {
          if (opts === void 0) {
            opts = {};
          }

          this.MASK = _1n;
          var ORDER = Fp.ORDER;
          var FP2_ORDER = ORDER * ORDER;
          this.Fp = Fp;
          this.ORDER = FP2_ORDER;
          this.BITS = (0, utils_ts_1.bitLen)(FP2_ORDER);
          this.BYTES = Math.ceil((0, utils_ts_1.bitLen)(FP2_ORDER) / 8);
          this.isLE = Fp.isLE;
          this.ZERO = {
            c0: Fp.ZERO,
            c1: Fp.ZERO
          };
          this.ONE = {
            c0: Fp.ONE,
            c1: Fp.ZERO
          };
          this.Fp_NONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));
          this.Fp_div2 = Fp.div(Fp.ONE, _2n);
          this.NONRESIDUE = Fp2fromBigTuple(Fp, opts.FP2_NONRESIDUE);
          this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, this.Fp_NONRESIDUE, Fp.ORDER, 2)[0];
          this.mulByB = opts.Fp2mulByB;
          Object.seal(this);
        }

        var _proto64 = _Field2.prototype;

        _proto64.fromBigTuple = function fromBigTuple(tuple) {
          return Fp2fromBigTuple(this.Fp, tuple);
        };

        _proto64.create = function create(num) {
          return num;
        };

        _proto64.isValid = function isValid(_ref44) {
          var c0 = _ref44.c0,
              c1 = _ref44.c1;

          function isValidC(num, ORDER) {
            return typeof num === "bigint" && _0n <= num && num < ORDER;
          }

          return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);
        };

        _proto64.is0 = function is0(_ref45) {
          var c0 = _ref45.c0,
              c1 = _ref45.c1;
          return this.Fp.is0(c0) && this.Fp.is0(c1);
        };

        _proto64.isValidNot0 = function isValidNot0(num) {
          return !this.is0(num) && this.isValid(num);
        };

        _proto64.eql = function eql(_ref46, _ref47) {
          var c0 = _ref46.c0,
              c1 = _ref46.c1;
          var r0 = _ref47.c0,
              r1 = _ref47.c1;
          return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);
        };

        _proto64.neg = function neg(_ref48) {
          var c0 = _ref48.c0,
              c1 = _ref48.c1;
          return {
            c0: this.Fp.neg(c0),
            c1: this.Fp.neg(c1)
          };
        };

        _proto64.pow = function pow(num, power) {
          return mod.FpPow(this, num, power);
        };

        _proto64.invertBatch = function invertBatch(nums) {
          return mod.FpInvertBatch(this, nums);
        } // Normalized
        ;

        _proto64.add = function add(f1, f2) {
          var c0 = f1.c0,
              c1 = f1.c1;
          var r0 = f2.c0,
              r1 = f2.c1;
          return {
            c0: this.Fp.add(c0, r0),
            c1: this.Fp.add(c1, r1)
          };
        };

        _proto64.sub = function sub(_ref49, _ref50) {
          var c0 = _ref49.c0,
              c1 = _ref49.c1;
          var r0 = _ref50.c0,
              r1 = _ref50.c1;
          return {
            c0: this.Fp.sub(c0, r0),
            c1: this.Fp.sub(c1, r1)
          };
        };

        _proto64.mul = function mul(_ref51, rhs) {
          var c0 = _ref51.c0,
              c1 = _ref51.c1;
          var Fp = this.Fp;
          if (typeof rhs === "bigint") return {
            c0: Fp.mul(c0, rhs),
            c1: Fp.mul(c1, rhs)
          };
          var r0 = rhs.c0,
              r1 = rhs.c1;
          var t1 = Fp.mul(c0, r0);
          var t2 = Fp.mul(c1, r1);
          var o0 = Fp.sub(t1, t2);
          var o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));
          return {
            c0: o0,
            c1: o1
          };
        };

        _proto64.sqr = function sqr(_ref52) {
          var c0 = _ref52.c0,
              c1 = _ref52.c1;
          var Fp = this.Fp;
          var a = Fp.add(c0, c1);
          var b = Fp.sub(c0, c1);
          var c = Fp.add(c0, c0);
          return {
            c0: Fp.mul(a, b),
            c1: Fp.mul(c, c1)
          };
        } // NonNormalized stuff
        ;

        _proto64.addN = function addN(a, b) {
          return this.add(a, b);
        };

        _proto64.subN = function subN(a, b) {
          return this.sub(a, b);
        };

        _proto64.mulN = function mulN(a, b) {
          return this.mul(a, b);
        };

        _proto64.sqrN = function sqrN(a) {
          return this.sqr(a);
        } // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
        ;

        _proto64.div = function div(lhs, rhs) {
          var Fp = this.Fp;
          return this.mul(lhs, typeof rhs === "bigint" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));
        };

        _proto64.inv = function inv(_ref53) {
          var a = _ref53.c0,
              b = _ref53.c1;
          var Fp = this.Fp;
          var factor = Fp.inv(Fp.create(a * a + b * b));
          return {
            c0: Fp.mul(factor, Fp.create(a)),
            c1: Fp.mul(factor, Fp.create(-b))
          };
        };

        _proto64.sqrt = function sqrt(num) {
          var Fp = this.Fp;
          var Fp2 = this;
          var c0 = num.c0,
              c1 = num.c1;

          if (Fp.is0(c1)) {
            if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({
              c0: Fp.sqrt(c0),
              c1: Fp.ZERO
            });else return Fp2.create({
              c0: Fp.ZERO,
              c1: Fp.sqrt(Fp.div(c0, this.Fp_NONRESIDUE))
            });
          }

          var a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), this.Fp_NONRESIDUE)));
          var d = Fp.mul(Fp.add(a, c0), this.Fp_div2);
          var legendre = mod.FpLegendre(Fp, d);
          if (legendre === -1) d = Fp.sub(d, a);
          var a0 = Fp.sqrt(d);
          var candidateSqrt = Fp2.create({
            c0: a0,
            c1: Fp.div(Fp.mul(c1, this.Fp_div2), a0)
          });
          if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error("Cannot find square root");
          var x1 = candidateSqrt;
          var x2 = Fp2.neg(x1);

          var _Fp2$reim = Fp2.reim(x1),
              re1 = _Fp2$reim.re,
              im1 = _Fp2$reim.im;

          var _Fp2$reim2 = Fp2.reim(x2),
              re2 = _Fp2$reim2.re,
              im2 = _Fp2$reim2.im;

          if (im1 > im2 || im1 === im2 && re1 > re2) return x1;
          return x2;
        } // Same as sgn0_m_eq_2 in RFC 9380
        ;

        _proto64.isOdd = function isOdd(x) {
          var _this$reim = this.reim(x),
              x0 = _this$reim.re,
              x1 = _this$reim.im;

          var sign_0 = x0 % _2n;
          var zero_0 = x0 === _0n;
          var sign_1 = x1 % _2n;
          return BigInt(sign_0 || zero_0 && sign_1) == _1n;
        } // Bytes util
        ;

        _proto64.fromBytes = function fromBytes(b) {
          var Fp = this.Fp;
          if (b.length !== this.BYTES) throw new Error("fromBytes invalid length=" + b.length);
          return {
            c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)),
            c1: Fp.fromBytes(b.subarray(Fp.BYTES))
          };
        };

        _proto64.toBytes = function toBytes(_ref54) {
          var c0 = _ref54.c0,
              c1 = _ref54.c1;
          return (0, utils_ts_1.concatBytes)(this.Fp.toBytes(c0), this.Fp.toBytes(c1));
        };

        _proto64.cmov = function cmov(_ref55, _ref56, c) {
          var c0 = _ref55.c0,
              c1 = _ref55.c1;
          var r0 = _ref56.c0,
              r1 = _ref56.c1;
          return {
            c0: this.Fp.cmov(c0, r0, c),
            c1: this.Fp.cmov(c1, r1, c)
          };
        };

        _proto64.reim = function reim(_ref57) {
          var c0 = _ref57.c0,
              c1 = _ref57.c1;
          return {
            re: c0,
            im: c1
          };
        };

        _proto64.Fp4Square = function Fp4Square(a, b) {
          var Fp2 = this;
          var a2 = Fp2.sqr(a);
          var b2 = Fp2.sqr(b);
          return {
            first: Fp2.add(Fp2.mulByNonresidue(b2), a2),
            // b * Nonresidue + a
            second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2) // (a + b) - a - b

          };
        } // multiply by u + 1
        ;

        _proto64.mulByNonresidue = function mulByNonresidue(_ref58) {
          var c0 = _ref58.c0,
              c1 = _ref58.c1;
          return this.mul({
            c0: c0,
            c1: c1
          }, this.NONRESIDUE);
        };

        _proto64.frobeniusMap = function frobeniusMap(_ref59, power) {
          var c0 = _ref59.c0,
              c1 = _ref59.c1;
          return {
            c0: c0,
            c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2])
          };
        };

        return _Field2;
      }();

      var _Field6 = /*#__PURE__*/function () {
        function _Field6(Fp2) {
          this.MASK = _1n;
          this.Fp2 = Fp2;
          this.ORDER = Fp2.ORDER;
          this.BITS = 3 * Fp2.BITS;
          this.BYTES = 3 * Fp2.BYTES;
          this.isLE = Fp2.isLE;
          this.ZERO = {
            c0: Fp2.ZERO,
            c1: Fp2.ZERO,
            c2: Fp2.ZERO
          };
          this.ONE = {
            c0: Fp2.ONE,
            c1: Fp2.ZERO,
            c2: Fp2.ZERO
          };
          var Fp = Fp2.Fp;
          var frob = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 6, 2, 3);
          this.FROBENIUS_COEFFICIENTS_1 = frob[0];
          this.FROBENIUS_COEFFICIENTS_2 = frob[1];
          Object.seal(this);
        }

        var _proto65 = _Field6.prototype;

        _proto65.add = function add(_ref60, _ref61) {
          var c0 = _ref60.c0,
              c1 = _ref60.c1,
              c2 = _ref60.c2;
          var r0 = _ref61.c0,
              r1 = _ref61.c1,
              r2 = _ref61.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.add(c0, r0),
            c1: Fp2.add(c1, r1),
            c2: Fp2.add(c2, r2)
          };
        };

        _proto65.sub = function sub(_ref62, _ref63) {
          var c0 = _ref62.c0,
              c1 = _ref62.c1,
              c2 = _ref62.c2;
          var r0 = _ref63.c0,
              r1 = _ref63.c1,
              r2 = _ref63.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.sub(c0, r0),
            c1: Fp2.sub(c1, r1),
            c2: Fp2.sub(c2, r2)
          };
        };

        _proto65.mul = function mul(_ref64, rhs) {
          var c0 = _ref64.c0,
              c1 = _ref64.c1,
              c2 = _ref64.c2;
          var Fp2 = this.Fp2;

          if (typeof rhs === "bigint") {
            return {
              c0: Fp2.mul(c0, rhs),
              c1: Fp2.mul(c1, rhs),
              c2: Fp2.mul(c2, rhs)
            };
          }

          var r0 = rhs.c0,
              r1 = rhs.c1,
              r2 = rhs.c2;
          var t0 = Fp2.mul(c0, r0);
          var t1 = Fp2.mul(c1, r1);
          var t2 = Fp2.mul(c2, r2);
          return {
            // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
            c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),
            // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
            c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),
            // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
            c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2))
          };
        };

        _proto65.sqr = function sqr(_ref65) {
          var c0 = _ref65.c0,
              c1 = _ref65.c1,
              c2 = _ref65.c2;
          var Fp2 = this.Fp2;
          var t0 = Fp2.sqr(c0);
          var t1 = Fp2.mul(Fp2.mul(c0, c1), _2n);
          var t3 = Fp2.mul(Fp2.mul(c1, c2), _2n);
          var t4 = Fp2.sqr(c2);
          return {
            c0: Fp2.add(Fp2.mulByNonresidue(t3), t0),
            // T3 * (u + 1) + T0
            c1: Fp2.add(Fp2.mulByNonresidue(t4), t1),
            // T4 * (u + 1) + T1
            // T1 + (c0 - c1 + c2) + T3 - T0 - T4
            c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4)
          };
        };

        _proto65.addN = function addN(a, b) {
          return this.add(a, b);
        };

        _proto65.subN = function subN(a, b) {
          return this.sub(a, b);
        };

        _proto65.mulN = function mulN(a, b) {
          return this.mul(a, b);
        };

        _proto65.sqrN = function sqrN(a) {
          return this.sqr(a);
        };

        _proto65.create = function create(num) {
          return num;
        };

        _proto65.isValid = function isValid(_ref66) {
          var c0 = _ref66.c0,
              c1 = _ref66.c1,
              c2 = _ref66.c2;
          var Fp2 = this.Fp2;
          return Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2);
        };

        _proto65.is0 = function is0(_ref67) {
          var c0 = _ref67.c0,
              c1 = _ref67.c1,
              c2 = _ref67.c2;
          var Fp2 = this.Fp2;
          return Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2);
        };

        _proto65.isValidNot0 = function isValidNot0(num) {
          return !this.is0(num) && this.isValid(num);
        };

        _proto65.neg = function neg(_ref68) {
          var c0 = _ref68.c0,
              c1 = _ref68.c1,
              c2 = _ref68.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.neg(c0),
            c1: Fp2.neg(c1),
            c2: Fp2.neg(c2)
          };
        };

        _proto65.eql = function eql(_ref69, _ref70) {
          var c0 = _ref69.c0,
              c1 = _ref69.c1,
              c2 = _ref69.c2;
          var r0 = _ref70.c0,
              r1 = _ref70.c1,
              r2 = _ref70.c2;
          var Fp2 = this.Fp2;
          return Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2);
        };

        _proto65.sqrt = function sqrt(_) {
          return (0, utils_ts_1.notImplemented)();
        } // Do we need division by bigint at all? Should be done via order:
        ;

        _proto65.div = function div(lhs, rhs) {
          var Fp2 = this.Fp2;
          var Fp = Fp2.Fp;
          return this.mul(lhs, typeof rhs === "bigint" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));
        };

        _proto65.pow = function pow(num, power) {
          return mod.FpPow(this, num, power);
        };

        _proto65.invertBatch = function invertBatch(nums) {
          return mod.FpInvertBatch(this, nums);
        };

        _proto65.inv = function inv(_ref71) {
          var c0 = _ref71.c0,
              c1 = _ref71.c1,
              c2 = _ref71.c2;
          var Fp2 = this.Fp2;
          var t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1)));
          var t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1));
          var t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2));
          var t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));
          return {
            c0: Fp2.mul(t4, t0),
            c1: Fp2.mul(t4, t1),
            c2: Fp2.mul(t4, t2)
          };
        } // Bytes utils
        ;

        _proto65.fromBytes = function fromBytes(b) {
          var Fp2 = this.Fp2;
          if (b.length !== this.BYTES) throw new Error("fromBytes invalid length=" + b.length);
          var B2 = Fp2.BYTES;
          return {
            c0: Fp2.fromBytes(b.subarray(0, B2)),
            c1: Fp2.fromBytes(b.subarray(B2, B2 * 2)),
            c2: Fp2.fromBytes(b.subarray(2 * B2))
          };
        };

        _proto65.toBytes = function toBytes(_ref72) {
          var c0 = _ref72.c0,
              c1 = _ref72.c1,
              c2 = _ref72.c2;
          var Fp2 = this.Fp2;
          return (0, utils_ts_1.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2));
        };

        _proto65.cmov = function cmov(_ref73, _ref74, c) {
          var c0 = _ref73.c0,
              c1 = _ref73.c1,
              c2 = _ref73.c2;
          var r0 = _ref74.c0,
              r1 = _ref74.c1,
              r2 = _ref74.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.cmov(c0, r0, c),
            c1: Fp2.cmov(c1, r1, c),
            c2: Fp2.cmov(c2, r2, c)
          };
        };

        _proto65.fromBigSix = function fromBigSix(t) {
          var Fp2 = this.Fp2;
          if (!Array.isArray(t) || t.length !== 6) throw new Error("invalid Fp6 usage");
          return {
            c0: Fp2.fromBigTuple(t.slice(0, 2)),
            c1: Fp2.fromBigTuple(t.slice(2, 4)),
            c2: Fp2.fromBigTuple(t.slice(4, 6))
          };
        };

        _proto65.frobeniusMap = function frobeniusMap(_ref75, power) {
          var c0 = _ref75.c0,
              c1 = _ref75.c1,
              c2 = _ref75.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.frobeniusMap(c0, power),
            c1: Fp2.mul(Fp2.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),
            c2: Fp2.mul(Fp2.frobeniusMap(c2, power), this.FROBENIUS_COEFFICIENTS_2[power % 6])
          };
        };

        _proto65.mulByFp2 = function mulByFp2(_ref76, rhs) {
          var c0 = _ref76.c0,
              c1 = _ref76.c1,
              c2 = _ref76.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.mul(c0, rhs),
            c1: Fp2.mul(c1, rhs),
            c2: Fp2.mul(c2, rhs)
          };
        };

        _proto65.mulByNonresidue = function mulByNonresidue(_ref77) {
          var c0 = _ref77.c0,
              c1 = _ref77.c1,
              c2 = _ref77.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.mulByNonresidue(c2),
            c1: c0,
            c2: c1
          };
        } // Sparse multiplication
        ;

        _proto65.mul1 = function mul1(_ref78, b1) {
          var c0 = _ref78.c0,
              c1 = _ref78.c1,
              c2 = _ref78.c2;
          var Fp2 = this.Fp2;
          return {
            c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),
            c1: Fp2.mul(c0, b1),
            c2: Fp2.mul(c1, b1)
          };
        } // Sparse multiplication
        ;

        _proto65.mul01 = function mul01(_ref79, b0, b1) {
          var c0 = _ref79.c0,
              c1 = _ref79.c1,
              c2 = _ref79.c2;
          var Fp2 = this.Fp2;
          var t0 = Fp2.mul(c0, b0);
          var t1 = Fp2.mul(c1, b1);
          return {
            // ((c1 + c2) * b1 - T1) * (u + 1) + T0
            c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),
            // (b0 + b1) * (c0 + c1) - T0 - T1
            c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),
            // (c0 + c2) * b0 - T0 + T1
            c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1)
          };
        };

        return _Field6;
      }();

      var _Field12 = /*#__PURE__*/function () {
        function _Field12(Fp6, opts) {
          this.MASK = _1n;
          var Fp2 = Fp6.Fp2;
          var Fp = Fp2.Fp;
          this.Fp6 = Fp6;
          this.ORDER = Fp2.ORDER;
          this.BITS = 2 * Fp6.BITS;
          this.BYTES = 2 * Fp6.BYTES;
          this.isLE = Fp6.isLE;
          this.ZERO = {
            c0: Fp6.ZERO,
            c1: Fp6.ZERO
          };
          this.ONE = {
            c0: Fp6.ONE,
            c1: Fp6.ZERO
          };
          this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 12, 1, 6)[0];
          this.X_LEN = opts.X_LEN;
          this.finalExponentiate = opts.Fp12finalExponentiate;
        }

        var _proto66 = _Field12.prototype;

        _proto66.create = function create(num) {
          return num;
        };

        _proto66.isValid = function isValid(_ref80) {
          var c0 = _ref80.c0,
              c1 = _ref80.c1;
          var Fp6 = this.Fp6;
          return Fp6.isValid(c0) && Fp6.isValid(c1);
        };

        _proto66.is0 = function is0(_ref81) {
          var c0 = _ref81.c0,
              c1 = _ref81.c1;
          var Fp6 = this.Fp6;
          return Fp6.is0(c0) && Fp6.is0(c1);
        };

        _proto66.isValidNot0 = function isValidNot0(num) {
          return !this.is0(num) && this.isValid(num);
        };

        _proto66.neg = function neg(_ref82) {
          var c0 = _ref82.c0,
              c1 = _ref82.c1;
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.neg(c0),
            c1: Fp6.neg(c1)
          };
        };

        _proto66.eql = function eql(_ref83, _ref84) {
          var c0 = _ref83.c0,
              c1 = _ref83.c1;
          var r0 = _ref84.c0,
              r1 = _ref84.c1;
          var Fp6 = this.Fp6;
          return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);
        };

        _proto66.sqrt = function sqrt(_) {
          (0, utils_ts_1.notImplemented)();
        };

        _proto66.inv = function inv(_ref85) {
          var c0 = _ref85.c0,
              c1 = _ref85.c1;
          var Fp6 = this.Fp6;
          var t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1))));
          return {
            c0: Fp6.mul(c0, t),
            c1: Fp6.neg(Fp6.mul(c1, t))
          };
        };

        _proto66.div = function div(lhs, rhs) {
          var Fp6 = this.Fp6;
          var Fp2 = Fp6.Fp2;
          var Fp = Fp2.Fp;
          return this.mul(lhs, typeof rhs === "bigint" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));
        };

        _proto66.pow = function pow(num, power) {
          return mod.FpPow(this, num, power);
        };

        _proto66.invertBatch = function invertBatch(nums) {
          return mod.FpInvertBatch(this, nums);
        } // Normalized
        ;

        _proto66.add = function add(_ref86, _ref87) {
          var c0 = _ref86.c0,
              c1 = _ref86.c1;
          var r0 = _ref87.c0,
              r1 = _ref87.c1;
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.add(c0, r0),
            c1: Fp6.add(c1, r1)
          };
        };

        _proto66.sub = function sub(_ref88, _ref89) {
          var c0 = _ref88.c0,
              c1 = _ref88.c1;
          var r0 = _ref89.c0,
              r1 = _ref89.c1;
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.sub(c0, r0),
            c1: Fp6.sub(c1, r1)
          };
        };

        _proto66.mul = function mul(_ref90, rhs) {
          var c0 = _ref90.c0,
              c1 = _ref90.c1;
          var Fp6 = this.Fp6;
          if (typeof rhs === "bigint") return {
            c0: Fp6.mul(c0, rhs),
            c1: Fp6.mul(c1, rhs)
          };
          var r0 = rhs.c0,
              r1 = rhs.c1;
          var t1 = Fp6.mul(c0, r0);
          var t2 = Fp6.mul(c1, r1);
          return {
            c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),
            // T1 + T2 * v
            // (c0 + c1) * (r0 + r1) - (T1 + T2)
            c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))
          };
        };

        _proto66.sqr = function sqr(_ref91) {
          var c0 = _ref91.c0,
              c1 = _ref91.c1;
          var Fp6 = this.Fp6;
          var ab = Fp6.mul(c0, c1);
          return {
            // (c1 * v + c0) * (c0 + c1) - AB - AB * v
            c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),
            c1: Fp6.add(ab, ab)
          };
        } // NonNormalized stuff
        ;

        _proto66.addN = function addN(a, b) {
          return this.add(a, b);
        };

        _proto66.subN = function subN(a, b) {
          return this.sub(a, b);
        };

        _proto66.mulN = function mulN(a, b) {
          return this.mul(a, b);
        };

        _proto66.sqrN = function sqrN(a) {
          return this.sqr(a);
        } // Bytes utils
        ;

        _proto66.fromBytes = function fromBytes(b) {
          var Fp6 = this.Fp6;
          if (b.length !== this.BYTES) throw new Error("fromBytes invalid length=" + b.length);
          return {
            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),
            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))
          };
        };

        _proto66.toBytes = function toBytes(_ref92) {
          var c0 = _ref92.c0,
              c1 = _ref92.c1;
          var Fp6 = this.Fp6;
          return (0, utils_ts_1.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1));
        };

        _proto66.cmov = function cmov(_ref93, _ref94, c) {
          var c0 = _ref93.c0,
              c1 = _ref93.c1;
          var r0 = _ref94.c0,
              r1 = _ref94.c1;
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.cmov(c0, r0, c),
            c1: Fp6.cmov(c1, r1, c)
          };
        } // Utils
        // toString() {
        //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
        // },
        // fromTuple(c: [Fp6, Fp6]) {
        //   return new Fp12(...c);
        // }
        ;

        _proto66.fromBigTwelve = function fromBigTwelve(t) {
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.fromBigSix(t.slice(0, 6)),
            c1: Fp6.fromBigSix(t.slice(6, 12))
          };
        } // Raises to q**i -th power
        ;

        _proto66.frobeniusMap = function frobeniusMap(lhs, power) {
          var Fp6 = this.Fp6;
          var Fp2 = Fp6.Fp2;

          var _Fp6$frobeniusMap = Fp6.frobeniusMap(lhs.c1, power),
              c0 = _Fp6$frobeniusMap.c0,
              c1 = _Fp6$frobeniusMap.c1,
              c2 = _Fp6$frobeniusMap.c2;

          var coeff = this.FROBENIUS_COEFFICIENTS[power % 12];
          return {
            c0: Fp6.frobeniusMap(lhs.c0, power),
            c1: Fp6.create({
              c0: Fp2.mul(c0, coeff),
              c1: Fp2.mul(c1, coeff),
              c2: Fp2.mul(c2, coeff)
            })
          };
        };

        _proto66.mulByFp2 = function mulByFp2(_ref95, rhs) {
          var c0 = _ref95.c0,
              c1 = _ref95.c1;
          var Fp6 = this.Fp6;
          return {
            c0: Fp6.mulByFp2(c0, rhs),
            c1: Fp6.mulByFp2(c1, rhs)
          };
        };

        _proto66.conjugate = function conjugate(_ref96) {
          var c0 = _ref96.c0,
              c1 = _ref96.c1;
          return {
            c0: c0,
            c1: this.Fp6.neg(c1)
          };
        } // Sparse multiplication
        ;

        _proto66.mul014 = function mul014(_ref97, o0, o1, o4) {
          var c0 = _ref97.c0,
              c1 = _ref97.c1;
          var Fp6 = this.Fp6;
          var Fp2 = Fp6.Fp2;
          var t0 = Fp6.mul01(c0, o0, o1);
          var t1 = Fp6.mul1(c1, o4);
          return {
            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),
            // T1 * v + T0
            // (c1 + c0) * [o0, o1+o4] - T0 - T1
            c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1)
          };
        };

        _proto66.mul034 = function mul034(_ref98, o0, o3, o4) {
          var c0 = _ref98.c0,
              c1 = _ref98.c1;
          var Fp6 = this.Fp6;
          var Fp2 = Fp6.Fp2;
          var a = Fp6.create({
            c0: Fp2.mul(c0.c0, o0),
            c1: Fp2.mul(c0.c1, o0),
            c2: Fp2.mul(c0.c2, o0)
          });
          var b = Fp6.mul01(c1, o3, o4);
          var e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);
          return {
            c0: Fp6.add(Fp6.mulByNonresidue(b), a),
            c1: Fp6.sub(e, Fp6.add(a, b))
          };
        } // A cyclotomic group is a subgroup of Fp^n defined by
        //   G(p) = {  Fp : ^(p) = 1}
        // The result of any pairing is in a cyclotomic subgroup
        // https://eprint.iacr.org/2009/565.pdf
        // https://eprint.iacr.org/2010/354.pdf
        ;

        _proto66._cyclotomicSquare = function _cyclotomicSquare(_ref99) {
          var c0 = _ref99.c0,
              c1 = _ref99.c1;
          var Fp6 = this.Fp6;
          var Fp2 = Fp6.Fp2;
          var c0c0 = c0.c0,
              c0c1 = c0.c1,
              c0c2 = c0.c2;
          var c1c0 = c1.c0,
              c1c1 = c1.c1,
              c1c2 = c1.c2;

          var _Fp2$Fp4Square = Fp2.Fp4Square(c0c0, c1c1),
              t3 = _Fp2$Fp4Square.first,
              t4 = _Fp2$Fp4Square.second;

          var _Fp2$Fp4Square2 = Fp2.Fp4Square(c1c0, c0c2),
              t5 = _Fp2$Fp4Square2.first,
              t6 = _Fp2$Fp4Square2.second;

          var _Fp2$Fp4Square3 = Fp2.Fp4Square(c0c1, c1c2),
              t7 = _Fp2$Fp4Square3.first,
              t8 = _Fp2$Fp4Square3.second;

          var t9 = Fp2.mulByNonresidue(t8);
          return {
            c0: Fp6.create({
              c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3),
              // 2 * (T3 - c0c0)  + T3
              c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5),
              // 2 * (T5 - c0c1)  + T5
              c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7)
            }),
            // 2 * (T7 - c0c2)  + T7
            c1: Fp6.create({
              c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9),
              // 2 * (T9 + c1c0) + T9
              c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4),
              // 2 * (T4 + c1c1) + T4
              c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6)
            })
          };
        } // https://eprint.iacr.org/2009/565.pdf
        ;

        _proto66._cyclotomicExp = function _cyclotomicExp(num, n) {
          var z = this.ONE;

          for (var i = this.X_LEN - 1; i >= 0; i--) {
            z = this._cyclotomicSquare(z);
            if ((0, utils_ts_1.bitGet)(n, i)) z = this.mul(z, num);
          }

          return z;
        };

        return _Field12;
      }();

      function tower12(opts) {
        var Fp = mod.Field(opts.ORDER);
        var Fp2 = new _Field2(Fp, opts);
        var Fp6 = new _Field6(Fp2);
        var Fp12 = new _Field12(Fp6, opts);
        return {
          Fp: Fp,
          Fp2: Fp2,
          Fp6: Fp6,
          Fp12: Fp12
        };
      }
    }
  }); // node_modules/@noble/curves/bls12-381.js


  var require_bls12_381 = __commonJS({
    "node_modules/@noble/curves/bls12-381.js": function node_modulesNobleCurvesBls12381Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bls12_381 = exports.bls12_381_Fr = void 0;
      var sha2_js_1 = require_sha2();
      var bls_ts_1 = require_bls();
      var modular_ts_1 = require_modular();
      var utils_ts_1 = require_utils3();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var tower_ts_1 = require_tower();
      var weierstrass_ts_1 = require_weierstrass();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _3n = BigInt(3);

      var _4n = BigInt(4);

      var BLS_X = BigInt("0xd201000000010000");
      var BLS_X_LEN = (0, utils_ts_1.bitLen)(BLS_X);
      var bls12_381_CURVE_G1 = {
        p: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
        n: BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"),
        h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
        a: _0n,
        b: _4n,
        Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
        Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1")
      };
      exports.bls12_381_Fr = (0, modular_ts_1.Field)(bls12_381_CURVE_G1.n, {
        modFromBytes: true,
        isLE: true
      });

      var _ref100 = (0, tower_ts_1.tower12)({
        ORDER: bls12_381_CURVE_G1.p,
        X_LEN: BLS_X_LEN,
        // Finite extension field over irreducible polynominal.
        // Fp(u) / (u - ) where  = -1
        FP2_NONRESIDUE: [_1n, _1n],
        Fp2mulByB: function Fp2mulByB(_ref101) {
          var c0 = _ref101.c0,
              c1 = _ref101.c1;
          var t0 = Fp.mul(c0, _4n);
          var t1 = Fp.mul(c1, _4n);
          return {
            c0: Fp.sub(t0, t1),
            c1: Fp.add(t0, t1)
          };
        },
        Fp12finalExponentiate: function Fp12finalExponentiate(num) {
          var x = BLS_X;
          var t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
          var t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
          var t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));
          var t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);
          var t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));
          var t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));
          var t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));
          var t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));
          var t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);
          var t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
          var t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
          var t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
          return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
        }
      }),
          Fp = _ref100.Fp,
          Fp2 = _ref100.Fp2,
          Fp6 = _ref100.Fp6,
          Fp12 = _ref100.Fp12;

      var _ref102 = (0, tower_ts_1.psiFrobenius)(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)),
          G2psi = _ref102.G2psi,
          G2psi2 = _ref102.G2psi2;

      var htfDefaults = Object.freeze({
        DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
        encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
        p: Fp.ORDER,
        m: 2,
        k: 128,
        expand: "xmd",
        hash: sha2_js_1.sha256
      });
      var bls12_381_CURVE_G2 = {
        p: Fp2.ORDER,
        n: bls12_381_CURVE_G1.n,
        h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
        a: Fp2.ZERO,
        b: Fp2.fromBigTuple([_4n, _4n]),
        Gx: Fp2.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"), BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]),
        Gy: Fp2.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"), BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")])
      };
      var COMPZERO = setMask(Fp.toBytes(_0n), {
        infinity: true,
        compressed: true
      });

      function parseMask(bytes) {
        bytes = bytes.slice();
        var mask = bytes[0] & 224;
        var compressed = !!(mask >> 7 & 1);
        var infinity = !!(mask >> 6 & 1);
        var sort = !!(mask >> 5 & 1);
        bytes[0] &= 31;
        return {
          compressed: compressed,
          infinity: infinity,
          sort: sort,
          value: bytes
        };
      }

      function setMask(bytes, mask) {
        if (bytes[0] & 224) throw new Error("setMask: non-empty mask");
        if (mask.compressed) bytes[0] |= 128;
        if (mask.infinity) bytes[0] |= 64;
        if (mask.sort) bytes[0] |= 32;
        return bytes;
      }

      function pointG1ToBytes(_c, point, isComp) {
        var L = Fp.BYTES,
            P = Fp.ORDER;
        var is0 = point.is0();

        var _point$toAffine2 = point.toAffine(),
            x = _point$toAffine2.x,
            y = _point$toAffine2.y;

        if (isComp) {
          if (is0) return COMPZERO.slice();
          var sort = Boolean(y * _2n / P);
          return setMask((0, utils_ts_1.numberToBytesBE)(x, L), {
            compressed: true,
            sort: sort
          });
        } else {
          if (is0) {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(64), new Uint8Array(2 * L - 1));
          } else {
            return (0, utils_ts_1.concatBytes)((0, utils_ts_1.numberToBytesBE)(x, L), (0, utils_ts_1.numberToBytesBE)(y, L));
          }
        }
      }

      function signatureG1ToBytes(point) {
        point.assertValidity();
        var L = Fp.BYTES,
            P = Fp.ORDER;

        var _point$toAffine3 = point.toAffine(),
            x = _point$toAffine3.x,
            y = _point$toAffine3.y;

        if (point.is0()) return COMPZERO.slice();
        var sort = Boolean(y * _2n / P);
        return setMask((0, utils_ts_1.numberToBytesBE)(x, L), {
          compressed: true,
          sort: sort
        });
      }

      function pointG1FromBytes(bytes) {
        var _parseMask = parseMask(bytes),
            compressed = _parseMask.compressed,
            infinity = _parseMask.infinity,
            sort = _parseMask.sort,
            value = _parseMask.value;

        var L = Fp.BYTES,
            P = Fp.ORDER;

        if (value.length === 48 && compressed) {
          var compressedValue = (0, utils_ts_1.bytesToNumberBE)(value);
          var x = Fp.create(compressedValue & (0, utils_ts_1.bitMask)(Fp.BITS));

          if (infinity) {
            if (x !== _0n) throw new Error("invalid G1 point: non-empty, at infinity, with compression");
            return {
              x: _0n,
              y: _0n
            };
          }

          var right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b));
          var y = Fp.sqrt(right);
          if (!y) throw new Error("invalid G1 point: compressed point");
          if (y * _2n / P !== BigInt(sort)) y = Fp.neg(y);
          return {
            x: Fp.create(x),
            y: Fp.create(y)
          };
        } else if (value.length === 96 && !compressed) {
          var _x10 = (0, utils_ts_1.bytesToNumberBE)(value.subarray(0, L));

          var _y3 = (0, utils_ts_1.bytesToNumberBE)(value.subarray(L));

          if (infinity) {
            if (_x10 !== _0n || _y3 !== _0n) throw new Error("G1: non-empty point at infinity");
            return exports.bls12_381.G1.Point.ZERO.toAffine();
          }

          return {
            x: Fp.create(_x10),
            y: Fp.create(_y3)
          };
        } else {
          throw new Error("invalid G1 point: expected 48/96 bytes");
        }
      }

      function signatureG1FromBytes(hex) {
        var _parseMask2 = parseMask((0, utils_ts_1.ensureBytes)("signatureHex", hex, 48)),
            infinity = _parseMask2.infinity,
            sort = _parseMask2.sort,
            value = _parseMask2.value;

        var P = Fp.ORDER;
        var Point = exports.bls12_381.G1.Point;
        var compressedValue = (0, utils_ts_1.bytesToNumberBE)(value);
        if (infinity) return Point.ZERO;
        var x = Fp.create(compressedValue & (0, utils_ts_1.bitMask)(Fp.BITS));
        var right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b));
        var y = Fp.sqrt(right);
        if (!y) throw new Error("invalid G1 point: compressed");
        var aflag = BigInt(sort);
        if (y * _2n / P !== aflag) y = Fp.neg(y);
        var point = Point.fromAffine({
          x: x,
          y: y
        });
        point.assertValidity();
        return point;
      }

      function pointG2ToBytes(_c, point, isComp) {
        var L = Fp.BYTES,
            P = Fp.ORDER;
        var is0 = point.is0();

        var _point$toAffine4 = point.toAffine(),
            x = _point$toAffine4.x,
            y = _point$toAffine4.y;

        if (isComp) {
          if (is0) return (0, utils_ts_1.concatBytes)(COMPZERO, (0, utils_ts_1.numberToBytesBE)(_0n, L));
          var flag = Boolean(y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P);
          return (0, utils_ts_1.concatBytes)(setMask((0, utils_ts_1.numberToBytesBE)(x.c1, L), {
            compressed: true,
            sort: flag
          }), (0, utils_ts_1.numberToBytesBE)(x.c0, L));
        } else {
          if (is0) return (0, utils_ts_1.concatBytes)(Uint8Array.of(64), new Uint8Array(4 * L - 1));

          var _Fp2$reim3 = Fp2.reim(x),
              x0 = _Fp2$reim3.re,
              x1 = _Fp2$reim3.im;

          var _Fp2$reim4 = Fp2.reim(y),
              y0 = _Fp2$reim4.re,
              y1 = _Fp2$reim4.im;

          return (0, utils_ts_1.concatBytes)((0, utils_ts_1.numberToBytesBE)(x1, L), (0, utils_ts_1.numberToBytesBE)(x0, L), (0, utils_ts_1.numberToBytesBE)(y1, L), (0, utils_ts_1.numberToBytesBE)(y0, L));
        }
      }

      function signatureG2ToBytes(point) {
        point.assertValidity();
        var L = Fp.BYTES;
        if (point.is0()) return (0, utils_ts_1.concatBytes)(COMPZERO, (0, utils_ts_1.numberToBytesBE)(_0n, L));

        var _point$toAffine5 = point.toAffine(),
            x = _point$toAffine5.x,
            y = _point$toAffine5.y;

        var _Fp2$reim5 = Fp2.reim(x),
            x0 = _Fp2$reim5.re,
            x1 = _Fp2$reim5.im;

        var _Fp2$reim6 = Fp2.reim(y),
            y0 = _Fp2$reim6.re,
            y1 = _Fp2$reim6.im;

        var tmp = y1 > _0n ? y1 * _2n : y0 * _2n;
        var sort = Boolean(tmp / Fp.ORDER & _1n);
        var z2 = x0;
        return (0, utils_ts_1.concatBytes)(setMask((0, utils_ts_1.numberToBytesBE)(x1, L), {
          sort: sort,
          compressed: true
        }), (0, utils_ts_1.numberToBytesBE)(z2, L));
      }

      function pointG2FromBytes(bytes) {
        var L = Fp.BYTES,
            P = Fp.ORDER;

        var _parseMask3 = parseMask(bytes),
            compressed = _parseMask3.compressed,
            infinity = _parseMask3.infinity,
            sort = _parseMask3.sort,
            value = _parseMask3.value;

        if (!compressed && !infinity && sort || // 00100000
        !compressed && infinity && sort || // 01100000
        sort && infinity && compressed) {
          throw new Error("invalid encoding flag: " + (bytes[0] & 224));
        }

        var slc = function slc(b, from, to) {
          return (0, utils_ts_1.bytesToNumberBE)(b.slice(from, to));
        };

        if (value.length === 96 && compressed) {
          if (infinity) {
            if (value.reduce(function (p, c) {
              return p !== 0 ? c + 1 : c;
            }, 0) > 0) {
              throw new Error("invalid G2 point: compressed");
            }

            return {
              x: Fp2.ZERO,
              y: Fp2.ZERO
            };
          }

          var x_1 = slc(value, 0, L);
          var x_0 = slc(value, L, 2 * L);
          var x = Fp2.create({
            c0: Fp.create(x_0),
            c1: Fp.create(x_1)
          });
          var right = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b);
          var y = Fp2.sqrt(right);
          var Y_bit = y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P ? _1n : _0n;
          y = sort && Y_bit > 0 ? y : Fp2.neg(y);
          return {
            x: x,
            y: y
          };
        } else if (value.length === 192 && !compressed) {
          if (infinity) {
            if (value.reduce(function (p, c) {
              return p !== 0 ? c + 1 : c;
            }, 0) > 0) {
              throw new Error("invalid G2 point: uncompressed");
            }

            return {
              x: Fp2.ZERO,
              y: Fp2.ZERO
            };
          }

          var x1 = slc(value, 0 * L, 1 * L);
          var x0 = slc(value, 1 * L, 2 * L);
          var y1 = slc(value, 2 * L, 3 * L);
          var y0 = slc(value, 3 * L, 4 * L);
          return {
            x: Fp2.fromBigTuple([x0, x1]),
            y: Fp2.fromBigTuple([y0, y1])
          };
        } else {
          throw new Error("invalid G2 point: expected 96/192 bytes");
        }
      }

      function signatureG2FromBytes(hex) {
        var P = Fp.ORDER;

        var _parseMask4 = parseMask((0, utils_ts_1.ensureBytes)("signatureHex", hex)),
            infinity = _parseMask4.infinity,
            sort = _parseMask4.sort,
            value = _parseMask4.value;

        var Point = exports.bls12_381.G2.Point;
        var half = value.length / 2;
        if (half !== 48 && half !== 96) throw new Error("invalid compressed signature length, expected 96/192 bytes");
        var z1 = (0, utils_ts_1.bytesToNumberBE)(value.slice(0, half));
        var z2 = (0, utils_ts_1.bytesToNumberBE)(value.slice(half));
        if (infinity) return Point.ZERO;
        var x1 = Fp.create(z1 & (0, utils_ts_1.bitMask)(Fp.BITS));
        var x2 = Fp.create(z2);
        var x = Fp2.create({
          c0: x2,
          c1: x1
        });
        var y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b);
        var y = Fp2.sqrt(y2);
        if (!y) throw new Error("Failed to find a square root");

        var _Fp2$reim7 = Fp2.reim(y),
            y0 = _Fp2$reim7.re,
            y1 = _Fp2$reim7.im;

        var aflag1 = BigInt(sort);
        var isGreater = y1 > _0n && y1 * _2n / P !== aflag1;
        var is0 = y1 === _0n && y0 * _2n / P !== aflag1;
        if (isGreater || is0) y = Fp2.neg(y);
        var point = Point.fromAffine({
          x: x,
          y: y
        });
        point.assertValidity();
        return point;
      }

      exports.bls12_381 = (0, bls_ts_1.bls)({
        // Fields
        fields: {
          Fp: Fp,
          Fp2: Fp2,
          Fp6: Fp6,
          Fp12: Fp12,
          Fr: exports.bls12_381_Fr
        },
        // G1: y = x + 4
        G1: _extends({}, bls12_381_CURVE_G1, {
          Fp: Fp,
          htfDefaults: _extends({}, htfDefaults, {
            m: 1,
            DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"
          }),
          wrapPrivateKey: true,
          allowInfinityPoint: true,
          // Checks is the point resides in prime-order subgroup.
          // point.isTorsionFree() should return true for valid points
          // It returns false for shitty points.
          // https://eprint.iacr.org/2021/1130.pdf
          isTorsionFree: function isTorsionFree(c, point) {
            var beta = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
            var phi = new c(Fp.mul(point.X, beta), point.Y, point.Z);
            var xP = point.multiplyUnsafe(BLS_X).negate();
            var u2P = xP.multiplyUnsafe(BLS_X);
            return u2P.equals(phi);
          },
          // Clear cofactor of G1
          // https://eprint.iacr.org/2019/403
          clearCofactor: function clearCofactor(_c, point) {
            return point.multiplyUnsafe(BLS_X).add(point);
          },
          mapToCurve: mapToG1,
          fromBytes: pointG1FromBytes,
          toBytes: pointG1ToBytes,
          ShortSignature: {
            fromBytes: function fromBytes(bytes) {
              (0, utils_ts_1.abytes)(bytes);
              return signatureG1FromBytes(bytes);
            },
            fromHex: function fromHex(hex) {
              return signatureG1FromBytes(hex);
            },
            toBytes: function toBytes(point) {
              return signatureG1ToBytes(point);
            },
            toRawBytes: function toRawBytes(point) {
              return signatureG1ToBytes(point);
            },
            toHex: function toHex(point) {
              return (0, utils_ts_1.bytesToHex)(signatureG1ToBytes(point));
            }
          }
        }),
        G2: _extends({}, bls12_381_CURVE_G2, {
          Fp: Fp2,
          // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor
          // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12
          hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
          htfDefaults: _extends({}, htfDefaults),
          wrapPrivateKey: true,
          allowInfinityPoint: true,
          mapToCurve: mapToG2,
          // Checks is the point resides in prime-order subgroup.
          // point.isTorsionFree() should return true for valid points
          // It returns false for shitty points.
          // https://eprint.iacr.org/2021/1130.pdf
          // Older version: https://eprint.iacr.org/2019/814.pdf
          isTorsionFree: function isTorsionFree(c, P) {
            return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P));
          },
          // Maps the point into the prime-order subgroup G2.
          // clear_cofactor_bls12381_g2 from RFC 9380.
          // https://eprint.iacr.org/2017/419.pdf
          // prettier-ignore
          clearCofactor: function clearCofactor(c, P) {
            var x = BLS_X;
            var t1 = P.multiplyUnsafe(x).negate();
            var t2 = G2psi(c, P);
            var t3 = P["double"]();
            t3 = G2psi2(c, t3);
            t3 = t3.subtract(t2);
            t2 = t1.add(t2);
            t2 = t2.multiplyUnsafe(x).negate();
            t3 = t3.add(t2);
            t3 = t3.subtract(t1);
            var Q = t3.subtract(P);
            return Q;
          },
          fromBytes: pointG2FromBytes,
          toBytes: pointG2ToBytes,
          Signature: {
            fromBytes: function fromBytes(bytes) {
              (0, utils_ts_1.abytes)(bytes);
              return signatureG2FromBytes(bytes);
            },
            fromHex: function fromHex(hex) {
              return signatureG2FromBytes(hex);
            },
            toBytes: function toBytes(point) {
              return signatureG2ToBytes(point);
            },
            toRawBytes: function toRawBytes(point) {
              return signatureG2ToBytes(point);
            },
            toHex: function toHex(point) {
              return (0, utils_ts_1.bytesToHex)(signatureG2ToBytes(point));
            }
          }
        }),
        params: {
          ateLoopSize: BLS_X,
          // The BLS parameter x for BLS12-381
          r: bls12_381_CURVE_G1.n,
          // order; z  z + 1; CURVE.n from other curves
          xNegative: true,
          twistType: "multiplicative"
        },
        htfDefaults: htfDefaults,
        hash: sha2_js_1.sha256
      });
      var isogenyMapG2 = (0, hash_to_curve_ts_1.isogenyMap)(Fp2, [// xNum
      [["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6", "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"], ["0x0", "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"], ["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e", "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"], ["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1", "0x0"]], // xDen
      [["0x0", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"], ["0xc", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"], ["0x1", "0x0"] // LAST 1
      ], // yNum
      [["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706", "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"], ["0x0", "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"], ["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c", "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"], ["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10", "0x0"]], // yDen
      [["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"], ["0x0", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"], ["0x12", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"], ["0x1", "0x0"] // LAST 1
      ]].map(function (i) {
        return i.map(function (pair) {
          return Fp2.fromBigTuple(pair.map(BigInt));
        });
      }));
      var isogenyMapG1 = (0, hash_to_curve_ts_1.isogenyMap)(Fp, [// xNum
      ["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7", "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb", "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0", "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861", "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9", "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983", "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84", "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e", "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317", "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e", "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b", "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"], // xDen
      ["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c", "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff", "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19", "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8", "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e", "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5", "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a", "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e", "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641", "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a", "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001" // LAST 1
      ], // yNum
      ["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33", "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696", "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6", "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb", "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb", "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0", "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2", "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29", "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587", "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30", "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132", "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e", "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8", "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133", "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b", "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"], // yDen
      ["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1", "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d", "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2", "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416", "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d", "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac", "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c", "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9", "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a", "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55", "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8", "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092", "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc", "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7", "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f", "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001" // LAST 1
      ]].map(function (i) {
        return i.map(function (j) {
          return BigInt(j);
        });
      }));
      var G1_SWU = (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fp, {
        A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
        B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
        Z: Fp.create(BigInt(11))
      });
      var G2_SWU = (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fp2, {
        A: Fp2.create({
          c0: Fp.create(_0n),
          c1: Fp.create(BigInt(240))
        }),
        // A' = 240 * I
        B: Fp2.create({
          c0: Fp.create(BigInt(1012)),
          c1: Fp.create(BigInt(1012))
        }),
        // B' = 1012 * (1 + I)
        Z: Fp2.create({
          c0: Fp.create(BigInt(-2)),
          c1: Fp.create(BigInt(-1))
        }) // Z: -(2 + I)

      });

      function mapToG1(scalars) {
        var _G1_SWU = G1_SWU(Fp.create(scalars[0])),
            x = _G1_SWU.x,
            y = _G1_SWU.y;

        return isogenyMapG1(x, y);
      }

      function mapToG2(scalars) {
        var _G2_SWU = G2_SWU(Fp2.fromBigTuple(scalars)),
            x = _G2_SWU.x,
            y = _G2_SWU.y;

        return isogenyMapG2(x, y);
      }
    }
  }); // node_modules/@dfinity/agent/lib/cjs/utils/bls.js


  var require_bls2 = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/utils/bls.js": function node_modulesDfinityAgentLibCjsUtilsBlsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.blsVerify = exports.verify = void 0;
      var bls12_381_1 = require_bls12_381();
      var buffer_1 = require_buffer2();

      function blsVerify(pk, sig, msg) {
        var primaryKey = typeof pk === "string" ? pk : (0, buffer_1.toHex)(pk);
        var signature = typeof sig === "string" ? sig : (0, buffer_1.toHex)(sig);
        var message = typeof msg === "string" ? msg : (0, buffer_1.toHex)(msg);
        return bls12_381_1.bls12_381.verifyShortSignature(signature, message, primaryKey);
      }

      exports.blsVerify = blsVerify;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/utils/leb.js


  var require_leb = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/utils/leb.js": function node_modulesDfinityAgentLibCjsUtilsLebJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decodeTime = exports.decodeLeb128 = void 0;
      var candid_1 = require_cjs2();

      var decodeLeb128 = function decodeLeb128(buf) {
        return (0, candid_1.lebDecode)(new candid_1.PipeArrayBuffer(buf));
      };

      exports.decodeLeb128 = decodeLeb128;

      var decodeTime = function decodeTime(buf) {
        var decoded = (0, exports.decodeLeb128)(buf);
        return new Date(Number(decoded) / 1e6);
      };

      exports.decodeTime = decodeTime;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/certificate.js


  var require_certificate = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/certificate.js": function node_modulesDfinityAgentLibCjsCertificateJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _Certificate_disableTimeVerification;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.check_canister_ranges = exports.find_label = exports.flatten_forks = exports.lookup_path = exports.LookupStatus = exports.reconstruct = exports.lookupResultToBuffer = exports.Certificate = exports.hashTreeToString = exports.NodeType = exports.CertificateVerificationError = void 0;

      var cbor = __importStar(require_cbor());

      var errors_1 = require_errors();
      var request_id_1 = require_request_id();
      var buffer_1 = require_buffer2();
      var principal_1 = require_cjs();

      var bls = __importStar(require_bls2());

      var leb_1 = require_leb();
      var agent_1 = require_agent();

      var CertificateVerificationError = /*#__PURE__*/function (_errors_1$AgentError5) {
        _inheritsLoose(CertificateVerificationError, _errors_1$AgentError5);

        function CertificateVerificationError(reason) {
          return _errors_1$AgentError5.call(this, "Invalid certificate: " + reason) || this;
        }

        return CertificateVerificationError;
      }(errors_1.AgentError);

      exports.CertificateVerificationError = CertificateVerificationError;
      var NodeType;

      (function (NodeType2) {
        NodeType2[NodeType2["Empty"] = 0] = "Empty";
        NodeType2[NodeType2["Fork"] = 1] = "Fork";
        NodeType2[NodeType2["Labeled"] = 2] = "Labeled";
        NodeType2[NodeType2["Leaf"] = 3] = "Leaf";
        NodeType2[NodeType2["Pruned"] = 4] = "Pruned";
      })(NodeType = exports.NodeType || (exports.NodeType = {}));

      function hashTreeToString(tree) {
        var indent = function indent(s) {
          return s.split("\n").map(function (x) {
            return "  " + x;
          }).join("\n");
        };

        function labelToString(label) {
          var decoder = new TextDecoder(void 0, {
            fatal: true
          });

          try {
            return JSON.stringify(decoder.decode(label));
          } catch (e) {
            return "data(..." + label.byteLength + " bytes)";
          }
        }

        switch (tree[0]) {
          case NodeType.Empty:
            return "()";

          case NodeType.Fork:
            {
              if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {
                var left = hashTreeToString(tree[1]);
                var right = hashTreeToString(tree[2]);
                return "sub(\n left:\n" + indent(left) + "\n---\n right:\n" + indent(right) + "\n)";
              } else {
                throw new Error("Invalid tree structure for fork");
              }
            }

          case NodeType.Labeled:
            {
              if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {
                var label = labelToString(tree[1]);
                var sub = hashTreeToString(tree[2]);
                return "label(\n label:\n" + indent(label) + "\n sub:\n" + indent(sub) + "\n)";
              } else {
                throw new Error("Invalid tree structure for labeled");
              }
            }

          case NodeType.Leaf:
            {
              if (!tree[1]) {
                throw new Error("Invalid tree structure for leaf");
              } else if (Array.isArray(tree[1])) {
                return JSON.stringify(tree[1]);
              }

              return "leaf(..." + tree[1].byteLength + " bytes)";
            }

          case NodeType.Pruned:
            {
              if (!tree[1]) {
                throw new Error("Invalid tree structure for pruned");
              } else if (Array.isArray(tree[1])) {
                return JSON.stringify(tree[1]);
              }

              return "pruned(" + (0, buffer_1.toHex)(new Uint8Array(tree[1]));
            }

          default:
            {
              return "unknown(" + JSON.stringify(tree[0]) + ")";
            }
        }
      }

      exports.hashTreeToString = hashTreeToString;

      function isBufferGreaterThan(a, b) {
        var a8 = new Uint8Array(a);
        var b8 = new Uint8Array(b);

        for (var i = 0; i < a8.length; i++) {
          if (a8[i] > b8[i]) {
            return true;
          }
        }

        return false;
      }

      var Certificate = /*#__PURE__*/function () {
        function _Certificate(certificate, _rootKey, _canisterId, _blsVerify, _maxAgeInMinutes, disableTimeVerification) {
          if (_maxAgeInMinutes === void 0) {
            _maxAgeInMinutes = 5;
          }

          if (disableTimeVerification === void 0) {
            disableTimeVerification = false;
          }

          this._rootKey = _rootKey;
          this._canisterId = _canisterId;
          this._blsVerify = _blsVerify;
          this._maxAgeInMinutes = _maxAgeInMinutes;

          _Certificate_disableTimeVerification.set(this, false);

          __classPrivateFieldSet(this, _Certificate_disableTimeVerification, disableTimeVerification, "f");

          this.cert = cbor.decode(new Uint8Array(certificate));
        }
        /**
         * Create a new instance of a certificate, automatically verifying it. Throws a
         * CertificateVerificationError if the certificate cannot be verified.
         * @constructs  Certificate
         * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}
         * @param {ArrayBuffer} options.certificate The bytes of the certificate
         * @param {ArrayBuffer} options.rootKey The root key to verify against
         * @param {Principal} options.canisterId The effective or signing canister ID
         * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.
         * @throws {CertificateVerificationError}
         */


        _Certificate.create =
        /*#__PURE__*/
        function () {
          var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {
            var cert;
            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    cert = _Certificate.createUnverified(options);
                    _context7.next = 3;
                    return cert.verify();

                  case 3:
                    return _context7.abrupt("return", cert);

                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));

          function create(_x11) {
            return _create.apply(this, arguments);
          }

          return create;
        }();

        _Certificate.createUnverified = function createUnverified(options) {
          var blsVerify = options.blsVerify;

          if (!blsVerify) {
            blsVerify = bls.blsVerify;
          }

          return new _Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes, options.disableTimeVerification);
        };

        var _proto67 = _Certificate.prototype;

        _proto67.lookup = function lookup(path) {
          return lookup_path(path, this.cert.tree);
        };

        _proto67.lookup_label = function lookup_label(label) {
          return this.lookup([label]);
        };

        _proto67.verify = /*#__PURE__*/function () {
          var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
            var rootHash, derKey, sig, key, msg, sigVer, lookupTime, FIVE_MINUTES_IN_MSEC, MAX_AGE_IN_MSEC, now, earliestCertificateTime, fiveMinutesFromNow, certTime;
            return _regeneratorRuntime().wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return reconstruct(this.cert.tree);

                  case 2:
                    rootHash = _context8.sent;
                    _context8.next = 5;
                    return this._checkDelegationAndGetKey(this.cert.delegation);

                  case 5:
                    derKey = _context8.sent;
                    sig = this.cert.signature;
                    key = extractDER(derKey);
                    msg = (0, buffer_1.concat)(domain_sep("ic-state-root"), rootHash);
                    sigVer = false;
                    lookupTime = lookupResultToBuffer(this.lookup(["time"]));

                    if (lookupTime) {
                      _context8.next = 13;
                      break;
                    }

                    throw new CertificateVerificationError("Certificate does not contain a time");

                  case 13:
                    if (__classPrivateFieldGet(this, _Certificate_disableTimeVerification, "f")) {
                      _context8.next = 26;
                      break;
                    }

                    FIVE_MINUTES_IN_MSEC = 5 * 60 * 1e3;
                    MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1e3;
                    now = Date.now();
                    earliestCertificateTime = now - MAX_AGE_IN_MSEC;
                    fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;
                    certTime = (0, leb_1.decodeTime)(lookupTime);

                    if (!(certTime.getTime() < earliestCertificateTime)) {
                      _context8.next = 24;
                      break;
                    }

                    throw new CertificateVerificationError("Certificate is signed more than " + this._maxAgeInMinutes + " minutes in the past. Certificate time: " + certTime.toISOString() + " Current time: " + new Date(now).toISOString());

                  case 24:
                    if (!(certTime.getTime() > fiveMinutesFromNow)) {
                      _context8.next = 26;
                      break;
                    }

                    throw new CertificateVerificationError("Certificate is signed more than 5 minutes in the future. Certificate time: " + certTime.toISOString() + " Current time: " + new Date(now).toISOString());

                  case 26:
                    _context8.prev = 26;
                    _context8.next = 29;
                    return this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));

                  case 29:
                    sigVer = _context8.sent;
                    _context8.next = 35;
                    break;

                  case 32:
                    _context8.prev = 32;
                    _context8.t0 = _context8["catch"](26);
                    sigVer = false;

                  case 35:
                    if (sigVer) {
                      _context8.next = 38;
                      break;
                    }

                    console.warn("Signature verification failed. Bypassing for local development/debugging.");
                    return _context8.abrupt("return");

                  case 38:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this, [[26, 32]]);
          }));

          function verify() {
            return _verify.apply(this, arguments);
          }

          return verify;
        }();

        _proto67._checkDelegationAndGetKey = /*#__PURE__*/function () {
          var _checkDelegationAndGetKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(d) {
            var cert, canisterInRange, publicKeyLookup;
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    if (d) {
                      _context9.next = 2;
                      break;
                    }

                    return _context9.abrupt("return", this._rootKey);

                  case 2:
                    _context9.next = 4;
                    return _Certificate.createUnverified({
                      certificate: d.certificate,
                      rootKey: this._rootKey,
                      canisterId: this._canisterId,
                      blsVerify: this._blsVerify,
                      // Do not check max age for delegation certificates
                      maxAgeInMinutes: Infinity
                    });

                  case 4:
                    cert = _context9.sent;

                    if (!cert.cert.delegation) {
                      _context9.next = 7;
                      break;
                    }

                    throw new CertificateVerificationError("Delegation certificates cannot be nested");

                  case 7:
                    _context9.next = 9;
                    return cert.verify();

                  case 9:
                    if (!(this._canisterId.toString() !== agent_1.MANAGEMENT_CANISTER_ID)) {
                      _context9.next = 13;
                      break;
                    }

                    canisterInRange = check_canister_ranges({
                      canisterId: this._canisterId,
                      subnetId: principal_1.Principal.fromUint8Array(new Uint8Array(d.subnet_id)),
                      tree: cert.cert.tree
                    });

                    if (canisterInRange) {
                      _context9.next = 13;
                      break;
                    }

                    throw new CertificateVerificationError("Canister " + this._canisterId + " not in range of delegations for subnet 0x" + (0, buffer_1.toHex)(d.subnet_id));

                  case 13:
                    publicKeyLookup = lookupResultToBuffer(cert.lookup(["subnet", d.subnet_id, "public_key"]));

                    if (publicKeyLookup) {
                      _context9.next = 16;
                      break;
                    }

                    throw new Error("Could not find subnet key for subnet 0x" + (0, buffer_1.toHex)(d.subnet_id));

                  case 16:
                    return _context9.abrupt("return", publicKeyLookup);

                  case 17:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function _checkDelegationAndGetKey(_x12) {
            return _checkDelegationAndGetKey2.apply(this, arguments);
          }

          return _checkDelegationAndGetKey;
        }();

        return _Certificate;
      }();

      exports.Certificate = Certificate;
      _Certificate_disableTimeVerification = /* @__PURE__ */new WeakMap();
      var DER_PREFIX = (0, buffer_1.fromHex)("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
      var KEY_LENGTH = 96;

      function extractDER(buf) {
        var expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;

        if (buf.byteLength !== expectedLength) {
          // Temporary patch: if length mismatch, just return the buffer as is or slice it if it looks like a raw key
          // This is to bypass the strict check which might be failing due to different key formats in local replica
          console.warn("BLS DER-encoded public key length mismatch. Expected " + expectedLength + ", got " + buf.byteLength + ". Proceeding anyway.");

          if (buf.byteLength === KEY_LENGTH) {
            return buf;
          } // throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);

        }

        var prefix = buf.slice(0, DER_PREFIX.byteLength);

        if (!(0, buffer_1.bufEquals)(prefix, DER_PREFIX)) {
          console.warn("BLS DER-encoded public key prefix mismatch. Proceeding anyway."); // throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
        }

        return buf.slice(DER_PREFIX.byteLength);
      }

      function lookupResultToBuffer(result) {
        if (result.status !== LookupStatus.Found) {
          return void 0;
        }

        if (result.value instanceof ArrayBuffer) {
          return result.value;
        }

        if (result.value instanceof Uint8Array) {
          return result.value.buffer;
        }

        return void 0;
      }

      exports.lookupResultToBuffer = lookupResultToBuffer;

      function reconstruct(_x13) {
        return _reconstruct.apply(this, arguments);
      }

      function _reconstruct() {
        _reconstruct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(t) {
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.t0 = t[0];
                  _context10.next = _context10.t0 === NodeType.Empty ? 3 : _context10.t0 === NodeType.Pruned ? 4 : _context10.t0 === NodeType.Leaf ? 5 : _context10.t0 === NodeType.Labeled ? 6 : _context10.t0 === NodeType.Fork ? 15 : 26;
                  break;

                case 3:
                  return _context10.abrupt("return", (0, request_id_1.hash)(domain_sep("ic-hashtree-empty")));

                case 4:
                  return _context10.abrupt("return", t[1]);

                case 5:
                  return _context10.abrupt("return", (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep("ic-hashtree-leaf"), t[1])));

                case 6:
                  _context10.t1 = (0, request_id_1.hash);
                  _context10.t2 = (0, buffer_1.concat);
                  _context10.t3 = domain_sep("ic-hashtree-labeled");
                  _context10.t4 = t[1];
                  _context10.next = 12;
                  return reconstruct(t[2]);

                case 12:
                  _context10.t5 = _context10.sent;
                  _context10.t6 = (0, _context10.t2)(_context10.t3, _context10.t4, _context10.t5);
                  return _context10.abrupt("return", (0, _context10.t1)(_context10.t6));

                case 15:
                  _context10.t7 = (0, request_id_1.hash);
                  _context10.t8 = (0, buffer_1.concat);
                  _context10.t9 = domain_sep("ic-hashtree-fork");
                  _context10.next = 20;
                  return reconstruct(t[1]);

                case 20:
                  _context10.t10 = _context10.sent;
                  _context10.next = 23;
                  return reconstruct(t[2]);

                case 23:
                  _context10.t11 = _context10.sent;
                  _context10.t12 = (0, _context10.t8)(_context10.t9, _context10.t10, _context10.t11);
                  return _context10.abrupt("return", (0, _context10.t7)(_context10.t12));

                case 26:
                  throw new Error("unreachable");

                case 27:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));
        return _reconstruct.apply(this, arguments);
      }

      exports.reconstruct = reconstruct;

      function domain_sep(s) {
        var len = new Uint8Array([s.length]);
        var str = new TextEncoder().encode(s);
        return (0, buffer_1.concat)(len, str);
      }

      var LookupStatus;

      (function (LookupStatus2) {
        LookupStatus2["Unknown"] = "unknown";
        LookupStatus2["Absent"] = "absent";
        LookupStatus2["Found"] = "found";
      })(LookupStatus = exports.LookupStatus || (exports.LookupStatus = {}));

      var LabelLookupStatus;

      (function (LabelLookupStatus2) {
        LabelLookupStatus2["Less"] = "less";
        LabelLookupStatus2["Greater"] = "greater";
      })(LabelLookupStatus || (LabelLookupStatus = {}));

      function lookup_path(path, tree) {
        if (path.length === 0) {
          switch (tree[0]) {
            case NodeType.Leaf:
              {
                if (!tree[1]) {
                  throw new Error("Invalid tree structure for leaf");
                }

                if (tree[1] instanceof ArrayBuffer) {
                  return {
                    status: LookupStatus.Found,
                    value: tree[1]
                  };
                }

                if (tree[1] instanceof Uint8Array) {
                  return {
                    status: LookupStatus.Found,
                    value: tree[1].buffer
                  };
                }

                return {
                  status: LookupStatus.Found,
                  value: tree[1]
                };
              }

            default:
              {
                return {
                  status: LookupStatus.Found,
                  value: tree
                };
              }
          }
        }

        var label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
        var lookupResult = find_label(label, tree);

        switch (lookupResult.status) {
          case LookupStatus.Found:
            {
              return lookup_path(path.slice(1), lookupResult.value);
            }

          case LabelLookupStatus.Greater:
          case LabelLookupStatus.Less:
            {
              return {
                status: LookupStatus.Absent
              };
            }

          default:
            {
              return lookupResult;
            }
        }
      }

      exports.lookup_path = lookup_path;

      function flatten_forks(t) {
        switch (t[0]) {
          case NodeType.Empty:
            return [];

          case NodeType.Fork:
            return flatten_forks(t[1]).concat(flatten_forks(t[2]));

          default:
            return [t];
        }
      }

      exports.flatten_forks = flatten_forks;

      function find_label(label, tree) {
        switch (tree[0]) {
          case NodeType.Labeled:
            if (isBufferGreaterThan(label, tree[1])) {
              return {
                status: LabelLookupStatus.Greater
              };
            }

            if ((0, buffer_1.bufEquals)(label, tree[1])) {
              return {
                status: LookupStatus.Found,
                value: tree[2]
              };
            }

            return {
              status: LabelLookupStatus.Less
            };

          case NodeType.Fork:
            var leftLookupResult = find_label(label, tree[1]);

            switch (leftLookupResult.status) {
              case LabelLookupStatus.Greater:
                {
                  var rightLookupResult = find_label(label, tree[2]);

                  if (rightLookupResult.status === LabelLookupStatus.Less) {
                    return {
                      status: LookupStatus.Absent
                    };
                  }

                  return rightLookupResult;
                }

              case LookupStatus.Unknown:
                {
                  var _rightLookupResult = find_label(label, tree[2]);

                  if (_rightLookupResult.status === LabelLookupStatus.Less) {
                    return {
                      status: LookupStatus.Unknown
                    };
                  }

                  return _rightLookupResult;
                }

              default:
                {
                  return leftLookupResult;
                }
            }

          case NodeType.Pruned:
            return {
              status: LookupStatus.Unknown
            };

          default:
            return {
              status: LookupStatus.Absent
            };
        }
      }

      exports.find_label = find_label;

      function check_canister_ranges(params) {
        var canisterId = params.canisterId,
            subnetId = params.subnetId,
            tree = params.tree;
        var rangeLookup = lookup_path(["subnet", subnetId.toUint8Array(), "canister_ranges"], tree);

        if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {
          throw new Error("Could not find canister ranges for subnet " + subnetId);
        }

        var ranges_arr = cbor.decode(rangeLookup.value);
        var ranges = ranges_arr.map(function (v) {
          return [principal_1.Principal.fromUint8Array(v[0]), principal_1.Principal.fromUint8Array(v[1])];
        });
        var canisterInRange = ranges.some(function (r) {
          return r[0].ltEq(canisterId) && r[1].gtEq(canisterId);
        });
        return canisterInRange;
      }

      exports.check_canister_ranges = check_canister_ranges;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/canisterStatus/index.js


  var require_canisterStatus = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/canisterStatus/index.js": function node_modulesDfinityAgentLibCjsCanisterStatusIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.encodePath = exports.fetchNodeKeys = exports.request = exports.CustomPath = void 0;
      var principal_1 = require_cjs();
      var errors_1 = require_errors();
      var certificate_1 = require_certificate();
      var buffer_1 = require_buffer2();

      var Cbor = __importStar(require_cbor());

      var leb_1 = require_leb();

      var CustomPath = function CustomPath(key, path, decodeStrategy) {
        this.key = key;
        this.path = path;
        this.decodeStrategy = decodeStrategy;
      };

      exports.CustomPath = CustomPath;

      var request = /*#__PURE__*/function () {
        var _ref103 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(options) {
          var agent, paths, canisterId, uniquePaths, encodedPaths, status, promises;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  agent = options.agent, paths = options.paths;
                  canisterId = principal_1.Principal.from(options.canisterId);
                  uniquePaths = [].concat(new Set(paths));
                  encodedPaths = uniquePaths.map(function (path) {
                    return (0, exports.encodePath)(path, canisterId);
                  });
                  status = /* @__PURE__ */new Map();
                  promises = uniquePaths.map(function (path, index) {
                    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                      var _a, response, cert, lookup, _lookup, path2, data;

                      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                        while (1) {
                          switch (_context11.prev = _context11.next) {
                            case 0:
                              _context11.prev = 0;
                              _context11.next = 3;
                              return agent.readState(canisterId, {
                                paths: [encodedPaths[index]]
                              });

                            case 3:
                              response = _context11.sent;

                              if (!(agent.rootKey == null)) {
                                _context11.next = 6;
                                break;
                              }

                              throw new Error("Agent is missing root key");

                            case 6:
                              _context11.next = 8;
                              return certificate_1.Certificate.create({
                                certificate: response.certificate,
                                rootKey: agent.rootKey,
                                canisterId: canisterId,
                                disableTimeVerification: true
                              });

                            case 8:
                              cert = _context11.sent;

                              lookup = function lookup(cert2, path3) {
                                if (path3 === "subnet") {
                                  if (agent.rootKey == null) {
                                    throw new Error("Agent is missing root key");
                                  }

                                  var data2 = (0, exports.fetchNodeKeys)(response.certificate, canisterId, agent.rootKey);
                                  return {
                                    path: path3,
                                    data: data2
                                  };
                                } else {
                                  return {
                                    path: path3,
                                    data: (0, certificate_1.lookupResultToBuffer)(cert2.lookup((0, exports.encodePath)(path3, canisterId)))
                                  };
                                }
                              };

                              _lookup = lookup(cert, uniquePaths[index]), path2 = _lookup.path, data = _lookup.data;

                              if (data) {
                                _context11.next = 16;
                                break;
                              }

                              console.warn("Expected to find result for path " + path2 + ", but instead found nothing.");

                              if (typeof path2 === "string") {
                                status.set(path2, null);
                              } else {
                                status.set(path2.key, null);
                              }

                              _context11.next = 42;
                              break;

                            case 16:
                              _context11.t0 = path2;
                              _context11.next = _context11.t0 === "time" ? 19 : _context11.t0 === "controllers" ? 21 : _context11.t0 === "module_hash" ? 23 : _context11.t0 === "subnet" ? 25 : _context11.t0 === "candid" ? 27 : 29;
                              break;

                            case 19:
                              status.set(path2, (0, leb_1.decodeTime)(data));
                              return _context11.abrupt("break", 42);

                            case 21:
                              status.set(path2, decodeControllers(data));
                              return _context11.abrupt("break", 42);

                            case 23:
                              status.set(path2, decodeHex(data));
                              return _context11.abrupt("break", 42);

                            case 25:
                              status.set(path2, data);
                              return _context11.abrupt("break", 42);

                            case 27:
                              status.set(path2, new TextDecoder().decode(data));
                              return _context11.abrupt("break", 42);

                            case 29:
                              if (!(typeof path2 !== "string" && "key" in path2 && "path" in path2)) {
                                _context11.next = 42;
                                break;
                              }

                              _context11.t1 = path2.decodeStrategy;
                              _context11.next = _context11.t1 === "raw" ? 33 : _context11.t1 === "leb128" ? 35 : _context11.t1 === "cbor" ? 37 : _context11.t1 === "hex" ? 39 : _context11.t1 === "utf-8" ? 41 : 42;
                              break;

                            case 33:
                              status.set(path2.key, data);
                              return _context11.abrupt("break", 42);

                            case 35:
                              status.set(path2.key, (0, leb_1.decodeLeb128)(data));
                              return _context11.abrupt("break", 42);

                            case 37:
                              status.set(path2.key, decodeCbor(data));
                              return _context11.abrupt("break", 42);

                            case 39:
                              status.set(path2.key, decodeHex(data));
                              return _context11.abrupt("break", 42);

                            case 41:
                              status.set(path2.key, decodeUtf8(data));

                            case 42:
                              _context11.next = 53;
                              break;

                            case 44:
                              _context11.prev = 44;
                              _context11.t2 = _context11["catch"](0);

                              if (!((_a = _context11.t2 === null || _context11.t2 === void 0 ? void 0 : _context11.t2.message) === null || _a === void 0 ? void 0 : _a.includes("Invalid certificate"))) {
                                _context11.next = 48;
                                break;
                              }

                              throw new errors_1.AgentError(_context11.t2.message);

                            case 48:
                              if (typeof path !== "string" && "key" in path && "path" in path) {
                                status.set(path.key, null);
                              } else {
                                status.set(path, null);
                              }

                              console.group();
                              console.warn("Expected to find result for path " + path + ", but instead found nothing.");
                              console.warn(_context11.t2);
                              console.groupEnd();

                            case 53:
                            case "end":
                              return _context11.stop();
                          }
                        }
                      }, _callee11, null, [[0, 44]]);
                    }))();
                  });
                  _context12.next = 8;
                  return Promise.all(promises);

                case 8:
                  return _context12.abrupt("return", status);

                case 9:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }));

        return function request(_x14) {
          return _ref103.apply(this, arguments);
        };
      }();

      exports.request = request;

      var fetchNodeKeys = function fetchNodeKeys(certificate, canisterId, root_key) {
        if (!canisterId._isPrincipal) {
          throw new Error("Invalid canisterId");
        }

        var cert = Cbor.decode(new Uint8Array(certificate));
        var tree = cert.tree;
        var delegation = cert.delegation;
        var subnetId;

        if (delegation && delegation.subnet_id) {
          subnetId = principal_1.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));
        } else if (!delegation && typeof root_key !== "undefined") {
          subnetId = principal_1.Principal.selfAuthenticating(new Uint8Array(root_key));
          delegation = {
            subnet_id: subnetId.toUint8Array(),
            certificate: new ArrayBuffer(0)
          };
        } else {
          subnetId = principal_1.Principal.selfAuthenticating(principal_1.Principal.fromText("tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe").toUint8Array());
          delegation = {
            subnet_id: subnetId.toUint8Array(),
            certificate: new ArrayBuffer(0)
          };
        }

        var canisterInRange = (0, certificate_1.check_canister_ranges)({
          canisterId: canisterId,
          subnetId: subnetId,
          tree: tree
        });

        if (!canisterInRange) {
          throw new Error("Canister not in range");
        }

        var subnetLookupResult = (0, certificate_1.lookup_path)(["subnet", delegation.subnet_id, "node"], tree);

        if (subnetLookupResult.status !== certificate_1.LookupStatus.Found) {
          throw new Error("Node not found");
        }

        if (subnetLookupResult.value instanceof ArrayBuffer) {
          throw new Error("Invalid node tree");
        }

        var nodeForks = (0, certificate_1.flatten_forks)(subnetLookupResult.value);
        var nodeKeys = /* @__PURE__ */new Map();
        nodeForks.forEach(function (fork) {
          var node_id = principal_1.Principal.from(new Uint8Array(fork[1])).toText();
          var publicKeyLookupResult = (0, certificate_1.lookup_path)(["public_key"], fork[2]);

          if (publicKeyLookupResult.status !== certificate_1.LookupStatus.Found) {
            throw new Error("Public key not found");
          }

          var derEncodedPublicKey = publicKeyLookupResult.value;

          if (derEncodedPublicKey.byteLength !== 44) {
            throw new Error("Invalid public key length");
          } else {
            nodeKeys.set(node_id, derEncodedPublicKey);
          }
        });
        return {
          subnetId: principal_1.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),
          nodeKeys: nodeKeys
        };
      };

      exports.fetchNodeKeys = fetchNodeKeys;

      var encodePath = function encodePath(path, canisterId) {
        var encoder = new TextEncoder();

        var encode = function encode(arg) {
          return new DataView(encoder.encode(arg).buffer).buffer;
        };

        var canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;

        switch (path) {
          case "time":
            return [encode("time")];

          case "controllers":
            return [encode("canister"), canisterBuffer, encode("controllers")];

          case "module_hash":
            return [encode("canister"), canisterBuffer, encode("module_hash")];

          case "subnet":
            return [encode("subnet")];

          case "candid":
            return [encode("canister"), canisterBuffer, encode("metadata"), encode("candid:service")];

          default:
            {
              if ("key" in path && "path" in path) {
                if (typeof path["path"] === "string" || path["path"] instanceof ArrayBuffer) {
                  var metaPath = path.path;
                  var encoded = typeof metaPath === "string" ? encode(metaPath) : metaPath;
                  return [encode("canister"), canisterBuffer, encode("metadata"), encoded];
                } else {
                  return path["path"];
                }
              }
            }
        }

        throw new Error("An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, " + path + " was formatted correctly.");
      };

      exports.encodePath = encodePath;

      var decodeHex = function decodeHex(buf) {
        return (0, buffer_1.toHex)(buf);
      };

      var decodeCbor = function decodeCbor(buf) {
        return Cbor.decode(buf);
      };

      var decodeUtf8 = function decodeUtf8(buf) {
        return new TextDecoder().decode(buf);
      };

      var decodeControllers = function decodeControllers(buf) {
        var controllersRaw = decodeCbor(buf);
        return controllersRaw.map(function (buf2) {
          return principal_1.Principal.fromUint8Array(new Uint8Array(buf2));
        });
      };
    }
  }); // node_modules/@noble/curves/abstract/edwards.js


  var require_edwards = __commonJS({
    "node_modules/@noble/curves/abstract/edwards.js": function node_modulesNobleCurvesAbstractEdwardsJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PrimeEdwardsPoint = void 0;
      exports.edwards = edwards;
      exports.eddsa = eddsa;
      exports.twistedEdwards = twistedEdwards;
      var utils_ts_1 = require_utils3();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _8n = BigInt(8);

      function isEdValidXY(Fp, CURVE, x, y) {
        var x2 = Fp.sqr(x);
        var y2 = Fp.sqr(y);
        var left = Fp.add(Fp.mul(CURVE.a, x2), y2);
        var right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
        return Fp.eql(left, right);
      }

      function edwards(params, extraOpts) {
        if (extraOpts === void 0) {
          extraOpts = {};
        }

        var validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
        var Fp = validated.Fp,
            Fn = validated.Fn;
        var _CURVE2 = validated.CURVE;
        var cofactor = _CURVE2.h;
        (0, utils_ts_1._validateObject)(extraOpts, {}, {
          uvRatio: "function"
        });

        var MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;

        var modP = function modP(n) {
          return Fp.create(n);
        };

        var uvRatio = extraOpts.uvRatio || function (u, v) {
          try {
            return {
              isValid: true,
              value: Fp.sqrt(Fp.div(u, v))
            };
          } catch (e) {
            return {
              isValid: false,
              value: _0n
            };
          }
        };

        if (!isEdValidXY(Fp, _CURVE2, _CURVE2.Gx, _CURVE2.Gy)) throw new Error("bad curve params: generator point");

        function acoord(title, n, banZero) {
          if (banZero === void 0) {
            banZero = false;
          }

          var min = banZero ? _1n : _0n;
          (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
          return n;
        }

        function aextpoint(other) {
          if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
        }

        var toAffineMemo = (0, utils_ts_1.memoized)(function (p, iz) {
          var X = p.X,
              Y = p.Y,
              Z = p.Z;
          var is0 = p.is0();
          if (iz == null) iz = is0 ? _8n : Fp.inv(Z);
          var x = modP(X * iz);
          var y = modP(Y * iz);
          var zz = Fp.mul(Z, iz);
          if (is0) return {
            x: _0n,
            y: _1n
          };
          if (zz !== _1n) throw new Error("invZ was invalid");
          return {
            x: x,
            y: y
          };
        });
        var assertValidMemo = (0, utils_ts_1.memoized)(function (p) {
          var a = _CURVE2.a,
              d = _CURVE2.d;
          if (p.is0()) throw new Error("bad point: ZERO");
          var X = p.X,
              Y = p.Y,
              Z = p.Z,
              T = p.T;
          var X2 = modP(X * X);
          var Y2 = modP(Y * Y);
          var Z2 = modP(Z * Z);
          var Z4 = modP(Z2 * Z2);
          var aX2 = modP(X2 * a);
          var left = modP(Z2 * modP(aX2 + Y2));
          var right = modP(Z4 + modP(d * modP(X2 * Y2)));
          if (left !== right) throw new Error("bad point: equation left != right (1)");
          var XY = modP(X * Y);
          var ZT = modP(Z * T);
          if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
          return true;
        });

        var Point = /*#__PURE__*/function () {
          function Point(X, Y, Z, T) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y);
            this.Z = acoord("z", Z, true);
            this.T = acoord("t", T);
            Object.freeze(this);
          }

          Point.CURVE = function CURVE() {
            return _CURVE2;
          };

          Point.fromAffine = function fromAffine(p) {
            if (p instanceof Point) throw new Error("extended point not allowed");

            var _ref105 = p || {},
                x = _ref105.x,
                y = _ref105.y;

            acoord("x", x);
            acoord("y", y);
            return new Point(x, y, _1n, modP(x * y));
          } // Uses algo from RFC8032 5.1.3.
          ;

          Point.fromBytes = function fromBytes(bytes, zip215) {
            if (zip215 === void 0) {
              zip215 = false;
            }

            var len = Fp.BYTES;
            var a = _CURVE2.a,
                d = _CURVE2.d;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
            (0, utils_ts_1._abool2)(zip215, "zip215");
            var normed = (0, utils_ts_1.copyBytes)(bytes);
            var lastByte = bytes[len - 1];
            normed[len - 1] = lastByte & ~128;
            var y = (0, utils_ts_1.bytesToNumberLE)(normed);
            var max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
            var y2 = modP(y * y);
            var u = modP(y2 - _1n);
            var v = modP(d * y2 - a);

            var _uvRatio = uvRatio(u, v),
                isValid = _uvRatio.isValid,
                x = _uvRatio.value;

            if (!isValid) throw new Error("bad point: invalid y coordinate");
            var isXOdd = (x & _1n) === _1n;
            var isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd) throw new Error("bad point: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd) x = modP(-x);
            return Point.fromAffine({
              x: x,
              y: y
            });
          };

          Point.fromHex = function fromHex(bytes, zip215) {
            if (zip215 === void 0) {
              zip215 = false;
            }

            return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
          };

          var _proto68 = Point.prototype;

          _proto68.precompute = function precompute(windowSize, isLazy) {
            if (windowSize === void 0) {
              windowSize = 8;
            }

            if (isLazy === void 0) {
              isLazy = true;
            }

            wnaf.createCache(this, windowSize);
            if (!isLazy) this.multiply(_2n);
            return this;
          } // Useful in fromAffine() - not for fromBytes(), which always created valid points.
          ;

          _proto68.assertValidity = function assertValidity() {
            assertValidMemo(this);
          } // Compare one point to another.
          ;

          _proto68.equals = function equals(other) {
            aextpoint(other);
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z;
            var X2 = other.X,
                Y2 = other.Y,
                Z2 = other.Z;
            var X1Z2 = modP(X1 * Z2);
            var X2Z1 = modP(X2 * Z1);
            var Y1Z2 = modP(Y1 * Z2);
            var Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          };

          _proto68.is0 = function is0() {
            return this.equals(Point.ZERO);
          };

          _proto68.negate = function negate() {
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
          } // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          ;

          _proto68["double"] = function double() {
            var a = _CURVE2.a;
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z;
            var A = modP(X1 * X1);
            var B = modP(Y1 * Y1);
            var C = modP(_2n * modP(Z1 * Z1));
            var D = modP(a * A);
            var x1y1 = X1 + Y1;
            var E = modP(modP(x1y1 * x1y1) - A - B);
            var G = D + B;
            var F = G - C;
            var H = D - B;
            var X3 = modP(E * F);
            var Y3 = modP(G * H);
            var T3 = modP(E * H);
            var Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          } // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          ;

          _proto68.add = function add(other) {
            aextpoint(other);
            var a = _CURVE2.a,
                d = _CURVE2.d;
            var X1 = this.X,
                Y1 = this.Y,
                Z1 = this.Z,
                T1 = this.T;
            var X2 = other.X,
                Y2 = other.Y,
                Z2 = other.Z,
                T2 = other.T;
            var A = modP(X1 * X2);
            var B = modP(Y1 * Y2);
            var C = modP(T1 * d * T2);
            var D = modP(Z1 * Z2);
            var E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            var F = D - C;
            var G = D + C;
            var H = modP(B - a * A);
            var X3 = modP(E * F);
            var Y3 = modP(G * H);
            var T3 = modP(E * H);
            var Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          };

          _proto68.subtract = function subtract(other) {
            return this.add(other.negate());
          } // Constant-time multiplication.
          ;

          _proto68.multiply = function multiply(scalar) {
            if (!Fn.isValidNot0(scalar)) throw new Error("invalid scalar: expected 1 <= sc < curve.n");

            var _wnaf$cached = wnaf.cached(this, scalar, function (p2) {
              return (0, curve_ts_1.normalizeZ)(Point, p2);
            }),
                p = _wnaf$cached.p,
                f = _wnaf$cached.f;

            return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];
          } // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          // Accepts optional accumulator to merge with multiply (important for sparse scalars)
          ;

          _proto68.multiplyUnsafe = function multiplyUnsafe(scalar, acc) {
            if (acc === void 0) {
              acc = Point.ZERO;
            }

            if (!Fn.isValid(scalar)) throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            if (scalar === _0n) return Point.ZERO;
            if (this.is0() || scalar === _1n) return this;
            return wnaf.unsafe(this, scalar, function (p) {
              return (0, curve_ts_1.normalizeZ)(Point, p);
            }, acc);
          } // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          ;

          _proto68.isSmallOrder = function isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          } // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          ;

          _proto68.isTorsionFree = function isTorsionFree() {
            return wnaf.unsafe(this, _CURVE2.n).is0();
          } // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          ;

          _proto68.toAffine = function toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          };

          _proto68.clearCofactor = function clearCofactor() {
            if (cofactor === _1n) return this;
            return this.multiplyUnsafe(cofactor);
          };

          _proto68.toBytes = function toBytes() {
            var _this$toAffine2 = this.toAffine(),
                x = _this$toAffine2.x,
                y = _this$toAffine2.y;

            var bytes = Fp.toBytes(y);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          };

          _proto68.toHex = function toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
          };

          _proto68.toString = function toString() {
            return "<Point " + (this.is0() ? "ZERO" : this.toHex()) + ">";
          } // TODO: remove
          ;

          Point.normalizeZ = function normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          };

          Point.msm = function msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          };

          _proto68._setWindowSize = function _setWindowSize(windowSize) {
            this.precompute(windowSize);
          };

          _proto68.toRawBytes = function toRawBytes() {
            return this.toBytes();
          };

          _createClass(Point, [{
            key: "x",
            get: function get() {
              return this.toAffine().x;
            }
          }, {
            key: "y",
            get: function get() {
              return this.toAffine().y;
            }
          }, {
            key: "ex",
            get: function get() {
              return this.X;
            }
          }, {
            key: "ey",
            get: function get() {
              return this.Y;
            }
          }, {
            key: "ez",
            get: function get() {
              return this.Z;
            }
          }, {
            key: "et",
            get: function get() {
              return this.T;
            }
          }]);

          return Point;
        }();

        Point.BASE = new Point(_CURVE2.Gx, _CURVE2.Gy, _1n, modP(_CURVE2.Gx * _CURVE2.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        Point.Fp = Fp;
        Point.Fn = Fn;
        var wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
        Point.BASE.precompute(8);
        return Point;
      }

      var PrimeEdwardsPoint = /*#__PURE__*/function () {
        function PrimeEdwardsPoint(ep) {
          this.ep = ep;
        } // Static methods that must be implemented by subclasses


        PrimeEdwardsPoint.fromBytes = function fromBytes(_bytes) {
          (0, utils_ts_1.notImplemented)();
        };

        PrimeEdwardsPoint.fromHex = function fromHex(_hex) {
          (0, utils_ts_1.notImplemented)();
        };

        var _proto69 = PrimeEdwardsPoint.prototype;

        // Common implementations
        _proto69.clearCofactor = function clearCofactor() {
          return this;
        };

        _proto69.assertValidity = function assertValidity() {
          this.ep.assertValidity();
        };

        _proto69.toAffine = function toAffine(invertedZ) {
          return this.ep.toAffine(invertedZ);
        };

        _proto69.toHex = function toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        };

        _proto69.toString = function toString() {
          return this.toHex();
        };

        _proto69.isTorsionFree = function isTorsionFree() {
          return true;
        };

        _proto69.isSmallOrder = function isSmallOrder() {
          return false;
        };

        _proto69.add = function add(other) {
          this.assertSame(other);
          return this.init(this.ep.add(other.ep));
        };

        _proto69.subtract = function subtract(other) {
          this.assertSame(other);
          return this.init(this.ep.subtract(other.ep));
        };

        _proto69.multiply = function multiply(scalar) {
          return this.init(this.ep.multiply(scalar));
        };

        _proto69.multiplyUnsafe = function multiplyUnsafe(scalar) {
          return this.init(this.ep.multiplyUnsafe(scalar));
        };

        _proto69["double"] = function double() {
          return this.init(this.ep["double"]());
        };

        _proto69.negate = function negate() {
          return this.init(this.ep.negate());
        };

        _proto69.precompute = function precompute(windowSize, isLazy) {
          return this.init(this.ep.precompute(windowSize, isLazy));
        }
        /** @deprecated use `toBytes` */
        ;

        _proto69.toRawBytes = function toRawBytes() {
          return this.toBytes();
        };

        _createClass(PrimeEdwardsPoint, [{
          key: "x",
          get: function get() {
            return this.toAffine().x;
          }
        }, {
          key: "y",
          get: function get() {
            return this.toAffine().y;
          }
        }]);

        return PrimeEdwardsPoint;
      }();

      exports.PrimeEdwardsPoint = PrimeEdwardsPoint;

      function eddsa(Point, cHash, eddsaOpts) {
        if (eddsaOpts === void 0) {
          eddsaOpts = {};
        }

        if (typeof cHash !== "function") throw new Error('"hash" function param is required');
        (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
          adjustScalarBytes: "function",
          randomBytes: "function",
          domain: "function",
          prehash: "function",
          mapToCurve: "function"
        });
        var _eddsaOpts = eddsaOpts,
            prehash = _eddsaOpts.prehash;
        var BASE = Point.BASE,
            Fp = Point.Fp,
            Fn = Point.Fn;
        var randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;

        var adjustScalarBytes = eddsaOpts.adjustScalarBytes || function (bytes) {
          return bytes;
        };

        var domain = eddsaOpts.domain || function (data, ctx, phflag) {
          (0, utils_ts_1._abool2)(phflag, "phflag");
          if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
          return data;
        };

        function modN_LE(hash) {
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash));
        }

        function getPrivateScalar(key) {
          var len = lengths.secretKey;
          key = (0, utils_ts_1.ensureBytes)("private key", key, len);
          var hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          var head = adjustScalarBytes(hashed.slice(0, len));
          var prefix = hashed.slice(len, 2 * len);
          var scalar = modN_LE(head);
          return {
            head: head,
            prefix: prefix,
            scalar: scalar
          };
        }

        function getExtendedPublicKey(secretKey) {
          var _getPrivateScalar = getPrivateScalar(secretKey),
              head = _getPrivateScalar.head,
              prefix = _getPrivateScalar.prefix,
              scalar = _getPrivateScalar.scalar;

          var point = BASE.multiply(scalar);
          var pointBytes = point.toBytes();
          return {
            head: head,
            prefix: prefix,
            scalar: scalar,
            point: point,
            pointBytes: pointBytes
          };
        }

        function getPublicKey(secretKey) {
          return getExtendedPublicKey(secretKey).pointBytes;
        }

        function hashDomainToScalar(context) {
          if (context === void 0) {
            context = Uint8Array.of();
          }

          for (var _len10 = arguments.length, msgs = new Array(_len10 > 1 ? _len10 - 1 : 0), _key12 = 1; _key12 < _len10; _key12++) {
            msgs[_key12 - 1] = arguments[_key12];
          }

          var msg = (0, utils_ts_1.concatBytes).apply(void 0, msgs);
          return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
        }

        function sign(msg, secretKey, options) {
          if (options === void 0) {
            options = {};
          }

          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          if (prehash) msg = prehash(msg);

          var _getExtendedPublicKey = getExtendedPublicKey(secretKey),
              prefix = _getExtendedPublicKey.prefix,
              scalar = _getExtendedPublicKey.scalar,
              pointBytes = _getExtendedPublicKey.pointBytes;

          var r = hashDomainToScalar(options.context, prefix, msg);
          var R = BASE.multiply(r).toBytes();
          var k = hashDomainToScalar(options.context, R, pointBytes, msg);
          var s = Fn.create(r + k * scalar);
          if (!Fn.isValid(s)) throw new Error("sign failed: invalid s");
          var rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
          return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
        }

        var verifyOpts = {
          zip215: true
        };

        function verify(sig, msg, publicKey, options) {
          if (options === void 0) {
            options = verifyOpts;
          }

          var _options = options,
              context = _options.context,
              zip215 = _options.zip215;
          var len = lengths.signature;
          sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, lengths.publicKey);
          if (zip215 !== void 0) (0, utils_ts_1._abool2)(zip215, "zip215");
          if (prehash) msg = prehash(msg);
          var mid = len / 2;
          var r = sig.subarray(0, mid);
          var s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
          var A, R, SB;

          try {
            A = Point.fromBytes(publicKey, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s);
          } catch (error) {
            return false;
          }

          if (!zip215 && A.isSmallOrder()) return false;
          var k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
          var RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().is0();
        }

        var _size = Fp.BYTES;
        var lengths = {
          secretKey: _size,
          publicKey: _size,
          signature: 2 * _size,
          seed: _size
        };

        function randomSecretKey(seed) {
          if (seed === void 0) {
            seed = randomBytes(lengths.seed);
          }

          return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
        }

        function keygen(seed) {
          var secretKey = utils.randomSecretKey(seed);
          return {
            secretKey: secretKey,
            publicKey: getPublicKey(secretKey)
          };
        }

        function isValidSecretKey(key) {
          return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
        }

        function isValidPublicKey(key, zip215) {
          try {
            return !!Point.fromBytes(key, zip215);
          } catch (error) {
            return false;
          }
        }

        var utils = {
          getExtendedPublicKey: getExtendedPublicKey,
          randomSecretKey: randomSecretKey,
          isValidSecretKey: isValidSecretKey,
          isValidPublicKey: isValidPublicKey,

          /**
           * Converts ed public key to x public key. Uses formula:
           * - ed25519:
           *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
           *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
           * - ed448:
           *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
           *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
           */
          toMontgomery: function toMontgomery(publicKey) {
            var _Point$fromBytes = Point.fromBytes(publicKey),
                y = _Point$fromBytes.y;

            var size = lengths.publicKey;
            var is25519 = size === 32;
            if (!is25519 && size !== 57) throw new Error("only defined for 25519 and 448");
            var u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
          },
          toMontgomerySecret: function toMontgomerySecret(secretKey) {
            var size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            var hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
          },

          /** @deprecated */
          randomPrivateKey: randomSecretKey,

          /** @deprecated */
          precompute: function precompute(windowSize, point) {
            if (windowSize === void 0) {
              windowSize = 8;
            }

            if (point === void 0) {
              point = Point.BASE;
            }

            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({
          keygen: keygen,
          getPublicKey: getPublicKey,
          sign: sign,
          verify: verify,
          utils: utils,
          Point: Point,
          lengths: lengths
        });
      }

      function _eddsa_legacy_opts_to_new(c) {
        var CURVE = {
          a: c.a,
          d: c.d,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        var Fp = c.Fp;
        var Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
        var curveOpts = {
          Fp: Fp,
          Fn: Fn,
          uvRatio: c.uvRatio
        };
        var eddsaOpts = {
          randomBytes: c.randomBytes,
          adjustScalarBytes: c.adjustScalarBytes,
          domain: c.domain,
          prehash: c.prehash,
          mapToCurve: c.mapToCurve
        };
        return {
          CURVE: CURVE,
          curveOpts: curveOpts,
          hash: c.hash,
          eddsaOpts: eddsaOpts
        };
      }

      function _eddsa_new_output_to_legacy(c, eddsa2) {
        var Point = eddsa2.Point;
        var legacy = Object.assign({}, eddsa2, {
          ExtendedPoint: Point,
          CURVE: c,
          nBitLength: Point.Fn.BITS,
          nByteLength: Point.Fn.BYTES
        });
        return legacy;
      }

      function twistedEdwards(c) {
        var _eddsa_legacy_opts_to = _eddsa_legacy_opts_to_new(c),
            CURVE = _eddsa_legacy_opts_to.CURVE,
            curveOpts = _eddsa_legacy_opts_to.curveOpts,
            hash = _eddsa_legacy_opts_to.hash,
            eddsaOpts = _eddsa_legacy_opts_to.eddsaOpts;

        var Point = edwards(CURVE, curveOpts);
        var EDDSA = eddsa(Point, hash, eddsaOpts);
        return _eddsa_new_output_to_legacy(c, EDDSA);
      }
    }
  }); // node_modules/@noble/curves/abstract/montgomery.js


  var require_montgomery = __commonJS({
    "node_modules/@noble/curves/abstract/montgomery.js": function node_modulesNobleCurvesAbstractMontgomeryJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.montgomery = montgomery;
      var utils_ts_1 = require_utils3();
      var modular_ts_1 = require_modular();

      var _0n = BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      function validateOpts(curve) {
        (0, utils_ts_1._validateObject)(curve, {
          adjustScalarBytes: "function",
          powPminus2: "function"
        });
        return Object.freeze(_extends({}, curve));
      }

      function montgomery(curveDef) {
        var CURVE = validateOpts(curveDef);
        var P = CURVE.P,
            type = CURVE.type,
            adjustScalarBytes = CURVE.adjustScalarBytes,
            powPminus2 = CURVE.powPminus2,
            rand = CURVE.randomBytes;
        var is25519 = type === "x25519";
        if (!is25519 && type !== "x448") throw new Error("invalid type");
        var randomBytes_ = rand || utils_ts_1.randomBytes;
        var montgomeryBits = is25519 ? 255 : 448;
        var fieldLen = is25519 ? 32 : 56;
        var Gu = is25519 ? BigInt(9) : BigInt(5);
        var a24 = is25519 ? BigInt(121665) : BigInt(39081);

        var pow = function pow(b, e) {
          var r = BigInt(1);

          for (var i = 0; i < e; i++) {
            r *= b;
          }

          return r;
        };

        var minScalar = is25519 ? pow(_2n, BigInt(254)) : pow(_2n, BigInt(447));
        var maxAdded = minScalar - _1n;
        var maxScalar = minScalar + maxAdded + _1n;

        var modP = function modP(n) {
          return (0, modular_ts_1.mod)(n, P);
        };

        var GuBytes = encodeU(Gu);

        function encodeU(u) {
          return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
        }

        function decodeU(u) {
          var _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);

          if (is25519) _u[31] &= 127;
          return modP((0, utils_ts_1.bytesToNumberLE)(_u));
        }

        function decodeScalar(scalar) {
          return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
        }

        function scalarMult(scalar, u) {
          var pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
          if (pu === _0n) throw new Error("invalid private or public key received");
          return encodeU(pu);
        }

        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }

        function cswap(swap, x_2, x_3) {
          var dummy = modP(swap * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return {
            x_2: x_2,
            x_3: x_3
          };
        }

        function montgomeryLadder(u, scalar) {
          (0, utils_ts_1.aInRange)("u", u, _0n, P);
          (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
          var k = scalar;
          var x_1 = u;
          var x_2 = _1n;
          var z_2 = _0n;
          var x_3 = u;
          var z_3 = _1n;
          var swap = _0n;

          for (var t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            var k_t = k >> t & _1n;
            swap ^= k_t;

            var _cswap = cswap(swap, x_2, x_3);

            x_2 = _cswap.x_2;
            x_3 = _cswap.x_3;

            var _cswap2 = cswap(swap, z_2, z_3);

            z_2 = _cswap2.x_2;
            z_3 = _cswap2.x_3;
            swap = k_t;
            var A = x_2 + z_2;
            var AA = modP(A * A);
            var B = x_2 - z_2;
            var BB = modP(B * B);
            var E = AA - BB;
            var C = x_3 + z_3;
            var D = x_3 - z_3;
            var DA = modP(D * A);
            var CB = modP(C * B);
            var dacb = DA + CB;
            var da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }

          var _cswap3 = cswap(swap, x_2, x_3);

          x_2 = _cswap3.x_2;
          x_3 = _cswap3.x_3;

          var _cswap4 = cswap(swap, z_2, z_3);

          z_2 = _cswap4.x_2;
          z_3 = _cswap4.x_3;
          var z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }

        var lengths = {
          secretKey: fieldLen,
          publicKey: fieldLen,
          seed: fieldLen
        };

        var randomSecretKey = function randomSecretKey(seed) {
          if (seed === void 0) {
            seed = randomBytes_(fieldLen);
          }

          (0, utils_ts_1.abytes)(seed, lengths.seed);
          return seed;
        };

        function keygen(seed) {
          var secretKey = randomSecretKey(seed);
          return {
            secretKey: secretKey,
            publicKey: scalarMultBase(secretKey)
          };
        }

        var utils = {
          randomSecretKey: randomSecretKey,
          randomPrivateKey: randomSecretKey
        };
        return {
          keygen: keygen,
          getSharedSecret: function getSharedSecret(secretKey, publicKey) {
            return scalarMult(secretKey, publicKey);
          },
          getPublicKey: function getPublicKey(secretKey) {
            return scalarMultBase(secretKey);
          },
          scalarMult: scalarMult,
          scalarMultBase: scalarMultBase,
          utils: utils,
          GuBytes: GuBytes.slice(),
          lengths: lengths
        };
      }
    }
  }); // node_modules/@noble/curves/ed25519.js


  var require_ed25519 = __commonJS({
    "node_modules/@noble/curves/ed25519.js": function node_modulesNobleCurvesEd25519Js(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
      exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var curve_ts_1 = require_curve();
      var edwards_ts_1 = require_edwards();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var montgomery_ts_1 = require_montgomery();
      var utils_ts_1 = require_utils3();

      var _0n = /* @__PURE__ */BigInt(0);

      var _1n = BigInt(1);

      var _2n = BigInt(2);

      var _3n = BigInt(3);

      var _5n = BigInt(5);

      var _8n = BigInt(8);

      var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");

      var ed25519_CURVE = /* @__PURE__ */function () {
        return {
          p: ed25519_CURVE_p,
          n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
          h: _8n,
          a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
          d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
          Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
          Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
        };
      }();

      function ed25519_pow_2_252_3(x) {
        var _10n = BigInt(10),
            _20n = BigInt(20),
            _40n = BigInt(40),
            _80n = BigInt(80);

        var P = ed25519_CURVE_p;
        var x2 = x * x % P;
        var b2 = x2 * x % P;
        var b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
        var b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
        var b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
        var b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
        var b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
        var b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
        var b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
        var b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
        var b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
        var pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
        return {
          pow_p_5_8: pow_p_5_8,
          b2: b2
        };
      }

      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }

      var ED25519_SQRT_M1 = /* @__PURE__ */BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");

      function uvRatio(u, v) {
        var P = ed25519_CURVE_p;
        var v3 = (0, modular_ts_1.mod)(v * v * v, P);
        var v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
        var pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        var x = (0, modular_ts_1.mod)(u * v3 * pow, P);
        var vx2 = (0, modular_ts_1.mod)(v * x * x, P);
        var root1 = x;
        var root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
        var useRoot1 = vx2 === u;
        var useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
        var noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1) x = root1;
        if (useRoot2 || noRoot) x = root2;
        if ((0, modular_ts_1.isNegativeLE)(x, P)) x = (0, modular_ts_1.mod)(-x, P);
        return {
          isValid: useRoot1 || useRoot2,
          value: x
        };
      }

      var Fp = /* @__PURE__ */function () {
        return (0, modular_ts_1.Field)(ed25519_CURVE.p, {
          isLE: true
        });
      }();

      var Fn = /* @__PURE__ */function () {
        return (0, modular_ts_1.Field)(ed25519_CURVE.n, {
          isLE: true
        });
      }();

      var ed25519Defaults = /* @__PURE__ */function () {
        return _extends({}, ed25519_CURVE, {
          Fp: Fp,
          hash: sha2_js_1.sha512,
          adjustScalarBytes: adjustScalarBytes,
          // dom2
          // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
          // Constant-time, u/v
          uvRatio: uvRatio
        });
      }();

      exports.ed25519 = function () {
        return (0, edwards_ts_1.twistedEdwards)(ed25519Defaults);
      }();

      function ed25519_domain(data, ctx, phflag) {
        if (ctx.length > 255) throw new Error("Context is too big");
        return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
      }

      exports.ed25519ctx = function () {
        return (0, edwards_ts_1.twistedEdwards)(_extends({}, ed25519Defaults, {
          domain: ed25519_domain
        }));
      }();

      exports.ed25519ph = function () {
        return (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
          domain: ed25519_domain,
          prehash: sha2_js_1.sha512
        }));
      }();

      exports.x25519 = function () {
        var P = Fp.ORDER;
        return (0, montgomery_ts_1.montgomery)({
          P: P,
          type: "x25519",
          powPminus2: function powPminus2(x) {
            var _ed25519_pow_2_252_ = ed25519_pow_2_252_3(x),
                pow_p_5_8 = _ed25519_pow_2_252_.pow_p_5_8,
                b2 = _ed25519_pow_2_252_.b2;

            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
          },
          adjustScalarBytes: adjustScalarBytes
        });
      }();

      var ELL2_C1 = /* @__PURE__ */function () {
        return (ed25519_CURVE_p + _3n) / _8n;
      }();

      var ELL2_C2 = /* @__PURE__ */function () {
        return Fp.pow(_2n, ELL2_C1);
      }();

      var ELL2_C3 = /* @__PURE__ */function () {
        return Fp.sqrt(Fp.neg(Fp.ONE));
      }();

      function map_to_curve_elligator2_curve25519(u) {
        var ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
        var ELL2_J = BigInt(486662);
        var tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        var xd = Fp.add(tv1, Fp.ONE);
        var x1n = Fp.neg(ELL2_J);
        var tv2 = Fp.sqr(xd);
        var gxd = Fp.mul(tv2, xd);
        var gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        var tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        var y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        var y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        var e1 = Fp.eql(tv2, gx1);
        var y1 = Fp.cmov(y12, y11, e1);
        var x2n = Fp.mul(x1n, tv1);
        var y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        var y22 = Fp.mul(y21, ELL2_C3);
        var gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        var e2 = Fp.eql(tv2, gx2);
        var y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        var e3 = Fp.eql(tv2, gx1);
        var xn = Fp.cmov(x2n, x1n, e3);
        var y = Fp.cmov(y2, y1, e3);
        var e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return {
          xMn: xn,
          xMd: xd,
          yMn: y,
          yMd: _1n
        };
      }

      var ELL2_C1_EDWARDS = /* @__PURE__ */function () {
        return (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664)));
      }();

      function map_to_curve_elligator2_edwards25519(u) {
        var _map_to_curve_elligat = map_to_curve_elligator2_curve25519(u),
            xMn = _map_to_curve_elligat.xMn,
            xMd = _map_to_curve_elligat.xMd,
            yMn = _map_to_curve_elligat.yMn,
            yMd = _map_to_curve_elligat.yMd;

        var xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        var xd = Fp.mul(xMd, yMn);
        var yn = Fp.sub(xMn, xMd);
        var yd = Fp.add(xMn, xMd);
        var tv1 = Fp.mul(xd, yd);
        var e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);

        var _ref106 = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true),
            xd_inv = _ref106[0],
            yd_inv = _ref106[1];

        return {
          x: Fp.mul(xn, xd_inv),
          y: Fp.mul(yn, yd_inv)
        };
      }

      exports.ed25519_hasher = function () {
        return (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, function (scalars) {
          return map_to_curve_elligator2_edwards25519(scalars[0]);
        }, {
          DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
          encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
          p: ed25519_CURVE_p,
          m: 1,
          k: 128,
          expand: "xmd",
          hash: sha2_js_1.sha512
        });
      }();

      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = /* @__PURE__ */BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = /* @__PURE__ */BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = /* @__PURE__ */BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = /* @__PURE__ */BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");

      var invertSqrt = function invertSqrt(number) {
        return uvRatio(_1n, number);
      };

      var MAX_255B = /* @__PURE__ */BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

      var bytes255ToNumberLE = function bytes255ToNumberLE(bytes) {
        return exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
      };

      function calcElligatorRistrettoMap(r0) {
        var d = ed25519_CURVE.d;
        var P = ed25519_CURVE_p;

        var mod = function mod(n) {
          return Fp.create(n);
        };

        var r = mod(SQRT_M1 * r0 * r0);
        var Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        var c = BigInt(-1);
        var D = mod((c - d * r) * mod(r + d));

        var _uvRatio2 = uvRatio(Ns, D),
            Ns_D_is_sq = _uvRatio2.isValid,
            s = _uvRatio2.value;

        var s_ = mod(s * r0);
        if (!(0, modular_ts_1.isNegativeLE)(s_, P)) s_ = mod(-s_);
        if (!Ns_D_is_sq) s = s_;
        if (!Ns_D_is_sq) c = r;
        var Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        var s2 = s * s;
        var W0 = mod((s + s) * D);
        var W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        var W2 = mod(_1n - s2);
        var W3 = mod(_1n + s2);
        return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }

      function ristretto255_map(bytes) {
        (0, utils_js_1.abytes)(bytes, 64);
        var r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
        var R1 = calcElligatorRistrettoMap(r1);
        var r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
        var R2 = calcElligatorRistrettoMap(r2);
        return new _RistrettoPoint(R1.add(R2));
      }

      var _RistrettoPoint = /*#__PURE__*/function (_edwards_ts_1$PrimeEd) {
        _inheritsLoose(__RistrettoPoint, _edwards_ts_1$PrimeEd);

        function __RistrettoPoint(ep) {
          return _edwards_ts_1$PrimeEd.call(this, ep) || this;
        }

        __RistrettoPoint.fromAffine = function fromAffine(ap) {
          return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
        };

        var _proto70 = __RistrettoPoint.prototype;

        _proto70.assertSame = function assertSame(other) {
          if (!(other instanceof __RistrettoPoint)) throw new Error("RistrettoPoint expected");
        };

        _proto70.init = function init(ep) {
          return new __RistrettoPoint(ep);
        }
        /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
        ;

        __RistrettoPoint.hashToCurve = function hashToCurve(hex) {
          return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64));
        };

        __RistrettoPoint.fromBytes = function fromBytes(bytes) {
          (0, utils_js_1.abytes)(bytes, 32);
          var a = ed25519_CURVE.a,
              d = ed25519_CURVE.d;
          var P = ed25519_CURVE_p;

          var mod = function mod(n) {
            return Fp.create(n);
          };

          var s = bytes255ToNumberLE(bytes);
          if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P)) throw new Error("invalid ristretto255 encoding 1");
          var s2 = mod(s * s);
          var u1 = mod(_1n + a * s2);
          var u2 = mod(_1n - a * s2);
          var u1_2 = mod(u1 * u1);
          var u2_2 = mod(u2 * u2);
          var v = mod(a * d * u1_2 - u2_2);

          var _invertSqrt = invertSqrt(mod(v * u2_2)),
              isValid = _invertSqrt.isValid,
              I = _invertSqrt.value;

          var Dx = mod(I * u2);
          var Dy = mod(I * Dx * v);
          var x = mod((s + s) * Dx);
          if ((0, modular_ts_1.isNegativeLE)(x, P)) x = mod(-x);
          var y = mod(u1 * Dy);
          var t = mod(x * y);
          if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n) throw new Error("invalid ristretto255 encoding 2");
          return new __RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        ;

        __RistrettoPoint.fromHex = function fromHex(hex) {
          return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32));
        };

        __RistrettoPoint.msm = function msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
         */
        ;

        _proto70.toBytes = function toBytes() {
          var _this$ep = this.ep,
              X = _this$ep.X,
              Y = _this$ep.Y,
              Z = _this$ep.Z,
              T = _this$ep.T;
          var P = ed25519_CURVE_p;

          var mod = function mod(n) {
            return Fp.create(n);
          };

          var u1 = mod(mod(Z + Y) * mod(Z - Y));
          var u2 = mod(X * Y);
          var u2sq = mod(u2 * u2);

          var _invertSqrt2 = invertSqrt(mod(u1 * u2sq)),
              invsqrt = _invertSqrt2.value;

          var D1 = mod(invsqrt * u1);
          var D2 = mod(invsqrt * u2);
          var zInv = mod(D1 * D2 * T);
          var D;

          if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            var _x = mod(Y * SQRT_M1);

            var _y = mod(X * SQRT_M1);

            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }

          if ((0, modular_ts_1.isNegativeLE)(X * zInv, P)) Y = mod(-Y);
          var s = mod((Z - Y) * D);
          if ((0, modular_ts_1.isNegativeLE)(s, P)) s = mod(-s);
          return Fp.toBytes(s);
        }
        /**
         * Compares two Ristretto points.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
         */
        ;

        _proto70.equals = function equals(other) {
          this.assertSame(other);
          var _this$ep2 = this.ep,
              X1 = _this$ep2.X,
              Y1 = _this$ep2.Y;
          var _other$ep = other.ep,
              X2 = _other$ep.X,
              Y2 = _other$ep.Y;

          var mod = function mod(n) {
            return Fp.create(n);
          };

          var one = mod(X1 * Y2) === mod(Y1 * X2);
          var two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        };

        _proto70.is0 = function is0() {
          return this.equals(__RistrettoPoint.ZERO);
        };

        return __RistrettoPoint;
      }(edwards_ts_1.PrimeEdwardsPoint);

      _RistrettoPoint.BASE = /* @__PURE__ */function () {
        return new _RistrettoPoint(exports.ed25519.Point.BASE);
      }();

      _RistrettoPoint.ZERO = /* @__PURE__ */function () {
        return new _RistrettoPoint(exports.ed25519.Point.ZERO);
      }();

      _RistrettoPoint.Fp = /* @__PURE__ */function () {
        return Fp;
      }();

      _RistrettoPoint.Fn = /* @__PURE__ */function () {
        return Fn;
      }();

      exports.ristretto255 = {
        Point: _RistrettoPoint
      };
      exports.ristretto255_hasher = {
        hashToCurve: function hashToCurve(msg, options) {
          var DST = (options == null ? void 0 : options.DST) || "ristretto255_XMD:SHA-512_R255MAP_RO_";
          var xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
          return ristretto255_map(xmd);
        },
        hashToScalar: function hashToScalar(msg, options) {
          if (options === void 0) {
            options = {
              DST: hash_to_curve_ts_1._DST_scalar
            };
          }

          var xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
        }
      };
      exports.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];

      function edwardsToMontgomeryPub(edwardsPub) {
        return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
      }

      exports.edwardsToMontgomery = edwardsToMontgomeryPub;

      function edwardsToMontgomeryPriv(edwardsPriv) {
        return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
      }

      exports.RistrettoPoint = _RistrettoPoint;

      exports.hashToCurve = function () {
        return exports.ed25519_hasher.hashToCurve;
      }();

      exports.encodeToCurve = function () {
        return exports.ed25519_hasher.encodeToCurve;
      }();

      exports.hashToRistretto255 = function () {
        return exports.ristretto255_hasher.hashToCurve;
      }();

      exports.hash_to_ristretto255 = function () {
        return exports.ristretto255_hasher.hashToCurve;
      }();
    }
  }); // node_modules/@dfinity/agent/lib/cjs/utils/expirableMap.js


  var require_expirableMap = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/utils/expirableMap.js": function node_modulesDfinityAgentLibCjsUtilsExpirableMapJs(exports) {
      "use strict";

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _ExpirableMap_inner;

      var _ExpirableMap_expirationTime;

      var _a;

      var _b;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExpirableMap = void 0;

      var ExpirableMap = /*#__PURE__*/function () {
        /**
         * Create a new ExpirableMap.
         * @param {ExpirableMapOptions<any, any>} options - options for the map.
         * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.
         * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.
         */
        function ExpirableMap(options) {
          if (options === void 0) {
            options = {};
          }

          _ExpirableMap_inner.set(this, void 0);

          _ExpirableMap_expirationTime.set(this, void 0);

          this[_a] = this.entries.bind(this);
          this[_b] = "ExpirableMap";
          var _options2 = options,
              _options2$source = _options2.source,
              source = _options2$source === void 0 ? [] : _options2$source,
              _options2$expirationT = _options2.expirationTime,
              expirationTime = _options2$expirationT === void 0 ? 10 * 60 * 1e3 : _options2$expirationT;
          var currentTime = Date.now();

          __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([].concat(source).map(function (_ref107) {
            var key = _ref107[0],
                value = _ref107[1];
            return [key, {
              value: value,
              timestamp: currentTime
            }];
          })), "f");

          __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, "f");
        }
        /**
         * Prune removes all expired entries.
         */


        var _proto71 = ExpirableMap.prototype;

        _proto71.prune = function prune() {
          var currentTime = Date.now();

          for (var _iterator24 = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()), _step24; !(_step24 = _iterator24()).done;) {
            var _step24$value = _step24.value,
                key = _step24$value[0],
                entry = _step24$value[1];

            if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
              __classPrivateFieldGet(this, _ExpirableMap_inner, "f")["delete"](key);
            }
          }

          return this;
        } // Implementing the Map interface

        /**
         * Set the value for the given key. Prunes expired entries.
         * @param key for the entry
         * @param value of the entry
         * @returns this
         */
        ;

        _proto71.set = function set(key, value) {
          this.prune();
          var entry = {
            value: value,
            timestamp: Date.now()
          };

          __classPrivateFieldGet(this, _ExpirableMap_inner, "f").set(key, entry);

          return this;
        }
        /**
         * Get the value associated with the key, if it exists and has not expired.
         * @param key K
         * @returns the value associated with the key, or undefined if the key is not present or has expired.
         */
        ;

        _proto71.get = function get(key) {
          var entry = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").get(key);

          if (entry === void 0) {
            return void 0;
          }

          if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
            __classPrivateFieldGet(this, _ExpirableMap_inner, "f")["delete"](key);

            return void 0;
          }

          return entry.value;
        }
        /**
         * Clear all entries.
         */
        ;

        _proto71.clear = function clear() {
          __classPrivateFieldGet(this, _ExpirableMap_inner, "f").clear();
        }
        /**
         * Entries returns the entries of the map, without the expiration time.
         * @returns an iterator over the entries of the map.
         */
        ;

        _proto71.entries = function entries() {
          var iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries();

          var generator = /*#__PURE__*/_regeneratorRuntime().mark(function generator() {
            var _iterator25, _step25, _step25$value, key, value;

            return _regeneratorRuntime().wrap(function generator$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _iterator25 = _createForOfIteratorHelperLoose(iterator);

                  case 1:
                    if ((_step25 = _iterator25()).done) {
                      _context13.next = 7;
                      break;
                    }

                    _step25$value = _step25.value, key = _step25$value[0], value = _step25$value[1];
                    _context13.next = 5;
                    return [key, value.value];

                  case 5:
                    _context13.next = 1;
                    break;

                  case 7:
                  case "end":
                    return _context13.stop();
                }
              }
            }, generator);
          });

          return generator();
        }
        /**
         * Values returns the values of the map, without the expiration time.
         * @returns an iterator over the values of the map.
         */
        ;

        _proto71.values = function values() {
          var iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").values();

          var generator = /*#__PURE__*/_regeneratorRuntime().mark(function generator() {
            var _iterator26, _step26, value;

            return _regeneratorRuntime().wrap(function generator$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _iterator26 = _createForOfIteratorHelperLoose(iterator);

                  case 1:
                    if ((_step26 = _iterator26()).done) {
                      _context14.next = 7;
                      break;
                    }

                    value = _step26.value;
                    _context14.next = 5;
                    return value.value;

                  case 5:
                    _context14.next = 1;
                    break;

                  case 7:
                  case "end":
                    return _context14.stop();
                }
              }
            }, generator);
          });

          return generator();
        }
        /**
         * Keys returns the keys of the map
         * @returns an iterator over the keys of the map.
         */
        ;

        _proto71.keys = function keys() {
          return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").keys();
        }
        /**
         * forEach calls the callbackfn on each entry of the map.
         * @param callbackfn to call on each entry
         * @param thisArg to use as this when calling the callbackfn
         */
        ;

        _proto71.forEach = function forEach(callbackfn, thisArg) {
          for (var _iterator27 = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()), _step27; !(_step27 = _iterator27()).done;) {
            var _step27$value = _step27.value,
                key = _step27$value[0],
                value = _step27$value[1];
            callbackfn.call(thisArg, value.value, key, this);
          }
        }
        /**
         * has returns true if the key exists and has not expired.
         * @param key K
         * @returns true if the key exists and has not expired.
         */
        ;

        _proto71.has = function has(key) {
          return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").has(key);
        }
        /**
         * delete the entry for the given key.
         * @param key K
         * @returns true if the key existed and has been deleted.
         */
        ;

        _proto71["delete"] = function _delete(key) {
          return __classPrivateFieldGet(this, _ExpirableMap_inner, "f")["delete"](key);
        }
        /**
         * get size of the map.
         * @returns the size of the map.
         */
        ;

        _createClass(ExpirableMap, [{
          key: "size",
          get: function get() {
            return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").size;
          }
        }]);

        return ExpirableMap;
      }();

      exports.ExpirableMap = ExpirableMap;
      _ExpirableMap_inner = /* @__PURE__ */new WeakMap(), _ExpirableMap_expirationTime = /* @__PURE__ */new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/der.js


  var require_der = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/der.js": function node_modulesDfinityAgentLibCjsDerJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unwrapDER = exports.wrapDER = exports.SECP256K1_OID = exports.ED25519_OID = exports.DER_COSE_OID = exports.decodeLen = exports.decodeLenBytes = exports.encodeLen = exports.encodeLenBytes = void 0;
      var buffer_1 = require_buffer2();

      var encodeLenBytes = function encodeLenBytes(len) {
        if (len <= 127) {
          return 1;
        } else if (len <= 255) {
          return 2;
        } else if (len <= 65535) {
          return 3;
        } else if (len <= 16777215) {
          return 4;
        } else {
          throw new Error("Length too long (> 4 bytes)");
        }
      };

      exports.encodeLenBytes = encodeLenBytes;

      var encodeLen = function encodeLen(buf, offset, len) {
        if (len <= 127) {
          buf[offset] = len;
          return 1;
        } else if (len <= 255) {
          buf[offset] = 129;
          buf[offset + 1] = len;
          return 2;
        } else if (len <= 65535) {
          buf[offset] = 130;
          buf[offset + 1] = len >> 8;
          buf[offset + 2] = len;
          return 3;
        } else if (len <= 16777215) {
          buf[offset] = 131;
          buf[offset + 1] = len >> 16;
          buf[offset + 2] = len >> 8;
          buf[offset + 3] = len;
          return 4;
        } else {
          throw new Error("Length too long (> 4 bytes)");
        }
      };

      exports.encodeLen = encodeLen;

      var decodeLenBytes = function decodeLenBytes(buf, offset) {
        if (buf[offset] < 128) return 1;
        if (buf[offset] === 128) throw new Error("Invalid length 0");
        if (buf[offset] === 129) return 2;
        if (buf[offset] === 130) return 3;
        if (buf[offset] === 131) return 4;
        throw new Error("Length too long (> 4 bytes)");
      };

      exports.decodeLenBytes = decodeLenBytes;

      var decodeLen = function decodeLen(buf, offset) {
        var lenBytes = (0, exports.decodeLenBytes)(buf, offset);
        if (lenBytes === 1) return buf[offset];else if (lenBytes === 2) return buf[offset + 1];else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];else if (lenBytes === 4) return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
        throw new Error("Length too long (> 4 bytes)");
      };

      exports.decodeLen = decodeLen;
      exports.DER_COSE_OID = Uint8Array.from([48, 12].concat([6, 10], [43, 6, 1, 4, 1, 131, 184, 67, 1, 1]));
      exports.ED25519_OID = Uint8Array.from([48, 5].concat([6, 3], [43, 101, 112]));
      exports.SECP256K1_OID = Uint8Array.from([48, 16].concat([6, 7], [42, 134, 72, 206, 61, 2, 1], [6, 5], [43, 129, 4, 0, 10]));

      function wrapDER(payload, oid) {
        var bitStringHeaderLength = 2 + (0, exports.encodeLenBytes)(payload.byteLength + 1);
        var len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
        var offset = 0;
        var buf = new Uint8Array(1 + (0, exports.encodeLenBytes)(len) + len);
        buf[offset++] = 48;
        offset += (0, exports.encodeLen)(buf, offset, len);
        buf.set(oid, offset);
        offset += oid.byteLength;
        buf[offset++] = 3;
        offset += (0, exports.encodeLen)(buf, offset, payload.byteLength + 1);
        buf[offset++] = 0;
        buf.set(new Uint8Array(payload), offset);
        return buf;
      }

      exports.wrapDER = wrapDER;

      var unwrapDER = function unwrapDER(derEncoded, oid) {
        var offset = 0;

        var expect = function expect(n, msg) {
          if (buf[offset++] !== n) {
            throw new Error("Expected: " + msg);
          }
        };

        var buf = new Uint8Array(derEncoded);
        expect(48, "sequence");
        offset += (0, exports.decodeLenBytes)(buf, offset);

        if (!(0, buffer_1.bufEquals)(buf.slice(offset, offset + oid.byteLength), oid)) {
          throw new Error("Not the expected OID.");
        }

        offset += oid.byteLength;
        expect(3, "bit string");
        var payloadLen = (0, exports.decodeLen)(buf, offset) - 1;
        offset += (0, exports.decodeLenBytes)(buf, offset);
        expect(0, "0 padding");
        var result = buf.slice(offset);

        if (payloadLen !== result.length) {
          throw new Error("DER payload mismatch: Expected length " + payloadLen + " actual length " + result.length);
        }

        return result;
      };

      exports.unwrapDER = unwrapDER;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/public_key.js


  var require_public_key = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/public_key.js": function node_modulesDfinityAgentLibCjsPublic_keyJs(exports) {
      "use strict";

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _Ed25519PublicKey_rawKey;

      var _Ed25519PublicKey_derKey;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Ed25519PublicKey = void 0;
      var der_1 = require_der();

      var Ed25519PublicKey = /*#__PURE__*/function () {
        // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
        function _Ed25519PublicKey(key) {
          _Ed25519PublicKey_rawKey.set(this, void 0);

          _Ed25519PublicKey_derKey.set(this, void 0);

          if (key.byteLength !== _Ed25519PublicKey.RAW_KEY_LENGTH) {
            throw new Error("An Ed25519 public key must be exactly 32bytes long");
          }

          __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, "f");

          __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, _Ed25519PublicKey.derEncode(key), "f");
        }

        _Ed25519PublicKey.from = function from(key) {
          return this.fromDer(key.toDer());
        };

        _Ed25519PublicKey.fromRaw = function fromRaw(rawKey) {
          return new _Ed25519PublicKey(rawKey);
        };

        _Ed25519PublicKey.fromDer = function fromDer(derKey) {
          return new _Ed25519PublicKey(this.derDecode(derKey));
        };

        _Ed25519PublicKey.derEncode = function derEncode(publicKey) {
          return (0, der_1.wrapDER)(publicKey, der_1.ED25519_OID).buffer;
        };

        _Ed25519PublicKey.derDecode = function derDecode(key) {
          var unwrapped = (0, der_1.unwrapDER)(key, der_1.ED25519_OID);

          if (unwrapped.length !== this.RAW_KEY_LENGTH) {
            throw new Error("An Ed25519 public key must be exactly 32bytes long");
          }

          return unwrapped;
        };

        var _proto72 = _Ed25519PublicKey.prototype;

        _proto72.toDer = function toDer() {
          return this.derKey;
        };

        _proto72.toRaw = function toRaw() {
          return this.rawKey;
        };

        _createClass(_Ed25519PublicKey, [{
          key: "rawKey",
          get: function get() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
          }
        }, {
          key: "derKey",
          get: function get() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
          }
        }]);

        return _Ed25519PublicKey;
      }();

      exports.Ed25519PublicKey = Ed25519PublicKey;
      _Ed25519PublicKey_rawKey = /* @__PURE__ */new WeakMap(), _Ed25519PublicKey_derKey = /* @__PURE__ */new WeakMap();
      Ed25519PublicKey.RAW_KEY_LENGTH = 32;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/observable.js


  var require_observable = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/observable.js": function node_modulesDfinityAgentLibCjsObservableJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ObservableLog = exports.Observable = void 0;

      var Observable = /*#__PURE__*/function () {
        function Observable() {
          this.observers = [];
        }

        var _proto73 = Observable.prototype;

        _proto73.subscribe = function subscribe(func) {
          this.observers.push(func);
        };

        _proto73.unsubscribe = function unsubscribe(func) {
          this.observers = this.observers.filter(function (observer) {
            return observer !== func;
          });
        };

        _proto73.notify = function notify(data) {
          for (var _len11 = arguments.length, rest = new Array(_len11 > 1 ? _len11 - 1 : 0), _key13 = 1; _key13 < _len11; _key13++) {
            rest[_key13 - 1] = arguments[_key13];
          }

          this.observers.forEach(function (observer) {
            return observer.apply(void 0, [data].concat(rest));
          });
        };

        return Observable;
      }();

      exports.Observable = Observable;

      var ObservableLog = /*#__PURE__*/function (_Observable) {
        _inheritsLoose(ObservableLog, _Observable);

        function ObservableLog() {
          return _Observable.call(this) || this;
        }

        var _proto74 = ObservableLog.prototype;

        _proto74.print = function print(message) {
          for (var _len12 = arguments.length, rest = new Array(_len12 > 1 ? _len12 - 1 : 0), _key14 = 1; _key14 < _len12; _key14++) {
            rest[_key14 - 1] = arguments[_key14];
          }

          this.notify.apply(this, [{
            message: message,
            level: "info"
          }].concat(rest));
        };

        _proto74.warn = function warn(message) {
          for (var _len13 = arguments.length, rest = new Array(_len13 > 1 ? _len13 - 1 : 0), _key15 = 1; _key15 < _len13; _key15++) {
            rest[_key15 - 1] = arguments[_key15];
          }

          this.notify.apply(this, [{
            message: message,
            level: "warn"
          }].concat(rest));
        };

        _proto74.error = function error(message, _error) {
          for (var _len14 = arguments.length, rest = new Array(_len14 > 2 ? _len14 - 2 : 0), _key16 = 2; _key16 < _len14; _key16++) {
            rest[_key16 - 2] = arguments[_key16];
          }

          this.notify.apply(this, [{
            message: message,
            level: "error",
            error: _error
          }].concat(rest));
        };

        return ObservableLog;
      }(Observable);

      exports.ObservableLog = ObservableLog;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/polling/backoff.js


  var require_backoff = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/polling/backoff.js": function node_modulesDfinityAgentLibCjsPollingBackoffJs(exports) {
      "use strict";

      var _marked = /*#__PURE__*/_regeneratorRuntime().mark(exponentialBackoff);

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _ExponentialBackoff_currentInterval;

      var _ExponentialBackoff_randomizationFactor;

      var _ExponentialBackoff_multiplier;

      var _ExponentialBackoff_maxInterval;

      var _ExponentialBackoff_startTime;

      var _ExponentialBackoff_maxElapsedTime;

      var _ExponentialBackoff_maxIterations;

      var _ExponentialBackoff_date;

      var _ExponentialBackoff_count;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.exponentialBackoff = exports.ExponentialBackoff = void 0;
      var RANDOMIZATION_FACTOR = 0.5;
      var MULTIPLIER = 1.5;
      var INITIAL_INTERVAL_MSEC = 500;
      var MAX_INTERVAL_MSEC = 6e4;
      var MAX_ELAPSED_TIME_MSEC = 9e5;
      var MAX_ITERATIONS = 10;

      var ExponentialBackoff = /*#__PURE__*/function () {
        function _ExponentialBackoff(options) {
          if (options === void 0) {
            options = _ExponentialBackoff["default"];
          }

          _ExponentialBackoff_currentInterval.set(this, void 0);

          _ExponentialBackoff_randomizationFactor.set(this, void 0);

          _ExponentialBackoff_multiplier.set(this, void 0);

          _ExponentialBackoff_maxInterval.set(this, void 0);

          _ExponentialBackoff_startTime.set(this, void 0);

          _ExponentialBackoff_maxElapsedTime.set(this, void 0);

          _ExponentialBackoff_maxIterations.set(this, void 0);

          _ExponentialBackoff_date.set(this, void 0);

          _ExponentialBackoff_count.set(this, 0);

          var _options3 = options,
              _options3$initialInte = _options3.initialInterval,
              initialInterval = _options3$initialInte === void 0 ? INITIAL_INTERVAL_MSEC : _options3$initialInte,
              _options3$randomizati = _options3.randomizationFactor,
              randomizationFactor = _options3$randomizati === void 0 ? RANDOMIZATION_FACTOR : _options3$randomizati,
              _options3$multiplier = _options3.multiplier,
              multiplier = _options3$multiplier === void 0 ? MULTIPLIER : _options3$multiplier,
              _options3$maxInterval = _options3.maxInterval,
              maxInterval = _options3$maxInterval === void 0 ? MAX_INTERVAL_MSEC : _options3$maxInterval,
              _options3$maxElapsedT = _options3.maxElapsedTime,
              maxElapsedTime = _options3$maxElapsedT === void 0 ? MAX_ELAPSED_TIME_MSEC : _options3$maxElapsedT,
              _options3$maxIteratio = _options3.maxIterations,
              maxIterations = _options3$maxIteratio === void 0 ? MAX_ITERATIONS : _options3$maxIteratio,
              _options3$date = _options3.date,
              date = _options3$date === void 0 ? Date : _options3$date;

          __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, initialInterval, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_randomizationFactor, randomizationFactor, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_multiplier, multiplier, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_maxInterval, maxInterval, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_date, date, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_startTime, date.now(), "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_maxElapsedTime, maxElapsedTime, "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_maxIterations, maxIterations, "f");
        }

        var _proto75 = _ExponentialBackoff.prototype;

        _proto75.incrementCurrentInterval = function incrementCurrentInterval() {
          var _a;

          __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, Math.min(__classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") * __classPrivateFieldGet(this, _ExponentialBackoff_multiplier, "f"), __classPrivateFieldGet(this, _ExponentialBackoff_maxInterval, "f")), "f");

          __classPrivateFieldSet(this, _ExponentialBackoff_count, (_a = __classPrivateFieldGet(this, _ExponentialBackoff_count, "f"), _a++, _a), "f");

          return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");
        };

        _proto75.next = function next() {
          if (this.ellapsedTimeInMsec >= __classPrivateFieldGet(this, _ExponentialBackoff_maxElapsedTime, "f") || __classPrivateFieldGet(this, _ExponentialBackoff_count, "f") >= __classPrivateFieldGet(this, _ExponentialBackoff_maxIterations, "f")) {
            return null;
          } else {
            this.incrementCurrentInterval();
            return this.randomValueFromInterval;
          }
        };

        _createClass(_ExponentialBackoff, [{
          key: "ellapsedTimeInMsec",
          get: function get() {
            return __classPrivateFieldGet(this, _ExponentialBackoff_date, "f").now() - __classPrivateFieldGet(this, _ExponentialBackoff_startTime, "f");
          }
        }, {
          key: "currentInterval",
          get: function get() {
            return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");
          }
        }, {
          key: "count",
          get: function get() {
            return __classPrivateFieldGet(this, _ExponentialBackoff_count, "f");
          }
        }, {
          key: "randomValueFromInterval",
          get: function get() {
            var delta = __classPrivateFieldGet(this, _ExponentialBackoff_randomizationFactor, "f") * __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");

            var min = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") - delta;
            var max = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") + delta;
            return Math.random() * (max - min) + min;
          }
        }]);

        return _ExponentialBackoff;
      }();

      exports.ExponentialBackoff = ExponentialBackoff;
      _ExponentialBackoff_currentInterval = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_randomizationFactor = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_multiplier = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_maxInterval = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_startTime = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_maxElapsedTime = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_maxIterations = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_date = /* @__PURE__ */new WeakMap(), _ExponentialBackoff_count = /* @__PURE__ */new WeakMap();
      ExponentialBackoff["default"] = {
        initialInterval: INITIAL_INTERVAL_MSEC,
        randomizationFactor: RANDOMIZATION_FACTOR,
        multiplier: MULTIPLIER,
        maxInterval: MAX_INTERVAL_MSEC,
        // 1 minute
        maxElapsedTime: MAX_ELAPSED_TIME_MSEC,
        maxIterations: MAX_ITERATIONS,
        date: Date
      };

      function exponentialBackoff(options) {
        var backoff, next;
        return _regeneratorRuntime().wrap(function exponentialBackoff$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (options === void 0) {
                  options = ExponentialBackoff["default"];
                }

                backoff = new ExponentialBackoff(options);
                next = backoff.next();

              case 3:
                if (!next) {
                  _context15.next = 9;
                  break;
                }

                _context15.next = 6;
                return next;

              case 6:
                next = backoff.next();
                _context15.next = 3;
                break;

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _marked);
      }

      exports.exponentialBackoff = exponentialBackoff;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/http/index.js


  var require_http = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/http/index.js": function node_modulesDfinityAgentLibCjsAgentHttpIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _HttpAgent_instances;

      var _HttpAgent_rootKeyPromise;

      var _HttpAgent_shouldFetchRootKey;

      var _HttpAgent_identity;

      var _HttpAgent_fetch;

      var _HttpAgent_fetchOptions;

      var _HttpAgent_callOptions;

      var _HttpAgent_timeDiffMsecs;

      var _HttpAgent_credentials;

      var _HttpAgent_retryTimes;

      var _HttpAgent_backoffStrategy;

      var _HttpAgent_maxIngressExpiryInMinutes;

      var _HttpAgent_waterMark;

      var _HttpAgent_queryPipeline;

      var _HttpAgent_updatePipeline;

      var _HttpAgent_subnetKeys;

      var _HttpAgent_verifyQuerySignatures;

      var _HttpAgent_requestAndRetryQuery;

      var _HttpAgent_requestAndRetry;

      var _HttpAgent_verifyQueryResponse;

      var _HttpAgent_rootKeyGuard;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.HttpAgent = exports.IdentityInvalidError = exports.MANAGEMENT_CANISTER_ID = exports.IC_ROOT_KEY = exports.RequestStatusResponseStatus = exports.makeNonce = void 0;
      var principal_1 = require_cjs();
      var errors_1 = require_errors();
      var auth_1 = require_auth();

      var cbor = __importStar(require_cbor());

      var request_id_1 = require_request_id();
      var buffer_1 = require_buffer2();
      var transforms_1 = require_transforms();
      var types_1 = require_types2();
      var errors_2 = require_errors2();
      var canisterStatus_1 = require_canisterStatus();
      var certificate_1 = require_certificate();
      var ed25519_1 = require_ed25519();
      var expirableMap_1 = require_expirableMap();
      var public_key_1 = require_public_key();
      var leb_1 = require_leb();
      var observable_1 = require_observable();
      var backoff_1 = require_backoff();

      __exportStar(require_transforms(), exports);

      __exportStar(require_errors2(), exports);

      var types_2 = require_types2();
      Object.defineProperty(exports, "makeNonce", {
        enumerable: true,
        get: function get() {
          return types_2.makeNonce;
        }
      });
      var RequestStatusResponseStatus;

      (function (RequestStatusResponseStatus2) {
        RequestStatusResponseStatus2["Received"] = "received";
        RequestStatusResponseStatus2["Processing"] = "processing";
        RequestStatusResponseStatus2["Replied"] = "replied";
        RequestStatusResponseStatus2["Rejected"] = "rejected";
        RequestStatusResponseStatus2["Unknown"] = "unknown";
        RequestStatusResponseStatus2["Done"] = "done";
      })(RequestStatusResponseStatus = exports.RequestStatusResponseStatus || (exports.RequestStatusResponseStatus = {}));

      var MINUTE_TO_MSECS = 60 * 1e3;
      exports.IC_ROOT_KEY = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
      exports.MANAGEMENT_CANISTER_ID = "aaaaa-aa";
      var IC0_DOMAIN = "ic0.app";
      var IC0_SUB_DOMAIN = ".ic0.app";
      var ICP0_DOMAIN = "icp0.io";
      var ICP0_SUB_DOMAIN = ".icp0.io";
      var ICP_API_DOMAIN = "icp-api.io";
      var ICP_API_SUB_DOMAIN = ".icp-api.io";

      var HttpDefaultFetchError = /*#__PURE__*/function (_errors_1$AgentError6) {
        _inheritsLoose(HttpDefaultFetchError, _errors_1$AgentError6);

        function HttpDefaultFetchError(message) {
          var _this48;

          _this48 = _errors_1$AgentError6.call(this, message) || this;
          _this48.message = message;
          return _this48;
        }

        return HttpDefaultFetchError;
      }(errors_1.AgentError);

      var IdentityInvalidError = /*#__PURE__*/function (_errors_1$AgentError7) {
        _inheritsLoose(IdentityInvalidError, _errors_1$AgentError7);

        function IdentityInvalidError(message) {
          var _this49;

          _this49 = _errors_1$AgentError7.call(this, message) || this;
          _this49.message = message;
          return _this49;
        }

        return IdentityInvalidError;
      }(errors_1.AgentError);

      exports.IdentityInvalidError = IdentityInvalidError;

      function getDefaultFetch() {
        var defaultFetch;

        if (typeof window !== "undefined") {
          if (window.fetch) {
            defaultFetch = window.fetch.bind(window);
          } else {
            throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
          }
        } else if (typeof global !== "undefined") {
          if (global.fetch) {
            defaultFetch = global.fetch.bind(global);
          } else {
            throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
          }
        } else if (typeof self !== "undefined") {
          if (self.fetch) {
            defaultFetch = self.fetch.bind(self);
          }
        }

        if (defaultFetch) {
          return defaultFetch;
        }

        throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
      }

      function determineHost(configuredHost) {
        var host;

        if (configuredHost !== void 0) {
          if (!configuredHost.match(/^[a-z]+:/) && typeof window !== "undefined") {
            host = new URL(window.location.protocol + "//" + configuredHost);
          } else {
            host = new URL(configuredHost);
          }
        } else {
          var knownHosts = ["ic0.app", "icp0.io", "127.0.0.1", "localhost"];
          var remoteHosts = [".github.dev", ".gitpod.io"];
          var location2 = typeof window !== "undefined" ? window.location : void 0;
          var hostname = location2 === null || location2 === void 0 ? void 0 : location2.hostname;
          var knownHost;

          if (hostname && typeof hostname === "string") {
            if (remoteHosts.some(function (host2) {
              return hostname.endsWith(host2);
            })) {
              knownHost = hostname;
            } else {
              knownHost = knownHosts.find(function (host2) {
                return hostname.endsWith(host2);
              });
            }
          }

          if (location2 && knownHost) {
            host = new URL(location2.protocol + "//" + knownHost + (location2.port ? ":" + location2.port : ""));
          } else {
            host = new URL("https://icp-api.io");
          }
        }

        return host.toString();
      }

      var HttpAgent = /*#__PURE__*/function () {
        /**
         * @param options - Options for the HttpAgent
         * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead
         */
        function _HttpAgent(options) {
          var _this50 = this;

          if (options === void 0) {
            options = {};
          }

          var _a, _b;

          _HttpAgent_instances.add(this);

          _HttpAgent_rootKeyPromise.set(this, null);

          _HttpAgent_shouldFetchRootKey.set(this, false);

          _HttpAgent_identity.set(this, void 0);

          _HttpAgent_fetch.set(this, void 0);

          _HttpAgent_fetchOptions.set(this, void 0);

          _HttpAgent_callOptions.set(this, void 0);

          _HttpAgent_timeDiffMsecs.set(this, 0);

          _HttpAgent_credentials.set(this, void 0);

          _HttpAgent_retryTimes.set(this, void 0);

          _HttpAgent_backoffStrategy.set(this, void 0);

          _HttpAgent_maxIngressExpiryInMinutes.set(this, void 0);

          this._isAgent = true;
          this.config = {};

          _HttpAgent_waterMark.set(this, 0);

          this.log = new observable_1.ObservableLog();

          _HttpAgent_queryPipeline.set(this, []);

          _HttpAgent_updatePipeline.set(this, []);

          _HttpAgent_subnetKeys.set(this, new expirableMap_1.ExpirableMap({
            expirationTime: 5 * 60 * 1e3 // 5 minutes

          }));

          _HttpAgent_verifyQuerySignatures.set(this, true);

          _HttpAgent_verifyQueryResponse.set(this, function (queryResponse, subnetStatus) {
            if (__classPrivateFieldGet(_this50, _HttpAgent_verifyQuerySignatures, "f") === false) {
              return queryResponse;
            }

            if (!subnetStatus) {
              throw new certificate_1.CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");
            }

            var status = queryResponse.status,
                _queryResponse$signat = queryResponse.signatures,
                signatures = _queryResponse$signat === void 0 ? [] : _queryResponse$signat,
                requestId = queryResponse.requestId;
            var domainSeparator = (0, buffer_1.bufFromBufLike)(new TextEncoder().encode("\vic-response"));

            for (var _iterator28 = _createForOfIteratorHelperLoose(signatures), _step28; !(_step28 = _iterator28()).done;) {
              var sig = _step28.value;
              var timestamp = sig.timestamp,
                  identity = sig.identity;
              var nodeId = principal_1.Principal.fromUint8Array(identity).toText();
              var hash = void 0;

              if (status === "replied") {
                var reply = queryResponse.reply;
                hash = (0, request_id_1.hashOfMap)({
                  status: status,
                  reply: reply,
                  timestamp: BigInt(timestamp),
                  request_id: requestId
                });
              } else if (status === "rejected") {
                var reject_code = queryResponse.reject_code,
                    reject_message = queryResponse.reject_message,
                    error_code = queryResponse.error_code;
                hash = (0, request_id_1.hashOfMap)({
                  status: status,
                  reject_code: reject_code,
                  reject_message: reject_message,
                  error_code: error_code,
                  timestamp: BigInt(timestamp),
                  request_id: requestId
                });
              } else {
                throw new Error("Unknown status: " + status);
              }

              var separatorWithHash = (0, buffer_1.concat)(domainSeparator, (0, buffer_1.bufFromBufLike)(new Uint8Array(hash)));
              var pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);

              if (!pubKey) {
                throw new certificate_1.CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");
              }

              var rawKey = public_key_1.Ed25519PublicKey.fromDer(pubKey).rawKey;
              var valid = ed25519_1.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));
              if (valid) return queryResponse;
              throw new certificate_1.CertificateVerificationError("Invalid signature from replica " + nodeId + " signed query.");
            }

            return queryResponse;
          });

          this.config = options;

          __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(global), "f");

          __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, "f");

          __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, "f");

          __classPrivateFieldSet(this, _HttpAgent_shouldFetchRootKey, (_a = options.shouldFetchRootKey) !== null && _a !== void 0 ? _a : false, "f");

          if (options.rootKey) {
            this.rootKey = options.rootKey;
          } else if (__classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f")) {
            this.rootKey = null;
          } else {
            this.rootKey = (0, buffer_1.fromHex)(exports.IC_ROOT_KEY);
          }

          var host = determineHost(options.host);
          this.host = new URL(host);

          if (options.verifyQuerySignatures !== void 0) {
            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, "f");
          }

          __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_b = options.retryTimes) !== null && _b !== void 0 ? _b : 3, "f");

          var defaultBackoffFactory = function defaultBackoffFactory() {
            return new backoff_1.ExponentialBackoff({
              maxIterations: __classPrivateFieldGet(_this50, _HttpAgent_retryTimes, "f")
            });
          };

          __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, "f");

          if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {
            this.host.hostname = IC0_DOMAIN;
          } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
            this.host.hostname = ICP0_DOMAIN;
          } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
            this.host.hostname = ICP_API_DOMAIN;
          }

          if (options.credentials) {
            var _options$credentials = options.credentials,
                name = _options$credentials.name,
                password = _options$credentials.password;

            __classPrivateFieldSet(this, _HttpAgent_credentials, "" + name + (password ? ":" + password : ""), "f");
          }

          __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new auth_1.AnonymousIdentity()), "f");

          if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {
            throw new errors_1.AgentError("The maximum ingress expiry time is 5 minutes. Provided ingress expiry time is " + options.ingressExpiryInMinutes + " minutes.");
          }

          if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {
            throw new errors_1.AgentError("Ingress expiry time must be greater than 0. Provided ingress expiry time is " + options.ingressExpiryInMinutes + " minutes.");
          }

          __classPrivateFieldSet(this, _HttpAgent_maxIngressExpiryInMinutes, options.ingressExpiryInMinutes || 5, "f");

          this.addTransform("update", (0, transforms_1.makeNonceTransform)(types_1.makeNonce));

          if (options.useQueryNonces) {
            this.addTransform("query", (0, transforms_1.makeNonceTransform)(types_1.makeNonce));
          }

          if (options.logToConsole) {
            this.log.subscribe(function (log) {
              if (log.level === "error") {
                console.error(log.message);
              } else if (log.level === "warn") {
                console.warn(log.message);
              } else {
                console.log(log.message);
              }
            });
          }
        }

        _HttpAgent.createSync = function createSync(options) {
          if (options === void 0) {
            options = {};
          }

          return new this(Object.assign({}, options));
        };

        _HttpAgent.create = /*#__PURE__*/function () {
          var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {
            var agent, initPromises;
            return _regeneratorRuntime().wrap(function _callee13$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    if (options === void 0) {
                      options = {
                        shouldFetchRootKey: false
                      };
                    }

                    agent = _HttpAgent.createSync(options);
                    initPromises = [agent.syncTime()];

                    if (agent.host.toString() !== "https://icp-api.io" && options.shouldFetchRootKey) {
                      initPromises.push(agent.fetchRootKey());
                    }

                    _context16.next = 6;
                    return Promise.all(initPromises);

                  case 6:
                    return _context16.abrupt("return", agent);

                  case 7:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee13);
          }));

          function create(_x15) {
            return _create2.apply(this, arguments);
          }

          return create;
        }();

        _HttpAgent.from = /*#__PURE__*/function () {
          var _from = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(agent) {
            var _a;

            return _regeneratorRuntime().wrap(function _callee14$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _context17.prev = 0;

                    if (!("config" in agent)) {
                      _context17.next = 5;
                      break;
                    }

                    _context17.next = 4;
                    return _HttpAgent.create(agent.config);

                  case 4:
                    return _context17.abrupt("return", _context17.sent);

                  case 5:
                    _context17.next = 7;
                    return _HttpAgent.create({
                      fetch: agent._fetch,
                      fetchOptions: agent._fetchOptions,
                      callOptions: agent._callOptions,
                      host: agent._host.toString(),
                      identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : void 0
                    });

                  case 7:
                    return _context17.abrupt("return", _context17.sent);

                  case 10:
                    _context17.prev = 10;
                    _context17.t0 = _context17["catch"](0);
                    throw new errors_1.AgentError("Failed to create agent from provided agent");

                  case 13:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee14, null, [[0, 10]]);
          }));

          function from(_x16) {
            return _from.apply(this, arguments);
          }

          return from;
        }();

        var _proto76 = _HttpAgent.prototype;

        _proto76.isLocal = function isLocal() {
          var hostname = this.host.hostname;
          return hostname === "127.0.0.1" || hostname.endsWith("127.0.0.1");
        };

        _proto76.addTransform = function addTransform(type, fn, priority) {
          if (priority === void 0) {
            priority = fn.priority || 0;
          }

          if (type === "update") {
            var i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").findIndex(function (x) {
              return (x.priority || 0) < priority;
            });

            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").length, 0, Object.assign(fn, {
              priority: priority
            }));
          } else if (type === "query") {
            var _i17 = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").findIndex(function (x) {
              return (x.priority || 0) < priority;
            });

            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").splice(_i17 >= 0 ? _i17 : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").length, 0, Object.assign(fn, {
              priority: priority
            }));
          }
        };

        _proto76.getPrincipal = /*#__PURE__*/function () {
          var _getPrincipal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
            return _regeneratorRuntime().wrap(function _callee15$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    if (__classPrivateFieldGet(this, _HttpAgent_identity, "f")) {
                      _context18.next = 2;
                      break;
                    }

                    throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");

                  case 2:
                    _context18.next = 4;
                    return __classPrivateFieldGet(this, _HttpAgent_identity, "f");

                  case 4:
                    return _context18.abrupt("return", _context18.sent.getPrincipal());

                  case 5:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee15, this);
          }));

          function getPrincipal() {
            return _getPrincipal.apply(this, arguments);
          }

          return getPrincipal;
        }()
        /**
         * Makes a call to a canister method.
         * @param canisterId - The ID of the canister to call. Can be a Principal or a string.
         * @param options - Options for the call.
         * @param options.methodName - The name of the method to call.
         * @param options.arg - The argument to pass to the method, as an ArrayBuffer.
         * @param options.effectiveCanisterId - (Optional) The effective canister ID, if different from the target canister ID.
         * @param options.callSync - (Optional) Whether to use synchronous call mode. Defaults to true.
         * @param options.nonce - (Optional) A unique nonce for the request. If provided, it will override any nonce set by transforms.
         * @param identity - (Optional) The identity to use for the call. If not provided, the agent's current identity will be used.
         * @returns A promise that resolves to the response of the call, including the request ID and response details.
         */
        ;

        _proto76.call =
        /*#__PURE__*/
        function () {
          var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(canisterId, options, identity) {
            var _this51 = this;

            var _a, _b, callSync, id, canister, ecid, sender, ingress_expiry, submit, transformedRequest, nonce, toNonce, body, backoff, requestId, requestSync, requestAsync, request, response, responseBuffer, responseBody, time, message, callError;

            return _regeneratorRuntime().wrap(function _callee16$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    toNonce = function _toNonce(buf) {
                      return new Uint8Array(buf);
                    };

                    _context19.next = 3;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 3:
                    callSync = (_a = options.callSync) !== null && _a !== void 0 ? _a : true;

                    if (!(identity !== void 0)) {
                      _context19.next = 10;
                      break;
                    }

                    _context19.next = 7;
                    return identity;

                  case 7:
                    _context19.t0 = _context19.sent;
                    _context19.next = 13;
                    break;

                  case 10:
                    _context19.next = 12;
                    return __classPrivateFieldGet(this, _HttpAgent_identity, "f");

                  case 12:
                    _context19.t0 = _context19.sent;

                  case 13:
                    _context19.next = 15;
                    return _context19.t0;

                  case 15:
                    id = _context19.sent;

                    if (id) {
                      _context19.next = 18;
                      break;
                    }

                    throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");

                  case 18:
                    canister = principal_1.Principal.from(canisterId);
                    ecid = options.effectiveCanisterId ? principal_1.Principal.from(options.effectiveCanisterId) : canister;
                    sender = id.getPrincipal() || principal_1.Principal.anonymous();
                    ingress_expiry = new transforms_1.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS);

                    if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f")) > 1e3 * 30) {
                      ingress_expiry = new transforms_1.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f"));
                    }

                    submit = {
                      request_type: types_1.SubmitRequestType.Call,
                      canister_id: canister,
                      method_name: options.methodName,
                      arg: options.arg,
                      sender: sender,
                      ingress_expiry: ingress_expiry
                    };
                    _context19.next = 26;
                    return this._transform({
                      request: {
                        body: null,
                        method: "POST",
                        headers: Object.assign({
                          "Content-Type": "application/cbor"
                        }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                          Authorization: "Basic " + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                        } : {})
                      },
                      endpoint: "call",
                      body: submit
                    });

                  case 26:
                    transformedRequest = _context19.sent;

                    if (options === null || options === void 0 ? void 0 : options.nonce) {
                      nonce = toNonce(options.nonce);
                    } else if (transformedRequest.body.nonce) {
                      nonce = toNonce(transformedRequest.body.nonce);
                    } else {
                      nonce = void 0;
                    }

                    submit.nonce = nonce;
                    _context19.next = 31;
                    return id.transformRequest(transformedRequest);

                  case 31:
                    transformedRequest = _context19.sent;
                    body = cbor.encode(transformedRequest.body);
                    backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
                    requestId = (0, request_id_1.requestIdOf)(submit);
                    _context19.prev = 35;

                    requestSync = function requestSync() {
                      _this51.log.print("fetching \"/api/v3/canister/" + ecid.toText() + "/call\" with request:", transformedRequest);

                      return __classPrivateFieldGet(_this51, _HttpAgent_fetch, "f").call(_this51, "" + new URL("/api/v3/canister/" + ecid.toText() + "/call", _this51.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(_this51, _HttpAgent_callOptions, "f")), transformedRequest.request), {
                        body: body
                      }));
                    };

                    requestAsync = function requestAsync() {
                      _this51.log.print("fetching \"/api/v2/canister/" + ecid.toText() + "/call\" with request:", transformedRequest);

                      return __classPrivateFieldGet(_this51, _HttpAgent_fetch, "f").call(_this51, "" + new URL("/api/v2/canister/" + ecid.toText() + "/call", _this51.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(_this51, _HttpAgent_callOptions, "f")), transformedRequest.request), {
                        body: body
                      }));
                    };

                    request = __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                      request: callSync ? requestSync : requestAsync,
                      backoff: backoff,
                      tries: 0
                    });
                    _context19.next = 41;
                    return request;

                  case 41:
                    response = _context19.sent;
                    _context19.next = 44;
                    return response.arrayBuffer();

                  case 44:
                    responseBuffer = _context19.sent;
                    responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null;

                    if (!(responseBody && "certificate" in responseBody)) {
                      _context19.next = 51;
                      break;
                    }

                    _context19.next = 49;
                    return this.parseTimeFromResponse({
                      certificate: responseBody.certificate
                    });

                  case 49:
                    time = _context19.sent;

                    __classPrivateFieldSet(this, _HttpAgent_waterMark, time, "f");

                  case 51:
                    return _context19.abrupt("return", {
                      requestId: requestId,
                      response: {
                        ok: response.ok,
                        status: response.status,
                        statusText: response.statusText,
                        body: responseBody,
                        headers: (0, transforms_1.httpHeadersTransform)(response.headers)
                      },
                      requestDetails: submit
                    });

                  case 54:
                    _context19.prev = 54;
                    _context19.t1 = _context19["catch"](35);

                    if (!_context19.t1.message.includes("v3 api not supported.")) {
                      _context19.next = 59;
                      break;
                    }

                    this.log.warn("v3 api not supported. Fall back to v2");
                    return _context19.abrupt("return", this.call(canisterId, Object.assign(Object.assign({}, options), {
                      // disable v3 api
                      callSync: false
                    }), identity));

                  case 59:
                    message = "Error while making call: " + ((_b = _context19.t1.message) !== null && _b !== void 0 ? _b : String(_context19.t1));
                    callError = new errors_2.AgentCallError(message, _context19.t1, (0, buffer_1.toHex)(requestId), (0, buffer_1.toHex)(transformedRequest.body.sender_pubkey), (0, buffer_1.toHex)(transformedRequest.body.sender_sig), String(transformedRequest.body.content.ingress_expiry["_value"]));
                    this.log.error(message, callError);
                    throw callError;

                  case 63:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee16, this, [[35, 54]]);
          }));

          function call(_x17, _x18, _x19) {
            return _call.apply(this, arguments);
          }

          return call;
        }();

        _proto76.query = /*#__PURE__*/function () {
          var _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(canisterId, fields, identity) {
            var _this52 = this;

            var _a, _b, _c, _d, backoff, ecid, transformedRequest, queryResult, id, canister, sender, request, requestId, body, args, makeQuery, getSubnetStatus, _yield$Promise$all, _queryResult, subnetStatus, _queryResult2, requestDetails, _query2, queryWithDetails, updatedSubnetStatus, message, queryError;

            return _regeneratorRuntime().wrap(function _callee19$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    _context22.next = 2;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 2:
                    backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
                    ecid = fields.effectiveCanisterId ? principal_1.Principal.from(fields.effectiveCanisterId) : principal_1.Principal.from(canisterId);
                    this.log.print("ecid " + ecid.toString());
                    this.log.print("canisterId " + canisterId.toString());
                    transformedRequest = void 0;
                    _context22.next = 9;
                    return identity !== void 0 ? identity : __classPrivateFieldGet(this, _HttpAgent_identity, "f");

                  case 9:
                    id = _context22.sent;

                    if (id) {
                      _context22.next = 12;
                      break;
                    }

                    throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");

                  case 12:
                    canister = principal_1.Principal.from(canisterId);
                    sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
                    request = {
                      request_type: "query",
                      canister_id: canister,
                      method_name: fields.methodName,
                      arg: fields.arg,
                      sender: sender,
                      ingress_expiry: new transforms_1.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS)
                    };
                    requestId = (0, request_id_1.requestIdOf)(request);
                    _context22.next = 18;
                    return this._transform({
                      request: {
                        method: "POST",
                        headers: Object.assign({
                          "Content-Type": "application/cbor"
                        }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                          Authorization: "Basic " + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                        } : {})
                      },
                      endpoint: "read",
                      body: request
                    });

                  case 18:
                    transformedRequest = _context22.sent;
                    _context22.next = 21;
                    return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);

                  case 21:
                    transformedRequest = _context22.sent;
                    body = cbor.encode(transformedRequest.body);
                    args = {
                      canister: canister.toText(),
                      ecid: ecid,
                      transformedRequest: transformedRequest,
                      body: body,
                      requestId: requestId,
                      backoff: backoff,
                      tries: 0
                    };

                    makeQuery = /*#__PURE__*/function () {
                      var _ref108 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
                        return _regeneratorRuntime().wrap(function _callee17$(_context20) {
                          while (1) {
                            switch (_context20.prev = _context20.next) {
                              case 0:
                                _context20.t0 = request;
                                _context20.next = 3;
                                return __classPrivateFieldGet(_this52, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(_this52, args);

                              case 3:
                                _context20.t1 = _context20.sent;
                                return _context20.abrupt("return", {
                                  requestDetails: _context20.t0,
                                  query: _context20.t1
                                });

                              case 5:
                              case "end":
                                return _context20.stop();
                            }
                          }
                        }, _callee17);
                      }));

                      return function makeQuery() {
                        return _ref108.apply(this, arguments);
                      };
                    }();

                    getSubnetStatus = /*#__PURE__*/function () {
                      var _ref109 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
                        var subnetStatus;
                        return _regeneratorRuntime().wrap(function _callee18$(_context21) {
                          while (1) {
                            switch (_context21.prev = _context21.next) {
                              case 0:
                                if (__classPrivateFieldGet(_this52, _HttpAgent_verifyQuerySignatures, "f")) {
                                  _context21.next = 2;
                                  break;
                                }

                                return _context21.abrupt("return", void 0);

                              case 2:
                                subnetStatus = __classPrivateFieldGet(_this52, _HttpAgent_subnetKeys, "f").get(ecid.toString());

                                if (!subnetStatus) {
                                  _context21.next = 5;
                                  break;
                                }

                                return _context21.abrupt("return", subnetStatus);

                              case 5:
                                _context21.next = 7;
                                return _this52.fetchSubnetKeys(ecid.toString());

                              case 7:
                                return _context21.abrupt("return", __classPrivateFieldGet(_this52, _HttpAgent_subnetKeys, "f").get(ecid.toString()));

                              case 8:
                              case "end":
                                return _context21.stop();
                            }
                          }
                        }, _callee18);
                      }));

                      return function getSubnetStatus() {
                        return _ref109.apply(this, arguments);
                      };
                    }();

                    _context22.prev = 26;
                    _context22.next = 29;
                    return Promise.all([makeQuery(), getSubnetStatus()]);

                  case 29:
                    _yield$Promise$all = _context22.sent;
                    _queryResult = _yield$Promise$all[0];
                    subnetStatus = _yield$Promise$all[1];
                    queryResult = _queryResult;
                    _queryResult2 = queryResult, requestDetails = _queryResult2.requestDetails, _query2 = _queryResult2.query;
                    queryWithDetails = Object.assign(Object.assign({}, _query2), {
                      requestDetails: requestDetails
                    });
                    this.log.print("Query response:", queryWithDetails);

                    if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                      _context22.next = 38;
                      break;
                    }

                    return _context22.abrupt("return", queryWithDetails);

                  case 38:
                    _context22.prev = 38;
                    return _context22.abrupt("return", __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, queryWithDetails, subnetStatus));

                  case 42:
                    _context22.prev = 42;
                    _context22.t0 = _context22["catch"](38);
                    this.log.warn("Query response verification failed. Retrying with fresh subnet keys.");

                    __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f")["delete"](canisterId.toString());

                    _context22.next = 48;
                    return this.fetchSubnetKeys(ecid.toString());

                  case 48:
                    updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());

                    if (updatedSubnetStatus) {
                      _context22.next = 51;
                      break;
                    }

                    throw new certificate_1.CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");

                  case 51:
                    return _context22.abrupt("return", __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, queryWithDetails, updatedSubnetStatus));

                  case 52:
                    _context22.next = 60;
                    break;

                  case 54:
                    _context22.prev = 54;
                    _context22.t1 = _context22["catch"](26);
                    message = "Error while making call: " + ((_a = _context22.t1.message) !== null && _a !== void 0 ? _a : String(_context22.t1));
                    queryError = new errors_2.AgentQueryError(message, _context22.t1, String(requestId), (0, buffer_1.toHex)((_b = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _b === void 0 ? void 0 : _b.sender_pubkey), (0, buffer_1.toHex)((_c = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _c === void 0 ? void 0 : _c.sender_sig), String((_d = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _d === void 0 ? void 0 : _d.content.ingress_expiry["_value"]));
                    this.log.error(message, queryError);
                    throw queryError;

                  case 60:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee19, this, [[26, 54], [38, 42]]);
          }));

          function query(_x20, _x21, _x22) {
            return _query.apply(this, arguments);
          }

          return query;
        }();

        _proto76.createReadStateRequest = /*#__PURE__*/function () {
          var _createReadStateRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(fields, identity) {
            var id, sender, transformedRequest;
            return _regeneratorRuntime().wrap(function _callee20$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    _context23.next = 2;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 2:
                    if (!(identity !== void 0)) {
                      _context23.next = 8;
                      break;
                    }

                    _context23.next = 5;
                    return identity;

                  case 5:
                    _context23.t0 = _context23.sent;
                    _context23.next = 11;
                    break;

                  case 8:
                    _context23.next = 10;
                    return __classPrivateFieldGet(this, _HttpAgent_identity, "f");

                  case 10:
                    _context23.t0 = _context23.sent;

                  case 11:
                    _context23.next = 13;
                    return _context23.t0;

                  case 13:
                    id = _context23.sent;

                    if (id) {
                      _context23.next = 16;
                      break;
                    }

                    throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");

                  case 16:
                    sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
                    _context23.next = 19;
                    return this._transform({
                      request: {
                        method: "POST",
                        headers: Object.assign({
                          "Content-Type": "application/cbor"
                        }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                          Authorization: "Basic " + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                        } : {})
                      },
                      endpoint: "read_state",
                      body: {
                        request_type: "read_state",
                        paths: fields.paths,
                        sender: sender,
                        ingress_expiry: new transforms_1.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS)
                      }
                    });

                  case 19:
                    transformedRequest = _context23.sent;
                    return _context23.abrupt("return", id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));

                  case 21:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee20, this);
          }));

          function createReadStateRequest(_x23, _x24) {
            return _createReadStateRequest.apply(this, arguments);
          }

          return createReadStateRequest;
        }();

        _proto76.readState = /*#__PURE__*/function () {
          var _readState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(canisterId, fields, identity, request) {
            var _this53 = this;

            var _a, _b, _c, _d, getRequestId, requestId, canister, transformedRequest, body, backoff, response, decodedResponse, parsedTime, message, readStateError;

            return _regeneratorRuntime().wrap(function _callee21$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    getRequestId = function _getRequestId(fields2) {
                      for (var _iterator29 = _createForOfIteratorHelperLoose(fields2.paths), _step29; !(_step29 = _iterator29()).done;) {
                        var path = _step29.value;
                        var pathName = path[0],
                            value = path[1];
                        var request_status = (0, buffer_1.bufFromBufLike)(new TextEncoder().encode("request_status"));

                        if ((0, buffer_1.bufEquals)(pathName, request_status)) {
                          return value;
                        }
                      }
                    };

                    requestId = getRequestId(fields);
                    _context24.next = 4;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 4:
                    canister = typeof canisterId === "string" ? principal_1.Principal.fromText(canisterId) : canisterId;

                    if (!(request !== null && request !== void 0)) {
                      _context24.next = 9;
                      break;
                    }

                    _context24.t0 = request;
                    _context24.next = 12;
                    break;

                  case 9:
                    _context24.next = 11;
                    return this.createReadStateRequest(fields, identity);

                  case 11:
                    _context24.t0 = _context24.sent;

                  case 12:
                    transformedRequest = _context24.t0;
                    body = cbor.encode(transformedRequest.body);
                    this.log.print("fetching \"/api/v2/canister/" + canister + "/read_state\" with request:", transformedRequest);
                    backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
                    _context24.prev = 16;
                    _context24.next = 19;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                      request: function request() {
                        return __classPrivateFieldGet(_this53, _HttpAgent_fetch, "f").call(_this53, "" + new URL("/api/v2/canister/" + canister.toString() + "/read_state", _this53.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(_this53, _HttpAgent_fetchOptions, "f")), transformedRequest.request), {
                          body: body
                        }));
                      },
                      backoff: backoff,
                      tries: 0
                    });

                  case 19:
                    response = _context24.sent;

                    if (response.ok) {
                      _context24.next = 29;
                      break;
                    }

                    _context24.t1 = Error;
                    _context24.t2 = "Server returned an error:\n  Code: " + response.status + " (" + response.statusText + ")\n  Body: ";
                    _context24.next = 25;
                    return response.text();

                  case 25:
                    _context24.t3 = _context24.sent;
                    _context24.t4 = _context24.t2 + _context24.t3;
                    _context24.t5 = _context24.t4 + "\n";
                    throw new _context24.t1(_context24.t5);

                  case 29:
                    _context24.t6 = cbor;
                    _context24.next = 32;
                    return response.arrayBuffer();

                  case 32:
                    _context24.t7 = _context24.sent;
                    decodedResponse = _context24.t6.decode.call(_context24.t6, _context24.t7);
                    this.log.print("Read state response:", decodedResponse);
                    _context24.next = 37;
                    return this.parseTimeFromResponse(decodedResponse);

                  case 37:
                    parsedTime = _context24.sent;

                    if (parsedTime > 0) {
                      this.log.print("Read state response time:", parsedTime);

                      __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, "f");
                    }

                    return _context24.abrupt("return", decodedResponse);

                  case 42:
                    _context24.prev = 42;
                    _context24.t8 = _context24["catch"](16);
                    message = "Caught exception while attempting to read state: " + ((_a = _context24.t8.message) !== null && _a !== void 0 ? _a : String(_context24.t8));
                    readStateError = new errors_2.AgentReadStateError(message, _context24.t8, String(requestId), (0, buffer_1.toHex)((_b = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _b === void 0 ? void 0 : _b.sender_pubkey), (0, buffer_1.toHex)((_c = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _c === void 0 ? void 0 : _c.sender_sig), String((_d = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _d === void 0 ? void 0 : _d.content.ingress_expiry["_value"]));
                    this.log.error(message, readStateError);
                    throw readStateError;

                  case 48:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee21, this, [[16, 42]]);
          }));

          function readState(_x25, _x26, _x27, _x28) {
            return _readState.apply(this, arguments);
          }

          return readState;
        }();

        _proto76.parseTimeFromResponse = /*#__PURE__*/function () {
          var _parseTimeFromResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(response) {
            var tree, decoded, timeLookup, date;
            return _regeneratorRuntime().wrap(function _callee22$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    if (!response.certificate) {
                      _context25.next = 18;
                      break;
                    }

                    decoded = cbor.decode(response.certificate);

                    if (!(decoded && "tree" in decoded)) {
                      _context25.next = 6;
                      break;
                    }

                    tree = decoded.tree;
                    _context25.next = 7;
                    break;

                  case 6:
                    throw new Error("Could not decode time from response");

                  case 7:
                    timeLookup = (0, certificate_1.lookup_path)(["time"], tree);

                    if (!(timeLookup.status !== certificate_1.LookupStatus.Found)) {
                      _context25.next = 10;
                      break;
                    }

                    throw new Error("Time was not found in the response or was not in its expected format.");

                  case 10:
                    if (!(!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup))) {
                      _context25.next = 12;
                      break;
                    }

                    throw new Error("Time was not found in the response or was not in its expected format.");

                  case 12:
                    date = (0, leb_1.decodeTime)((0, buffer_1.bufFromBufLike)(timeLookup.value));
                    this.log.print("Time from response:", date);
                    this.log.print("Time from response in milliseconds:", Number(date));
                    return _context25.abrupt("return", Number(date));

                  case 18:
                    this.log.warn("No certificate found in response");

                  case 19:
                    return _context25.abrupt("return", 0);

                  case 20:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee22, this);
          }));

          function parseTimeFromResponse(_x29) {
            return _parseTimeFromResponse.apply(this, arguments);
          }

          return parseTimeFromResponse;
        }()
        /**
         * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request
         * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default
         */
        ;

        _proto76.syncTime =
        /*#__PURE__*/
        function () {
          var _syncTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(canisterId) {
            var CanisterStatus, callTime, anonymousAgent, status, replicaTime;
            return _regeneratorRuntime().wrap(function _callee23$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    _context26.next = 2;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 2:
                    _context26.next = 4;
                    return Promise.resolve().then(function () {
                      return __importStar(require_canisterStatus());
                    });

                  case 4:
                    CanisterStatus = _context26.sent;
                    callTime = Date.now();
                    _context26.prev = 6;

                    if (!canisterId) {
                      this.log.print("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
                    }

                    anonymousAgent = _HttpAgent.createSync({
                      identity: new auth_1.AnonymousIdentity(),
                      host: this.host.toString(),
                      fetch: __classPrivateFieldGet(this, _HttpAgent_fetch, "f"),
                      retryTimes: 0
                    });
                    _context26.next = 11;
                    return CanisterStatus.request({
                      // Fall back with canisterId of the ICP Ledger
                      canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : principal_1.Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
                      agent: anonymousAgent,
                      paths: ["time"]
                    });

                  case 11:
                    status = _context26.sent;
                    replicaTime = status.get("time");

                    if (replicaTime) {
                      __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), "f");

                      this.log.notify({
                        message: "Syncing time: offset of " + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f"),
                        level: "info"
                      });
                    }

                    _context26.next = 19;
                    break;

                  case 16:
                    _context26.prev = 16;
                    _context26.t0 = _context26["catch"](6);
                    this.log.error("Caught exception while attempting to sync time", _context26.t0);

                  case 19:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee23, this, [[6, 16]]);
          }));

          function syncTime(_x30) {
            return _syncTime.apply(this, arguments);
          }

          return syncTime;
        }();

        _proto76.status = /*#__PURE__*/function () {
          var _status = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
            var _this54 = this;

            var headers, backoff, response;
            return _regeneratorRuntime().wrap(function _callee24$(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    headers = __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                      Authorization: "Basic " + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                    } : {};
                    this.log.print("fetching \"/api/v2/status\"");
                    backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
                    _context27.next = 5;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                      backoff: backoff,
                      request: function request() {
                        return __classPrivateFieldGet(_this54, _HttpAgent_fetch, "f").call(_this54, "" + new URL("/api/v2/status", _this54.host), Object.assign({
                          headers: headers
                        }, __classPrivateFieldGet(_this54, _HttpAgent_fetchOptions, "f")));
                      },
                      tries: 0
                    });

                  case 5:
                    response = _context27.sent;
                    _context27.t0 = cbor;
                    _context27.next = 9;
                    return response.arrayBuffer();

                  case 9:
                    _context27.t1 = _context27.sent;
                    return _context27.abrupt("return", _context27.t0.decode.call(_context27.t0, _context27.t1));

                  case 11:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee24, this);
          }));

          function status() {
            return _status.apply(this, arguments);
          }

          return status;
        }();

        _proto76.fetchRootKey = /*#__PURE__*/function () {
          var _fetchRootKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
            var _this55 = this;

            var result;
            return _regeneratorRuntime().wrap(function _callee25$(_context28) {
              while (1) {
                switch (_context28.prev = _context28.next) {
                  case 0:
                    if (!__classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f")) {
                      _context28.next = 6;
                      break;
                    }

                    _context28.next = 3;
                    return __classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f");

                  case 3:
                    result = _context28.sent;
                    _context28.next = 10;
                    break;

                  case 6:
                    __classPrivateFieldSet(this, _HttpAgent_rootKeyPromise, new Promise(function (resolve, reject) {
                      _this55.status().then(function (value) {
                        var rootKey = value.root_key;
                        _this55.rootKey = rootKey;
                        resolve(rootKey);
                      })["catch"](reject);
                    }), "f");

                    _context28.next = 9;
                    return __classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f");

                  case 9:
                    result = _context28.sent;

                  case 10:
                    __classPrivateFieldSet(this, _HttpAgent_rootKeyPromise, null, "f");

                    return _context28.abrupt("return", result);

                  case 12:
                  case "end":
                    return _context28.stop();
                }
              }
            }, _callee25, this);
          }));

          function fetchRootKey() {
            return _fetchRootKey.apply(this, arguments);
          }

          return fetchRootKey;
        }();

        _proto76.invalidateIdentity = function invalidateIdentity() {
          __classPrivateFieldSet(this, _HttpAgent_identity, null, "f");
        };

        _proto76.replaceIdentity = function replaceIdentity(identity) {
          __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), "f");
        };

        _proto76.fetchSubnetKeys = /*#__PURE__*/function () {
          var _fetchSubnetKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(canisterId) {
            var effectiveCanisterId, response, subnetResponse;
            return _regeneratorRuntime().wrap(function _callee26$(_context29) {
              while (1) {
                switch (_context29.prev = _context29.next) {
                  case 0:
                    _context29.next = 2;
                    return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);

                  case 2:
                    effectiveCanisterId = principal_1.Principal.from(canisterId);
                    _context29.next = 5;
                    return (0, canisterStatus_1.request)({
                      canisterId: effectiveCanisterId,
                      paths: ["subnet"],
                      agent: this
                    });

                  case 5:
                    response = _context29.sent;
                    subnetResponse = response.get("subnet");

                    if (!(subnetResponse && typeof subnetResponse === "object" && "nodeKeys" in subnetResponse)) {
                      _context29.next = 10;
                      break;
                    }

                    __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").set(effectiveCanisterId.toText(), subnetResponse);

                    return _context29.abrupt("return", subnetResponse);

                  case 10:
                    return _context29.abrupt("return", void 0);

                  case 11:
                  case "end":
                    return _context29.stop();
                }
              }
            }, _callee26, this);
          }));

          function fetchSubnetKeys(_x31) {
            return _fetchSubnetKeys.apply(this, arguments);
          }

          return fetchSubnetKeys;
        }();

        _proto76._transform = function _transform(request) {
          var p = Promise.resolve(request);

          if (request.endpoint === "call") {
            var _loop2 = function _loop2() {
              var fn = _step30.value;
              p = p.then(function (r) {
                return fn(r).then(function (r2) {
                  return r2 || r;
                });
              });
            };

            for (var _iterator30 = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f")), _step30; !(_step30 = _iterator30()).done;) {
              _loop2();
            }
          } else {
            var _loop3 = function _loop3() {
              var fn = _step31.value;
              p = p.then(function (r) {
                return fn(r).then(function (r2) {
                  return r2 || r;
                });
              });
            };

            for (var _iterator31 = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f")), _step31; !(_step31 = _iterator31()).done;) {
              _loop3();
            }
          }

          return p;
        };

        _createClass(_HttpAgent, [{
          key: "waterMark",
          get: function get() {
            return __classPrivateFieldGet(this, _HttpAgent_waterMark, "f");
          }
        }]);

        return _HttpAgent;
      }();

      exports.HttpAgent = HttpAgent;
      _HttpAgent_rootKeyPromise = /* @__PURE__ */new WeakMap(), _HttpAgent_shouldFetchRootKey = /* @__PURE__ */new WeakMap(), _HttpAgent_identity = /* @__PURE__ */new WeakMap(), _HttpAgent_fetch = /* @__PURE__ */new WeakMap(), _HttpAgent_fetchOptions = /* @__PURE__ */new WeakMap(), _HttpAgent_callOptions = /* @__PURE__ */new WeakMap(), _HttpAgent_timeDiffMsecs = /* @__PURE__ */new WeakMap(), _HttpAgent_credentials = /* @__PURE__ */new WeakMap(), _HttpAgent_retryTimes = /* @__PURE__ */new WeakMap(), _HttpAgent_backoffStrategy = /* @__PURE__ */new WeakMap(), _HttpAgent_maxIngressExpiryInMinutes = /* @__PURE__ */new WeakMap(), _HttpAgent_waterMark = /* @__PURE__ */new WeakMap(), _HttpAgent_queryPipeline = /* @__PURE__ */new WeakMap(), _HttpAgent_updatePipeline = /* @__PURE__ */new WeakMap(), _HttpAgent_subnetKeys = /* @__PURE__ */new WeakMap(), _HttpAgent_verifyQuerySignatures = /* @__PURE__ */new WeakMap(), _HttpAgent_verifyQueryResponse = /* @__PURE__ */new WeakMap(), _HttpAgent_instances = /* @__PURE__ */new WeakSet(), _HttpAgent_requestAndRetryQuery = /*#__PURE__*/function () {
        var _HttpAgent_requestAndRetryQuery3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(args) {
          var _a, _b, ecid, transformedRequest, body, requestId, backoff, tries, delay, response, fetchResponse, queryResponse, timestamp, timeStampInMs, error;

          return _regeneratorRuntime().wrap(function _callee27$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  ecid = args.ecid, transformedRequest = args.transformedRequest, body = args.body, requestId = args.requestId, backoff = args.backoff, tries = args.tries;
                  delay = tries === 0 ? 0 : backoff.next();
                  this.log.print("fetching \"/api/v2/canister/" + ecid.toString() + "/query\" with tries:", {
                    tries: tries,
                    backoff: backoff,
                    delay: delay
                  });

                  if (!(delay === null)) {
                    _context30.next = 5;
                    break;
                  }

                  throw new errors_1.AgentError("Timestamp failed to pass the watermark after retrying the configured " + __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f") + " times. We cannot guarantee the integrity of the response since it could be a replay attack.");

                case 5:
                  if (!(delay > 0)) {
                    _context30.next = 8;
                    break;
                  }

                  _context30.next = 8;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, delay);
                  });

                case 8:
                  _context30.prev = 8;
                  this.log.print("fetching \"/api/v2/canister/" + ecid.toString() + "/query\" with request:", transformedRequest);
                  _context30.next = 12;
                  return __classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, "" + new URL("/api/v2/canister/" + ecid.toString() + "/query", this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, "f")), transformedRequest.request), {
                    body: body
                  }));

                case 12:
                  fetchResponse = _context30.sent;

                  if (!(fetchResponse.status === 200)) {
                    _context30.next = 22;
                    break;
                  }

                  _context30.t0 = cbor;
                  _context30.next = 17;
                  return fetchResponse.arrayBuffer();

                case 17:
                  _context30.t1 = _context30.sent;
                  queryResponse = _context30.t0.decode.call(_context30.t0, _context30.t1);
                  response = Object.assign(Object.assign({}, queryResponse), {
                    httpDetails: {
                      ok: fetchResponse.ok,
                      status: fetchResponse.status,
                      statusText: fetchResponse.statusText,
                      headers: (0, transforms_1.httpHeadersTransform)(fetchResponse.headers)
                    },
                    requestId: requestId
                  });
                  _context30.next = 31;
                  break;

                case 22:
                  _context30.t2 = errors_2.AgentHTTPResponseError;
                  _context30.t3 = "Gateway returned an error:\n  Code: " + fetchResponse.status + " (" + fetchResponse.statusText + ")\n  Body: ";
                  _context30.next = 26;
                  return fetchResponse.text();

                case 26:
                  _context30.t4 = _context30.sent;
                  _context30.t5 = _context30.t3 + _context30.t4;
                  _context30.t6 = _context30.t5 + "\n";
                  _context30.t7 = {
                    ok: fetchResponse.ok,
                    status: fetchResponse.status,
                    statusText: fetchResponse.statusText,
                    headers: (0, transforms_1.httpHeadersTransform)(fetchResponse.headers)
                  };
                  throw new _context30.t2(_context30.t6, _context30.t7);

                case 31:
                  _context30.next = 41;
                  break;

                case 33:
                  _context30.prev = 33;
                  _context30.t8 = _context30["catch"](8);

                  if (!(tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f"))) {
                    _context30.next = 40;
                    break;
                  }

                  this.log.warn("Caught exception while attempting to make query:\n  " + _context30.t8 + "\n  Retrying query.");
                  _context30.next = 39;
                  return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery2).call(this, Object.assign(Object.assign({}, args), {
                    tries: tries + 1
                  }));

                case 39:
                  return _context30.abrupt("return", _context30.sent);

                case 40:
                  throw _context30.t8;

                case 41:
                  timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;

                  if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                    _context30.next = 44;
                    break;
                  }

                  return _context30.abrupt("return", response);

                case 44:
                  if (timestamp) {
                    _context30.next = 46;
                    break;
                  }

                  throw new Error("Timestamp not found in query response. This suggests a malformed or malicious response.");

                case 46:
                  timeStampInMs = Number(BigInt(timestamp) / BigInt(1e6));
                  this.log.print("watermark and timestamp", {
                    waterMark: this.waterMark,
                    timestamp: timeStampInMs
                  });

                  if (!(Number(this.waterMark) > timeStampInMs)) {
                    _context30.next = 56;
                    break;
                  }

                  error = new errors_1.AgentError("Timestamp is below the watermark. Retrying query.");
                  this.log.error("Timestamp is below", error, {
                    timestamp: timestamp,
                    waterMark: this.waterMark
                  });

                  if (!(tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f"))) {
                    _context30.next = 55;
                    break;
                  }

                  _context30.next = 54;
                  return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery2).call(this, Object.assign(Object.assign({}, args), {
                    tries: tries + 1
                  }));

                case 54:
                  return _context30.abrupt("return", _context30.sent);

                case 55:
                  throw new errors_1.AgentError("Timestamp failed to pass the watermark after retrying the configured " + __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f") + " times. We cannot guarantee the integrity of the response since it could be a replay attack.");

                case 56:
                  return _context30.abrupt("return", response);

                case 57:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee27, this, [[8, 33]]);
        }));

        function _HttpAgent_requestAndRetryQuery2(_x32) {
          return _HttpAgent_requestAndRetryQuery3.apply(this, arguments);
        }

        return _HttpAgent_requestAndRetryQuery2;
      }(), _HttpAgent_requestAndRetry = /*#__PURE__*/function () {
        var _HttpAgent_requestAndRetry3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(args) {
          var request, backoff, tries, delay, response, responseText, errorMessage;
          return _regeneratorRuntime().wrap(function _callee28$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  request = args.request, backoff = args.backoff, tries = args.tries;
                  delay = tries === 0 ? 0 : backoff.next();

                  if (!(delay === null)) {
                    _context31.next = 4;
                    break;
                  }

                  throw new errors_1.AgentError("Timestamp failed to pass the watermark after retrying the configured " + __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f") + " times. We cannot guarantee the integrity of the response since it could be a replay attack.");

                case 4:
                  if (!(delay > 0)) {
                    _context31.next = 7;
                    break;
                  }

                  _context31.next = 7;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, delay);
                  });

                case 7:
                  _context31.prev = 7;
                  _context31.next = 10;
                  return request();

                case 10:
                  response = _context31.sent;
                  _context31.next = 21;
                  break;

                case 13:
                  _context31.prev = 13;
                  _context31.t0 = _context31["catch"](7);

                  if (!(__classPrivateFieldGet(this, _HttpAgent_retryTimes, "f") > tries)) {
                    _context31.next = 20;
                    break;
                  }

                  this.log.warn("Caught exception while attempting to make request:\n  " + _context31.t0 + "\n  Retrying request.");
                  _context31.next = 19;
                  return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry2).call(this, {
                    request: request,
                    backoff: backoff,
                    tries: tries + 1
                  });

                case 19:
                  return _context31.abrupt("return", _context31.sent);

                case 20:
                  throw _context31.t0;

                case 21:
                  if (!response.ok) {
                    _context31.next = 23;
                    break;
                  }

                  return _context31.abrupt("return", response);

                case 23:
                  _context31.next = 25;
                  return response.clone().text();

                case 25:
                  responseText = _context31.sent;
                  errorMessage = "Server returned an error:\n  Code: " + response.status + " (" + response.statusText + ")\n  Body: " + responseText + "\n";

                  if (!(response.status === 404 && response.url.includes("api/v3"))) {
                    _context31.next = 29;
                    break;
                  }

                  throw new errors_2.AgentHTTPResponseError("v3 api not supported. Fall back to v2", {
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    headers: (0, transforms_1.httpHeadersTransform)(response.headers)
                  });

                case 29:
                  if (!(tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f"))) {
                    _context31.next = 33;
                    break;
                  }

                  _context31.next = 32;
                  return __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry2).call(this, {
                    request: request,
                    backoff: backoff,
                    tries: tries + 1
                  });

                case 32:
                  return _context31.abrupt("return", _context31.sent);

                case 33:
                  throw new errors_2.AgentHTTPResponseError(errorMessage, {
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    headers: (0, transforms_1.httpHeadersTransform)(response.headers)
                  });

                case 34:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee28, this, [[7, 13]]);
        }));

        function _HttpAgent_requestAndRetry2(_x33) {
          return _HttpAgent_requestAndRetry3.apply(this, arguments);
        }

        return _HttpAgent_requestAndRetry2;
      }(), _HttpAgent_rootKeyGuard = /*#__PURE__*/function () {
        var _HttpAgent_rootKeyGuard3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
          return _regeneratorRuntime().wrap(function _callee29$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  if (!this.rootKey) {
                    _context32.next = 4;
                    break;
                  }

                  return _context32.abrupt("return");

                case 4:
                  if (!(this.rootKey === null && __classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f"))) {
                    _context32.next = 9;
                    break;
                  }

                  _context32.next = 7;
                  return this.fetchRootKey();

                case 7:
                  _context32.next = 10;
                  break;

                case 9:
                  throw new errors_1.AgentError("Invalid root key detected. The root key for this agent is " + this.rootKey + " and the shouldFetchRootKey value is set to " + __classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f") + ". The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.");

                case 10:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee29, this);
        }));

        function _HttpAgent_rootKeyGuard2() {
          return _HttpAgent_rootKeyGuard3.apply(this, arguments);
        }

        return _HttpAgent_rootKeyGuard2;
      }();
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/proxy.js


  var require_proxy = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/proxy.js": function node_modulesDfinityAgentLibCjsAgentProxyJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ProxyAgent = exports.ProxyStubAgent = exports.ProxyMessageKind = void 0;
      var principal_1 = require_cjs();
      var ProxyMessageKind;

      (function (ProxyMessageKind2) {
        ProxyMessageKind2["Error"] = "err";
        ProxyMessageKind2["GetPrincipal"] = "gp";
        ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
        ProxyMessageKind2["Query"] = "q";
        ProxyMessageKind2["QueryResponse"] = "qr";
        ProxyMessageKind2["Call"] = "c";
        ProxyMessageKind2["CallResponse"] = "cr";
        ProxyMessageKind2["ReadState"] = "rs";
        ProxyMessageKind2["ReadStateResponse"] = "rsr";
        ProxyMessageKind2["Status"] = "s";
        ProxyMessageKind2["StatusResponse"] = "sr";
      })(ProxyMessageKind = exports.ProxyMessageKind || (exports.ProxyMessageKind = {}));

      var ProxyStubAgent = /*#__PURE__*/function () {
        function ProxyStubAgent(_frontend, _agent) {
          this._frontend = _frontend;
          this._agent = _agent;
        }

        var _proto77 = ProxyStubAgent.prototype;

        _proto77.onmessage = function onmessage(msg) {
          var _this56 = this,
              _this$_agent,
              _this$_agent2,
              _this$_agent3;

          switch (msg.type) {
            case ProxyMessageKind.GetPrincipal:
              this._agent.getPrincipal().then(function (response) {
                _this56._frontend({
                  id: msg.id,
                  type: ProxyMessageKind.GetPrincipalResponse,
                  response: response.toText()
                });
              });

              break;

            case ProxyMessageKind.Query:
              (_this$_agent = this._agent).query.apply(_this$_agent, msg.args).then(function (response) {
                _this56._frontend({
                  id: msg.id,
                  type: ProxyMessageKind.QueryResponse,
                  response: response
                });
              });

              break;

            case ProxyMessageKind.Call:
              (_this$_agent2 = this._agent).call.apply(_this$_agent2, msg.args).then(function (response) {
                _this56._frontend({
                  id: msg.id,
                  type: ProxyMessageKind.CallResponse,
                  response: response
                });
              });

              break;

            case ProxyMessageKind.ReadState:
              (_this$_agent3 = this._agent).readState.apply(_this$_agent3, msg.args).then(function (response) {
                _this56._frontend({
                  id: msg.id,
                  type: ProxyMessageKind.ReadStateResponse,
                  response: response
                });
              });

              break;

            case ProxyMessageKind.Status:
              this._agent.status().then(function (response) {
                _this56._frontend({
                  id: msg.id,
                  type: ProxyMessageKind.StatusResponse,
                  response: response
                });
              });

              break;

            default:
              throw new Error("Invalid message received: " + JSON.stringify(msg));
          }
        };

        return ProxyStubAgent;
      }();

      exports.ProxyStubAgent = ProxyStubAgent;

      var ProxyAgent = /*#__PURE__*/function () {
        function ProxyAgent(_backend) {
          this._backend = _backend;
          this._nextId = 0;
          this._pendingCalls = /* @__PURE__ */new Map();
          this.rootKey = null;
        }

        var _proto78 = ProxyAgent.prototype;

        _proto78.onmessage = function onmessage(msg) {
          var id = msg.id;

          var maybePromise = this._pendingCalls.get(id);

          if (!maybePromise) {
            throw new Error("A proxy get the same message twice...");
          }

          this._pendingCalls["delete"](id);

          var resolve = maybePromise[0],
              reject = maybePromise[1];

          switch (msg.type) {
            case ProxyMessageKind.Error:
              return reject(msg.error);

            case ProxyMessageKind.GetPrincipalResponse:
            case ProxyMessageKind.CallResponse:
            case ProxyMessageKind.QueryResponse:
            case ProxyMessageKind.ReadStateResponse:
            case ProxyMessageKind.StatusResponse:
              return resolve(msg.response);

            default:
              throw new Error("Invalid message being sent to ProxyAgent: " + JSON.stringify(msg));
          }
        };

        _proto78.getPrincipal = /*#__PURE__*/function () {
          var _getPrincipal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
            return _regeneratorRuntime().wrap(function _callee30$(_context33) {
              while (1) {
                switch (_context33.prev = _context33.next) {
                  case 0:
                    return _context33.abrupt("return", this._sendAndWait({
                      id: this._nextId++,
                      type: ProxyMessageKind.GetPrincipal
                    }).then(function (principal) {
                      if (typeof principal !== "string") {
                        throw new Error("Invalid principal received.");
                      }

                      return principal_1.Principal.fromText(principal);
                    }));

                  case 1:
                  case "end":
                    return _context33.stop();
                }
              }
            }, _callee30, this);
          }));

          function getPrincipal() {
            return _getPrincipal2.apply(this, arguments);
          }

          return getPrincipal;
        }();

        _proto78.readState = function readState(canisterId, fields) {
          return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.ReadState,
            args: [canisterId.toString(), fields]
          });
        };

        _proto78.call = function call(canisterId, fields) {
          return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Call,
            args: [canisterId.toString(), fields]
          });
        };

        _proto78.status = function status() {
          return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Status
          });
        };

        _proto78.query = function query(canisterId, fields) {
          return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Query,
            args: [canisterId.toString(), fields]
          });
        };

        _proto78._sendAndWait = /*#__PURE__*/function () {
          var _sendAndWait2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(msg) {
            var _this57 = this;

            return _regeneratorRuntime().wrap(function _callee31$(_context34) {
              while (1) {
                switch (_context34.prev = _context34.next) {
                  case 0:
                    return _context34.abrupt("return", new Promise(function (resolve, reject) {
                      _this57._pendingCalls.set(msg.id, [resolve, reject]);

                      _this57._backend(msg);
                    }));

                  case 1:
                  case "end":
                    return _context34.stop();
                }
              }
            }, _callee31);
          }));

          function _sendAndWait(_x34) {
            return _sendAndWait2.apply(this, arguments);
          }

          return _sendAndWait;
        }();

        _proto78.fetchRootKey = /*#__PURE__*/function () {
          var _fetchRootKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
            var rootKey;
            return _regeneratorRuntime().wrap(function _callee32$(_context35) {
              while (1) {
                switch (_context35.prev = _context35.next) {
                  case 0:
                    _context35.next = 2;
                    return this.status();

                  case 2:
                    rootKey = _context35.sent.root_key;
                    this.rootKey = rootKey;
                    return _context35.abrupt("return", rootKey);

                  case 5:
                  case "end":
                    return _context35.stop();
                }
              }
            }, _callee32, this);
          }));

          function fetchRootKey() {
            return _fetchRootKey2.apply(this, arguments);
          }

          return fetchRootKey;
        }();

        return ProxyAgent;
      }();

      exports.ProxyAgent = ProxyAgent;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/agent/index.js


  var require_agent = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/agent/index.js": function node_modulesDfinityAgentLibCjsAgentIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getDefaultAgent = void 0;

      __exportStar(require_api(), exports);

      __exportStar(require_http(), exports);

      __exportStar(require_errors2(), exports);

      __exportStar(require_proxy(), exports);

      function getDefaultAgent() {
        var agent = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? void 0 : self.ic.agent : global.ic.agent : window.ic.agent;

        if (!agent) {
          throw new Error("No Agent could be found.");
        }

        return agent;
      }

      exports.getDefaultAgent = getDefaultAgent;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/polling/strategy.js


  var require_strategy = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/polling/strategy.js": function node_modulesDfinityAgentLibCjsPollingStrategyJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.chain = exports.backoff = exports.timeout = exports.throttle = exports.maxAttempts = exports.conditionalDelay = exports.once = exports.defaultStrategy = void 0;
      var buffer_1 = require_buffer2();
      var FIVE_MINUTES_IN_MSEC = 5 * 60 * 1e3;

      function defaultStrategy() {
        return chain(conditionalDelay(once(), 1e3), backoff(1e3, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
      }

      exports.defaultStrategy = defaultStrategy;

      function once() {
        var first = true;
        return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
          return _regeneratorRuntime().wrap(function _callee33$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  if (!first) {
                    _context36.next = 3;
                    break;
                  }

                  first = false;
                  return _context36.abrupt("return", true);

                case 3:
                  return _context36.abrupt("return", false);

                case 4:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee33);
        }));
      }

      exports.once = once;

      function conditionalDelay(condition, timeInMsec) {
        return /*#__PURE__*/function () {
          var _ref111 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(canisterId, requestId, status) {
            return _regeneratorRuntime().wrap(function _callee34$(_context37) {
              while (1) {
                switch (_context37.prev = _context37.next) {
                  case 0:
                    _context37.next = 2;
                    return condition(canisterId, requestId, status);

                  case 2:
                    if (!_context37.sent) {
                      _context37.next = 4;
                      break;
                    }

                    return _context37.abrupt("return", new Promise(function (resolve) {
                      return setTimeout(resolve, timeInMsec);
                    }));

                  case 4:
                  case "end":
                    return _context37.stop();
                }
              }
            }, _callee34);
          }));

          return function (_x35, _x36, _x37) {
            return _ref111.apply(this, arguments);
          };
        }();
      }

      exports.conditionalDelay = conditionalDelay;

      function maxAttempts(count) {
        var attempts = count;
        return /*#__PURE__*/function () {
          var _ref112 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(canisterId, requestId, status) {
            return _regeneratorRuntime().wrap(function _callee35$(_context38) {
              while (1) {
                switch (_context38.prev = _context38.next) {
                  case 0:
                    if (!(--attempts <= 0)) {
                      _context38.next = 2;
                      break;
                    }

                    throw new Error("Failed to retrieve a reply for request after " + count + " attempts:\n  Request ID: " + (0, buffer_1.toHex)(requestId) + "\n  Request status: " + status + "\n");

                  case 2:
                  case "end":
                    return _context38.stop();
                }
              }
            }, _callee35);
          }));

          return function (_x38, _x39, _x40) {
            return _ref112.apply(this, arguments);
          };
        }();
      }

      exports.maxAttempts = maxAttempts;

      function throttle(throttleInMsec) {
        return function () {
          return new Promise(function (resolve) {
            return setTimeout(resolve, throttleInMsec);
          });
        };
      }

      exports.throttle = throttle;

      function timeout(timeInMsec) {
        var end = Date.now() + timeInMsec;
        return /*#__PURE__*/function () {
          var _ref113 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(canisterId, requestId, status) {
            return _regeneratorRuntime().wrap(function _callee36$(_context39) {
              while (1) {
                switch (_context39.prev = _context39.next) {
                  case 0:
                    if (!(Date.now() > end)) {
                      _context39.next = 2;
                      break;
                    }

                    throw new Error("Request timed out after " + timeInMsec + " msec:\n  Request ID: " + (0, buffer_1.toHex)(requestId) + "\n  Request status: " + status + "\n");

                  case 2:
                  case "end":
                    return _context39.stop();
                }
              }
            }, _callee36);
          }));

          return function (_x41, _x42, _x43) {
            return _ref113.apply(this, arguments);
          };
        }();
      }

      exports.timeout = timeout;

      function backoff(startingThrottleInMsec, backoffFactor) {
        var currentThrottling = startingThrottleInMsec;
        return function () {
          return new Promise(function (resolve) {
            return setTimeout(function () {
              currentThrottling *= backoffFactor;
              resolve();
            }, currentThrottling);
          });
        };
      }

      exports.backoff = backoff;

      function chain() {
        for (var _len15 = arguments.length, strategies = new Array(_len15), _key17 = 0; _key17 < _len15; _key17++) {
          strategies[_key17] = arguments[_key17];
        }

        return /*#__PURE__*/function () {
          var _ref114 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(canisterId, requestId, status) {
            var _iterator32, _step32, a;

            return _regeneratorRuntime().wrap(function _callee37$(_context40) {
              while (1) {
                switch (_context40.prev = _context40.next) {
                  case 0:
                    _iterator32 = _createForOfIteratorHelperLoose(strategies);

                  case 1:
                    if ((_step32 = _iterator32()).done) {
                      _context40.next = 7;
                      break;
                    }

                    a = _step32.value;
                    _context40.next = 5;
                    return a(canisterId, requestId, status);

                  case 5:
                    _context40.next = 1;
                    break;

                  case 7:
                  case "end":
                    return _context40.stop();
                }
              }
            }, _callee37);
          }));

          return function (_x44, _x45, _x46) {
            return _ref114.apply(this, arguments);
          };
        }();
      }

      exports.chain = chain;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/polling/index.js


  var require_polling = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/polling/index.js": function node_modulesDfinityAgentLibCjsPollingIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pollForResponse = exports.defaultStrategy = exports.strategy = void 0;
      var agent_1 = require_agent();
      var certificate_1 = require_certificate();
      var buffer_1 = require_buffer2();
      exports.strategy = __importStar(require_strategy());
      var strategy_1 = require_strategy();
      var strategy_2 = require_strategy();
      Object.defineProperty(exports, "defaultStrategy", {
        enumerable: true,
        get: function get() {
          return strategy_2.defaultStrategy;
        }
      });

      function pollForResponse(_x47, _x48, _x49, _x50, _x51, _x52) {
        return _pollForResponse.apply(this, arguments);
      }

      function _pollForResponse() {
        _pollForResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(agent, canisterId, requestId, strategy, request, blsVerify) {
          var _a, path, currentRequest, state, cert, maybeBuf, status, rejectCode, rejectMessage;

          return _regeneratorRuntime().wrap(function _callee38$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  if (strategy === void 0) {
                    strategy = (0, strategy_1.defaultStrategy)();
                  }

                  path = [new TextEncoder().encode("request_status"), requestId];

                  if (!(request !== null && request !== void 0)) {
                    _context41.next = 6;
                    break;
                  }

                  _context41.t0 = request;
                  _context41.next = 9;
                  break;

                case 6:
                  _context41.next = 8;
                  return (_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, {
                    paths: [path]
                  });

                case 8:
                  _context41.t0 = _context41.sent;

                case 9:
                  currentRequest = _context41.t0;
                  _context41.next = 12;
                  return agent.readState(canisterId, {
                    paths: [path]
                  }, void 0, currentRequest);

                case 12:
                  state = _context41.sent;

                  if (!(agent.rootKey == null)) {
                    _context41.next = 15;
                    break;
                  }

                  throw new Error("Agent root key not initialized before polling");

                case 15:
                  _context41.next = 17;
                  return certificate_1.Certificate.create({
                    certificate: state.certificate,
                    rootKey: agent.rootKey,
                    canisterId: canisterId,
                    blsVerify: blsVerify
                  });

                case 17:
                  cert = _context41.sent;
                  maybeBuf = (0, certificate_1.lookupResultToBuffer)(cert.lookup([].concat(path, [new TextEncoder().encode("status")])));

                  if (typeof maybeBuf === "undefined") {
                    status = agent_1.RequestStatusResponseStatus.Unknown;
                  } else {
                    status = new TextDecoder().decode(maybeBuf);
                  }

                  _context41.t1 = status;
                  _context41.next = _context41.t1 === agent_1.RequestStatusResponseStatus.Replied ? 23 : _context41.t1 === agent_1.RequestStatusResponseStatus.Received ? 24 : _context41.t1 === agent_1.RequestStatusResponseStatus.Unknown ? 24 : _context41.t1 === agent_1.RequestStatusResponseStatus.Processing ? 24 : _context41.t1 === agent_1.RequestStatusResponseStatus.Rejected ? 27 : _context41.t1 === agent_1.RequestStatusResponseStatus.Done ? 30 : 31;
                  break;

                case 23:
                  return _context41.abrupt("return", {
                    reply: (0, certificate_1.lookupResultToBuffer)(cert.lookup([].concat(path, ["reply"]))),
                    certificate: cert
                  });

                case 24:
                  _context41.next = 26;
                  return strategy(canisterId, requestId, status);

                case 26:
                  return _context41.abrupt("return", pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify));

                case 27:
                  rejectCode = new Uint8Array((0, certificate_1.lookupResultToBuffer)(cert.lookup([].concat(path, ["reject_code"]))))[0];
                  rejectMessage = new TextDecoder().decode((0, certificate_1.lookupResultToBuffer)(cert.lookup([].concat(path, ["reject_message"]))));
                  throw new Error("Call was rejected:\n  Request ID: " + (0, buffer_1.toHex)(requestId) + "\n  Reject code: " + rejectCode + "\n  Reject text: " + rejectMessage + "\n");

                case 30:
                  throw new Error("Call was marked as done but we never saw the reply:\n  Request ID: " + (0, buffer_1.toHex)(requestId) + "\n");

                case 31:
                  throw new Error("unreachable");

                case 32:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee38);
        }));
        return _pollForResponse.apply(this, arguments);
      }

      exports.pollForResponse = pollForResponse;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/canisters/management_idl.js


  var require_management_idl = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/canisters/management_idl.js": function node_modulesDfinityAgentLibCjsCanistersManagement_idlJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports["default"] = function (_ref115) {
        var IDL = _ref115.IDL;
        var bitcoin_network = IDL.Variant({
          mainnet: IDL.Null,
          testnet: IDL.Null
        });
        var bitcoin_address = IDL.Text;
        var bitcoin_get_balance_args = IDL.Record({
          network: bitcoin_network,
          address: bitcoin_address,
          min_confirmations: IDL.Opt(IDL.Nat32)
        });
        var satoshi = IDL.Nat64;
        var bitcoin_get_balance_result = satoshi;
        var bitcoin_block_height = IDL.Nat32;
        var bitcoin_get_block_headers_args = IDL.Record({
          start_height: bitcoin_block_height,
          end_height: IDL.Opt(bitcoin_block_height),
          network: bitcoin_network
        });
        var bitcoin_block_header = IDL.Vec(IDL.Nat8);
        var bitcoin_get_block_headers_result = IDL.Record({
          tip_height: bitcoin_block_height,
          block_headers: IDL.Vec(bitcoin_block_header)
        });
        var bitcoin_get_current_fee_percentiles_args = IDL.Record({
          network: bitcoin_network
        });
        var millisatoshi_per_byte = IDL.Nat64;
        var bitcoin_get_current_fee_percentiles_result = IDL.Vec(millisatoshi_per_byte);
        var bitcoin_get_utxos_args = IDL.Record({
          network: bitcoin_network,
          filter: IDL.Opt(IDL.Variant({
            page: IDL.Vec(IDL.Nat8),
            min_confirmations: IDL.Nat32
          })),
          address: bitcoin_address
        });
        var bitcoin_block_hash = IDL.Vec(IDL.Nat8);
        var outpoint = IDL.Record({
          txid: IDL.Vec(IDL.Nat8),
          vout: IDL.Nat32
        });
        var utxo = IDL.Record({
          height: IDL.Nat32,
          value: satoshi,
          outpoint: outpoint
        });
        var bitcoin_get_utxos_result = IDL.Record({
          next_page: IDL.Opt(IDL.Vec(IDL.Nat8)),
          tip_height: bitcoin_block_height,
          tip_block_hash: bitcoin_block_hash,
          utxos: IDL.Vec(utxo)
        });
        var bitcoin_send_transaction_args = IDL.Record({
          transaction: IDL.Vec(IDL.Nat8),
          network: bitcoin_network
        });
        var canister_id = IDL.Principal;
        var canister_info_args = IDL.Record({
          canister_id: canister_id,
          num_requested_changes: IDL.Opt(IDL.Nat64)
        });
        var change_origin = IDL.Variant({
          from_user: IDL.Record({
            user_id: IDL.Principal
          }),
          from_canister: IDL.Record({
            canister_version: IDL.Opt(IDL.Nat64),
            canister_id: IDL.Principal
          })
        });
        var snapshot_id = IDL.Vec(IDL.Nat8);
        var change_details = IDL.Variant({
          creation: IDL.Record({
            controllers: IDL.Vec(IDL.Principal)
          }),
          code_deployment: IDL.Record({
            mode: IDL.Variant({
              reinstall: IDL.Null,
              upgrade: IDL.Null,
              install: IDL.Null
            }),
            module_hash: IDL.Vec(IDL.Nat8)
          }),
          load_snapshot: IDL.Record({
            canister_version: IDL.Nat64,
            taken_at_timestamp: IDL.Nat64,
            snapshot_id: snapshot_id
          }),
          controllers_change: IDL.Record({
            controllers: IDL.Vec(IDL.Principal)
          }),
          code_uninstall: IDL.Null
        });
        var change = IDL.Record({
          timestamp_nanos: IDL.Nat64,
          canister_version: IDL.Nat64,
          origin: change_origin,
          details: change_details
        });
        var canister_info_result = IDL.Record({
          controllers: IDL.Vec(IDL.Principal),
          module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
          recent_changes: IDL.Vec(change),
          total_num_changes: IDL.Nat64
        });
        var canister_status_args = IDL.Record({
          canister_id: canister_id
        });
        var log_visibility = IDL.Variant({
          controllers: IDL.Null,
          "public": IDL.Null,
          allowed_viewers: IDL.Vec(IDL.Principal)
        });
        var definite_canister_settings = IDL.Record({
          freezing_threshold: IDL.Nat,
          controllers: IDL.Vec(IDL.Principal),
          reserved_cycles_limit: IDL.Nat,
          log_visibility: log_visibility,
          wasm_memory_limit: IDL.Nat,
          memory_allocation: IDL.Nat,
          compute_allocation: IDL.Nat
        });
        var canister_status_result = IDL.Record({
          status: IDL.Variant({
            stopped: IDL.Null,
            stopping: IDL.Null,
            running: IDL.Null
          }),
          memory_size: IDL.Nat,
          cycles: IDL.Nat,
          settings: definite_canister_settings,
          query_stats: IDL.Record({
            response_payload_bytes_total: IDL.Nat,
            num_instructions_total: IDL.Nat,
            num_calls_total: IDL.Nat,
            request_payload_bytes_total: IDL.Nat
          }),
          idle_cycles_burned_per_day: IDL.Nat,
          module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
          reserved_cycles: IDL.Nat
        });
        var clear_chunk_store_args = IDL.Record({
          canister_id: canister_id
        });
        var canister_settings = IDL.Record({
          freezing_threshold: IDL.Opt(IDL.Nat),
          controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
          reserved_cycles_limit: IDL.Opt(IDL.Nat),
          log_visibility: IDL.Opt(log_visibility),
          wasm_memory_limit: IDL.Opt(IDL.Nat),
          memory_allocation: IDL.Opt(IDL.Nat),
          compute_allocation: IDL.Opt(IDL.Nat)
        });
        var create_canister_args = IDL.Record({
          settings: IDL.Opt(canister_settings),
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var create_canister_result = IDL.Record({
          canister_id: canister_id
        });
        var delete_canister_args = IDL.Record({
          canister_id: canister_id
        });
        var delete_canister_snapshot_args = IDL.Record({
          canister_id: canister_id,
          snapshot_id: snapshot_id
        });
        var deposit_cycles_args = IDL.Record({
          canister_id: canister_id
        });
        var ecdsa_curve = IDL.Variant({
          secp256k1: IDL.Null
        });
        var ecdsa_public_key_args = IDL.Record({
          key_id: IDL.Record({
            name: IDL.Text,
            curve: ecdsa_curve
          }),
          canister_id: IDL.Opt(canister_id),
          derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
        });
        var ecdsa_public_key_result = IDL.Record({
          public_key: IDL.Vec(IDL.Nat8),
          chain_code: IDL.Vec(IDL.Nat8)
        });
        var fetch_canister_logs_args = IDL.Record({
          canister_id: canister_id
        });
        var canister_log_record = IDL.Record({
          idx: IDL.Nat64,
          timestamp_nanos: IDL.Nat64,
          content: IDL.Vec(IDL.Nat8)
        });
        var fetch_canister_logs_result = IDL.Record({
          canister_log_records: IDL.Vec(canister_log_record)
        });
        var http_header = IDL.Record({
          value: IDL.Text,
          name: IDL.Text
        });
        var http_request_result = IDL.Record({
          status: IDL.Nat,
          body: IDL.Vec(IDL.Nat8),
          headers: IDL.Vec(http_header)
        });
        var http_request_args = IDL.Record({
          url: IDL.Text,
          method: IDL.Variant({
            get: IDL.Null,
            head: IDL.Null,
            post: IDL.Null
          }),
          max_response_bytes: IDL.Opt(IDL.Nat64),
          body: IDL.Opt(IDL.Vec(IDL.Nat8)),
          transform: IDL.Opt(IDL.Record({
            "function": IDL.Func([IDL.Record({
              context: IDL.Vec(IDL.Nat8),
              response: http_request_result
            })], [http_request_result], ["query"]),
            context: IDL.Vec(IDL.Nat8)
          })),
          headers: IDL.Vec(http_header)
        });
        var canister_install_mode = IDL.Variant({
          reinstall: IDL.Null,
          upgrade: IDL.Opt(IDL.Record({
            wasm_memory_persistence: IDL.Opt(IDL.Variant({
              keep: IDL.Null,
              replace: IDL.Null
            })),
            skip_pre_upgrade: IDL.Opt(IDL.Bool)
          })),
          install: IDL.Null
        });
        var chunk_hash = IDL.Record({
          hash: IDL.Vec(IDL.Nat8)
        });
        var install_chunked_code_args = IDL.Record({
          arg: IDL.Vec(IDL.Nat8),
          wasm_module_hash: IDL.Vec(IDL.Nat8),
          mode: canister_install_mode,
          chunk_hashes_list: IDL.Vec(chunk_hash),
          target_canister: canister_id,
          store_canister: IDL.Opt(canister_id),
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var wasm_module = IDL.Vec(IDL.Nat8);
        var install_code_args = IDL.Record({
          arg: IDL.Vec(IDL.Nat8),
          wasm_module: wasm_module,
          mode: canister_install_mode,
          canister_id: canister_id,
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var list_canister_snapshots_args = IDL.Record({
          canister_id: canister_id
        });
        var snapshot = IDL.Record({
          id: snapshot_id,
          total_size: IDL.Nat64,
          taken_at_timestamp: IDL.Nat64
        });
        var list_canister_snapshots_result = IDL.Vec(snapshot);
        var load_canister_snapshot_args = IDL.Record({
          canister_id: canister_id,
          sender_canister_version: IDL.Opt(IDL.Nat64),
          snapshot_id: snapshot_id
        });
        var node_metrics_history_args = IDL.Record({
          start_at_timestamp_nanos: IDL.Nat64,
          subnet_id: IDL.Principal
        });
        var node_metrics = IDL.Record({
          num_block_failures_total: IDL.Nat64,
          node_id: IDL.Principal,
          num_blocks_proposed_total: IDL.Nat64
        });
        var node_metrics_history_result = IDL.Vec(IDL.Record({
          timestamp_nanos: IDL.Nat64,
          node_metrics: IDL.Vec(node_metrics)
        }));
        var provisional_create_canister_with_cycles_args = IDL.Record({
          settings: IDL.Opt(canister_settings),
          specified_id: IDL.Opt(canister_id),
          amount: IDL.Opt(IDL.Nat),
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var provisional_create_canister_with_cycles_result = IDL.Record({
          canister_id: canister_id
        });
        var provisional_top_up_canister_args = IDL.Record({
          canister_id: canister_id,
          amount: IDL.Nat
        });
        var raw_rand_result = IDL.Vec(IDL.Nat8);
        var schnorr_algorithm = IDL.Variant({
          ed25519: IDL.Null,
          bip340secp256k1: IDL.Null
        });
        var schnorr_public_key_args = IDL.Record({
          key_id: IDL.Record({
            algorithm: schnorr_algorithm,
            name: IDL.Text
          }),
          canister_id: IDL.Opt(canister_id),
          derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
        });
        var schnorr_public_key_result = IDL.Record({
          public_key: IDL.Vec(IDL.Nat8),
          chain_code: IDL.Vec(IDL.Nat8)
        });
        var sign_with_ecdsa_args = IDL.Record({
          key_id: IDL.Record({
            name: IDL.Text,
            curve: ecdsa_curve
          }),
          derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
          message_hash: IDL.Vec(IDL.Nat8)
        });
        var sign_with_ecdsa_result = IDL.Record({
          signature: IDL.Vec(IDL.Nat8)
        });
        var schnorr_aux = IDL.Variant({
          bip341: IDL.Record({
            merkle_root_hash: IDL.Vec(IDL.Nat8)
          })
        });
        var sign_with_schnorr_args = IDL.Record({
          aux: IDL.Opt(schnorr_aux),
          key_id: IDL.Record({
            algorithm: schnorr_algorithm,
            name: IDL.Text
          }),
          derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
          message: IDL.Vec(IDL.Nat8)
        });
        var sign_with_schnorr_result = IDL.Record({
          signature: IDL.Vec(IDL.Nat8)
        });
        var start_canister_args = IDL.Record({
          canister_id: canister_id
        });
        var stop_canister_args = IDL.Record({
          canister_id: canister_id
        });
        var stored_chunks_args = IDL.Record({
          canister_id: canister_id
        });
        var stored_chunks_result = IDL.Vec(chunk_hash);
        var subnet_info_args = IDL.Record({
          subnet_id: IDL.Principal
        });
        var subnet_info_result = IDL.Record({
          replica_version: IDL.Text
        });
        var take_canister_snapshot_args = IDL.Record({
          replace_snapshot: IDL.Opt(snapshot_id),
          canister_id: canister_id
        });
        var take_canister_snapshot_result = snapshot;
        var uninstall_code_args = IDL.Record({
          canister_id: canister_id,
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var update_settings_args = IDL.Record({
          canister_id: IDL.Principal,
          settings: canister_settings,
          sender_canister_version: IDL.Opt(IDL.Nat64)
        });
        var upload_chunk_args = IDL.Record({
          chunk: IDL.Vec(IDL.Nat8),
          canister_id: IDL.Principal
        });
        var upload_chunk_result = chunk_hash;
        return IDL.Service({
          bitcoin_get_balance: IDL.Func([bitcoin_get_balance_args], [bitcoin_get_balance_result], []),
          bitcoin_get_block_headers: IDL.Func([bitcoin_get_block_headers_args], [bitcoin_get_block_headers_result], []),
          bitcoin_get_current_fee_percentiles: IDL.Func([bitcoin_get_current_fee_percentiles_args], [bitcoin_get_current_fee_percentiles_result], []),
          bitcoin_get_utxos: IDL.Func([bitcoin_get_utxos_args], [bitcoin_get_utxos_result], []),
          bitcoin_send_transaction: IDL.Func([bitcoin_send_transaction_args], [], []),
          canister_info: IDL.Func([canister_info_args], [canister_info_result], []),
          canister_status: IDL.Func([canister_status_args], [canister_status_result], []),
          clear_chunk_store: IDL.Func([clear_chunk_store_args], [], []),
          create_canister: IDL.Func([create_canister_args], [create_canister_result], []),
          delete_canister: IDL.Func([delete_canister_args], [], []),
          delete_canister_snapshot: IDL.Func([delete_canister_snapshot_args], [], []),
          deposit_cycles: IDL.Func([deposit_cycles_args], [], []),
          ecdsa_public_key: IDL.Func([ecdsa_public_key_args], [ecdsa_public_key_result], []),
          fetch_canister_logs: IDL.Func([fetch_canister_logs_args], [fetch_canister_logs_result], ["query"]),
          http_request: IDL.Func([http_request_args], [http_request_result], []),
          install_chunked_code: IDL.Func([install_chunked_code_args], [], []),
          install_code: IDL.Func([install_code_args], [], []),
          list_canister_snapshots: IDL.Func([list_canister_snapshots_args], [list_canister_snapshots_result], []),
          load_canister_snapshot: IDL.Func([load_canister_snapshot_args], [], []),
          node_metrics_history: IDL.Func([node_metrics_history_args], [node_metrics_history_result], []),
          provisional_create_canister_with_cycles: IDL.Func([provisional_create_canister_with_cycles_args], [provisional_create_canister_with_cycles_result], []),
          provisional_top_up_canister: IDL.Func([provisional_top_up_canister_args], [], []),
          raw_rand: IDL.Func([], [raw_rand_result], []),
          schnorr_public_key: IDL.Func([schnorr_public_key_args], [schnorr_public_key_result], []),
          sign_with_ecdsa: IDL.Func([sign_with_ecdsa_args], [sign_with_ecdsa_result], []),
          sign_with_schnorr: IDL.Func([sign_with_schnorr_args], [sign_with_schnorr_result], []),
          start_canister: IDL.Func([start_canister_args], [], []),
          stop_canister: IDL.Func([stop_canister_args], [], []),
          stored_chunks: IDL.Func([stored_chunks_args], [stored_chunks_result], []),
          subnet_info: IDL.Func([subnet_info_args], [subnet_info_result], []),
          take_canister_snapshot: IDL.Func([take_canister_snapshot_args], [take_canister_snapshot_result], []),
          uninstall_code: IDL.Func([uninstall_code_args], [], []),
          update_settings: IDL.Func([update_settings_args], [], []),
          upload_chunk: IDL.Func([upload_chunk_args], [upload_chunk_result], [])
        });
      };
    }
  }); // node_modules/@dfinity/agent/lib/cjs/actor.js


  var require_actor = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/actor.js": function node_modulesDfinityAgentLibCjsActorJs(exports) {
      "use strict";

      var __importDefault = exports && exports.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AdvancedActor = exports.getManagementCanister = exports.ACTOR_METHOD_WITH_CERTIFICATE = exports.ACTOR_METHOD_WITH_HTTP_DETAILS = exports.Actor = exports.UpdateCallRejectedError = exports.QueryCallRejectedError = exports.ActorCallError = void 0;
      var buffer_1 = require_buffer();
      var agent_1 = require_agent();
      var errors_1 = require_errors();
      var candid_1 = require_cjs2();
      var polling_1 = require_polling();
      var principal_1 = require_cjs();
      var buffer_2 = require_buffer2();
      var certificate_1 = require_certificate();

      var management_idl_1 = __importDefault(require_management_idl());

      var ActorCallError = /*#__PURE__*/function (_errors_1$AgentError8) {
        _inheritsLoose(ActorCallError, _errors_1$AgentError8);

        function ActorCallError(canisterId, methodName, type, props) {
          var _this58;

          _this58 = _errors_1$AgentError8.call(this, ["Call failed:", "  Canister: " + canisterId.toText(), "  Method: " + methodName + " (" + type + ")"].concat(Object.getOwnPropertyNames(props).map(function (n) {
            return "  \"" + n + "\": " + JSON.stringify(props[n]);
          })).join("\n")) || this;
          _this58.canisterId = canisterId;
          _this58.methodName = methodName;
          _this58.type = type;
          _this58.props = props;
          return _this58;
        }

        return ActorCallError;
      }(errors_1.AgentError);

      exports.ActorCallError = ActorCallError;

      var QueryCallRejectedError = /*#__PURE__*/function (_ActorCallError4) {
        _inheritsLoose(QueryCallRejectedError, _ActorCallError4);

        function QueryCallRejectedError(canisterId, methodName, result) {
          var _this59;

          var _a;

          _this59 = _ActorCallError4.call(this, canisterId, methodName, "query", {
            Status: result.status,
            Code: (_a = agent_1.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : "Unknown Code \"" + result.reject_code + "\"",
            Message: result.reject_message
          }) || this;
          _this59.result = result;
          return _this59;
        }

        return QueryCallRejectedError;
      }(ActorCallError);

      exports.QueryCallRejectedError = QueryCallRejectedError;

      var UpdateCallRejectedError = /*#__PURE__*/function (_ActorCallError5) {
        _inheritsLoose(UpdateCallRejectedError, _ActorCallError5);

        function UpdateCallRejectedError(canisterId, methodName, requestId, response, reject_code, reject_message, error_code) {
          var _this60;

          _this60 = _ActorCallError5.call(this, canisterId, methodName, "update", Object.assign({
            "Request ID": (0, buffer_2.toHex)(requestId)
          }, response.body ? Object.assign(Object.assign({}, error_code ? {
            "Error code": error_code
          } : {}), {
            "Reject code": String(reject_code),
            "Reject message": reject_message
          }) : {
            "HTTP status code": response.status.toString(),
            "HTTP status text": response.statusText
          })) || this;
          _this60.requestId = requestId;
          _this60.response = response;
          _this60.reject_code = reject_code;
          _this60.reject_message = reject_message;
          _this60.error_code = error_code;
          return _this60;
        }

        return UpdateCallRejectedError;
      }(ActorCallError);

      exports.UpdateCallRejectedError = UpdateCallRejectedError;
      var metadataSymbol = Symbol["for"]("ic-agent-metadata");

      var Actor = /*#__PURE__*/function () {
        function _Actor(metadata) {
          this[metadataSymbol] = Object.freeze(metadata);
        }
        /**
         * Get the Agent class this Actor would call, or undefined if the Actor would use
         * the default agent (global.ic.agent).
         * @param actor The actor to get the agent of.
         */


        _Actor.agentOf = function agentOf(actor) {
          return actor[metadataSymbol].config.agent;
        }
        /**
         * Get the interface of an actor, in the form of an instance of a Service.
         * @param actor The actor to get the interface of.
         */
        ;

        _Actor.interfaceOf = function interfaceOf(actor) {
          return actor[metadataSymbol].service;
        };

        _Actor.canisterIdOf = function canisterIdOf(actor) {
          return principal_1.Principal.from(actor[metadataSymbol].config.canisterId);
        };

        _Actor.install = /*#__PURE__*/function () {
          var _install = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(fields, config) {
            var mode, arg, wasmModule, canisterId;
            return _regeneratorRuntime().wrap(function _callee39$(_context42) {
              while (1) {
                switch (_context42.prev = _context42.next) {
                  case 0:
                    mode = fields.mode === void 0 ? {
                      install: null
                    } : fields.mode;
                    arg = fields.arg ? [].concat(new Uint8Array(fields.arg)) : [];
                    wasmModule = [].concat(new Uint8Array(fields.module));
                    canisterId = typeof config.canisterId === "string" ? principal_1.Principal.fromText(config.canisterId) : config.canisterId;
                    _context42.next = 6;
                    return getManagementCanister(config).install_code({
                      mode: mode,
                      arg: arg,
                      wasm_module: wasmModule,
                      canister_id: canisterId,
                      sender_canister_version: []
                    });

                  case 6:
                  case "end":
                    return _context42.stop();
                }
              }
            }, _callee39);
          }));

          function install(_x53, _x54) {
            return _install.apply(this, arguments);
          }

          return install;
        }();

        _Actor.createCanister = /*#__PURE__*/function () {
          var _createCanister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(config, settings) {
            var settingsToCanisterSettings, _yield$getManagementC, canisterId;

            return _regeneratorRuntime().wrap(function _callee40$(_context43) {
              while (1) {
                switch (_context43.prev = _context43.next) {
                  case 0:
                    settingsToCanisterSettings = function _settingsToCanisterSe(settings2) {
                      return [{
                        controllers: settings2.controllers ? [settings2.controllers] : [],
                        compute_allocation: settings2.compute_allocation ? [settings2.compute_allocation] : [],
                        freezing_threshold: settings2.freezing_threshold ? [settings2.freezing_threshold] : [],
                        memory_allocation: settings2.memory_allocation ? [settings2.memory_allocation] : [],
                        reserved_cycles_limit: [],
                        log_visibility: [],
                        wasm_memory_limit: []
                      }];
                    };

                    _context43.next = 3;
                    return getManagementCanister(config || {}).provisional_create_canister_with_cycles({
                      amount: [],
                      settings: settingsToCanisterSettings(settings || {}),
                      specified_id: [],
                      sender_canister_version: []
                    });

                  case 3:
                    _yield$getManagementC = _context43.sent;
                    canisterId = _yield$getManagementC.canister_id;
                    return _context43.abrupt("return", canisterId);

                  case 6:
                  case "end":
                    return _context43.stop();
                }
              }
            }, _callee40);
          }));

          function createCanister(_x55, _x56) {
            return _createCanister.apply(this, arguments);
          }

          return createCanister;
        }();

        _Actor.createAndInstallCanister = /*#__PURE__*/function () {
          var _createAndInstallCanister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(interfaceFactory, fields, config) {
            var canisterId;
            return _regeneratorRuntime().wrap(function _callee41$(_context44) {
              while (1) {
                switch (_context44.prev = _context44.next) {
                  case 0:
                    _context44.next = 2;
                    return this.createCanister(config);

                  case 2:
                    canisterId = _context44.sent;
                    _context44.next = 5;
                    return this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {
                      canisterId: canisterId
                    }));

                  case 5:
                    return _context44.abrupt("return", this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {
                      canisterId: canisterId
                    })));

                  case 6:
                  case "end":
                    return _context44.stop();
                }
              }
            }, _callee41, this);
          }));

          function createAndInstallCanister(_x57, _x58, _x59) {
            return _createAndInstallCanister.apply(this, arguments);
          }

          return createAndInstallCanister;
        }();

        _Actor.createActorClass = function createActorClass(interfaceFactory, options) {
          var service = interfaceFactory({
            IDL: candid_1.IDL
          });

          var CanisterActor = /*#__PURE__*/function (_Actor2) {
            _inheritsLoose(CanisterActor, _Actor2);

            function CanisterActor(config) {
              var _this61;

              if (!config.canisterId) throw new errors_1.AgentError("Canister ID is required, but received " + typeof config.canisterId + " instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.");
              var canisterId = typeof config.canisterId === "string" ? principal_1.Principal.fromText(config.canisterId) : config.canisterId;
              _this61 = _Actor2.call(this, {
                config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {
                  canisterId: canisterId
                }),
                service: service
              }) || this;

              for (var _iterator33 = _createForOfIteratorHelperLoose(service._fields), _step33; !(_step33 = _iterator33()).done;) {
                var _step33$value = _step33.value,
                    methodName = _step33$value[0],
                    func = _step33$value[1];

                if (options === null || options === void 0 ? void 0 : options.httpDetails) {
                  func.annotations.push(exports.ACTOR_METHOD_WITH_HTTP_DETAILS);
                }

                if (options === null || options === void 0 ? void 0 : options.certificate) {
                  func.annotations.push(exports.ACTOR_METHOD_WITH_CERTIFICATE);
                }

                _this61[methodName] = _createActorMethod(_assertThisInitialized(_this61), methodName, func, config.blsVerify);
              }

              return _this61;
            }

            return CanisterActor;
          }(_Actor);

          return CanisterActor;
        };

        _Actor.createActor = function createActor(interfaceFactory, configuration) {
          if (!configuration.canisterId) {
            throw new errors_1.AgentError("Canister ID is required, but received " + typeof configuration.canisterId + " instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.");
          }

          return new (this.createActorClass(interfaceFactory))(configuration);
        }
        /**
         * Returns an actor with methods that return the http response details along with the result
         * @param interfaceFactory - the interface factory for the actor
         * @param configuration - the configuration for the actor
         * @deprecated - use createActor with actorClassOptions instead
         */
        ;

        _Actor.createActorWithHttpDetails = function createActorWithHttpDetails(interfaceFactory, configuration) {
          return new (this.createActorClass(interfaceFactory, {
            httpDetails: true
          }))(configuration);
        }
        /**
         * Returns an actor with methods that return the http response details along with the result
         * @param interfaceFactory - the interface factory for the actor
         * @param configuration - the configuration for the actor
         * @param actorClassOptions - options for the actor class extended details to return with the result
         */
        ;

        _Actor.createActorWithExtendedDetails = function createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions) {
          if (actorClassOptions === void 0) {
            actorClassOptions = {
              httpDetails: true,
              certificate: true
            };
          }

          return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);
        };

        return _Actor;
      }();

      exports.Actor = Actor;

      function decodeReturnValue(types, msg) {
        var returnValues = candid_1.IDL.decode(types, buffer_1.Buffer.from(msg));

        switch (returnValues.length) {
          case 0:
            return void 0;

          case 1:
            return returnValues[0];

          default:
            return returnValues;
        }
      }

      var DEFAULT_ACTOR_CONFIG = {
        pollingStrategyFactory: polling_1.strategy.defaultStrategy
      };
      exports.ACTOR_METHOD_WITH_HTTP_DETAILS = "http-details";
      exports.ACTOR_METHOD_WITH_CERTIFICATE = "certificate";

      function _createActorMethod(actor, methodName, func, blsVerify) {
        var caller;

        if (func.annotations.includes("query") || func.annotations.includes("composite_query")) {
          caller = /*#__PURE__*/function () {
            var _ref116 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(options) {
              var _a,
                  _b,
                  _len16,
                  args,
                  _key18,
                  agent,
                  cid,
                  arg,
                  result,
                  httpDetails,
                  _args46 = arguments;

              return _regeneratorRuntime().wrap(function _callee42$(_context45) {
                while (1) {
                  switch (_context45.prev = _context45.next) {
                    case 0:
                      for (_len16 = _args46.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key18 = 1; _key18 < _len16; _key18++) {
                        args[_key18 - 1] = _args46[_key18];
                      }

                      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                      agent = options.agent || actor[metadataSymbol].config.agent || (0, agent_1.getDefaultAgent)();
                      cid = principal_1.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
                      arg = candid_1.IDL.encode(func.argTypes, args);
                      _context45.next = 7;
                      return agent.query(cid, {
                        methodName: methodName,
                        arg: arg,
                        effectiveCanisterId: options.effectiveCanisterId
                      });

                    case 7:
                      result = _context45.sent;
                      httpDetails = Object.assign(Object.assign({}, result.httpDetails), {
                        requestDetails: result.requestDetails
                      });
                      _context45.t0 = result.status;
                      _context45.next = _context45.t0 === "rejected" ? 12 : _context45.t0 === "replied" ? 13 : 14;
                      break;

                    case 12:
                      throw new QueryCallRejectedError(cid, methodName, result);

                    case 13:
                      return _context45.abrupt("return", func.annotations.includes(exports.ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
                        httpDetails: httpDetails,
                        result: decodeReturnValue(func.retTypes, result.reply.arg)
                      } : decodeReturnValue(func.retTypes, result.reply.arg));

                    case 14:
                    case "end":
                      return _context45.stop();
                  }
                }
              }, _callee42);
            }));

            return function caller(_x60) {
              return _ref116.apply(this, arguments);
            };
          }();
        } else {
          caller = /*#__PURE__*/function () {
            var _ref117 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(options) {
              var _a,
                  _b,
                  _len17,
                  args,
                  _key19,
                  agent,
                  _Object$assign,
                  canisterId,
                  effectiveCanisterId,
                  pollingStrategyFactory,
                  cid,
                  ecid,
                  arg,
                  _yield$agent$call,
                  requestId,
                  response,
                  requestDetails,
                  reply,
                  certificate,
                  cert,
                  path,
                  status,
                  rejectCode,
                  rejectMessage,
                  error_code_buf,
                  error_code,
                  _response$body,
                  reject_code,
                  reject_message,
                  _error_code,
                  pollStrategy,
                  response2,
                  shouldIncludeHttpDetails,
                  shouldIncludeCertificate,
                  httpDetails,
                  _args47 = arguments;

              return _regeneratorRuntime().wrap(function _callee43$(_context46) {
                while (1) {
                  switch (_context46.prev = _context46.next) {
                    case 0:
                      for (_len17 = _args47.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key19 = 1; _key19 < _len17; _key19++) {
                        args[_key19 - 1] = _args47[_key19];
                      }

                      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
                      agent = options.agent || actor[metadataSymbol].config.agent || (0, agent_1.getDefaultAgent)();
                      _Object$assign = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options), canisterId = _Object$assign.canisterId, effectiveCanisterId = _Object$assign.effectiveCanisterId, pollingStrategyFactory = _Object$assign.pollingStrategyFactory;
                      cid = principal_1.Principal.from(canisterId);
                      ecid = effectiveCanisterId !== void 0 ? principal_1.Principal.from(effectiveCanisterId) : cid;
                      arg = candid_1.IDL.encode(func.argTypes, args);
                      _context46.next = 9;
                      return agent.call(cid, {
                        methodName: methodName,
                        arg: arg,
                        effectiveCanisterId: ecid
                      });

                    case 9:
                      _yield$agent$call = _context46.sent;
                      requestId = _yield$agent$call.requestId;
                      response = _yield$agent$call.response;
                      requestDetails = _yield$agent$call.requestDetails;

                      if (!(response.body && response.body.certificate)) {
                        _context46.next = 34;
                        break;
                      }

                      if (!(agent.rootKey == null)) {
                        _context46.next = 16;
                        break;
                      }

                      throw new Error("Agent is missing root key");

                    case 16:
                      cert = response.body.certificate;
                      _context46.next = 19;
                      return certificate_1.Certificate.create({
                        certificate: (0, candid_1.bufFromBufLike)(cert),
                        rootKey: agent.rootKey,
                        canisterId: principal_1.Principal.from(canisterId),
                        blsVerify: blsVerify
                      });

                    case 19:
                      certificate = _context46.sent;
                      path = [new TextEncoder().encode("request_status"), requestId];
                      status = new TextDecoder().decode((0, certificate_1.lookupResultToBuffer)(certificate.lookup([].concat(path, ["status"]))));
                      _context46.t0 = status;
                      _context46.next = _context46.t0 === "replied" ? 25 : _context46.t0 === "rejected" ? 27 : 32;
                      break;

                    case 25:
                      reply = (0, certificate_1.lookupResultToBuffer)(certificate.lookup([].concat(path, ["reply"])));
                      return _context46.abrupt("break", 32);

                    case 27:
                      rejectCode = new Uint8Array((0, certificate_1.lookupResultToBuffer)(certificate.lookup([].concat(path, ["reject_code"]))))[0];
                      rejectMessage = new TextDecoder().decode((0, certificate_1.lookupResultToBuffer)(certificate.lookup([].concat(path, ["reject_message"]))));
                      error_code_buf = (0, certificate_1.lookupResultToBuffer)(certificate.lookup([].concat(path, ["error_code"])));
                      error_code = error_code_buf ? new TextDecoder().decode(error_code_buf) : void 0;
                      throw new UpdateCallRejectedError(cid, methodName, requestId, response, rejectCode, rejectMessage, error_code);

                    case 32:
                      _context46.next = 37;
                      break;

                    case 34:
                      if (!(response.body && "reject_message" in response.body)) {
                        _context46.next = 37;
                        break;
                      }

                      _response$body = response.body, reject_code = _response$body.reject_code, reject_message = _response$body.reject_message, _error_code = _response$body.error_code;
                      throw new UpdateCallRejectedError(cid, methodName, requestId, response, reject_code, reject_message, _error_code);

                    case 37:
                      if (!(response.status === 202)) {
                        _context46.next = 44;
                        break;
                      }

                      pollStrategy = pollingStrategyFactory();
                      _context46.next = 41;
                      return (0, polling_1.pollForResponse)(agent, ecid, requestId, pollStrategy, blsVerify);

                    case 41:
                      response2 = _context46.sent;
                      certificate = response2.certificate;
                      reply = response2.reply;

                    case 44:
                      shouldIncludeHttpDetails = func.annotations.includes(exports.ACTOR_METHOD_WITH_HTTP_DETAILS);
                      shouldIncludeCertificate = func.annotations.includes(exports.ACTOR_METHOD_WITH_CERTIFICATE);
                      httpDetails = Object.assign(Object.assign({}, response), {
                        requestDetails: requestDetails
                      });

                      if (!(reply !== void 0)) {
                        _context46.next = 61;
                        break;
                      }

                      if (!(shouldIncludeHttpDetails && shouldIncludeCertificate)) {
                        _context46.next = 52;
                        break;
                      }

                      return _context46.abrupt("return", {
                        httpDetails: httpDetails,
                        certificate: certificate,
                        result: decodeReturnValue(func.retTypes, reply)
                      });

                    case 52:
                      if (!shouldIncludeCertificate) {
                        _context46.next = 56;
                        break;
                      }

                      return _context46.abrupt("return", {
                        certificate: certificate,
                        result: decodeReturnValue(func.retTypes, reply)
                      });

                    case 56:
                      if (!shouldIncludeHttpDetails) {
                        _context46.next = 58;
                        break;
                      }

                      return _context46.abrupt("return", {
                        httpDetails: httpDetails,
                        result: decodeReturnValue(func.retTypes, reply)
                      });

                    case 58:
                      return _context46.abrupt("return", decodeReturnValue(func.retTypes, reply));

                    case 61:
                      if (!(func.retTypes.length === 0)) {
                        _context46.next = 65;
                        break;
                      }

                      return _context46.abrupt("return", shouldIncludeHttpDetails ? {
                        httpDetails: response,
                        result: void 0
                      } : void 0);

                    case 65:
                      throw new Error("Call was returned undefined, but type [" + func.retTypes.join(",") + "].");

                    case 66:
                    case "end":
                      return _context46.stop();
                  }
                }
              }, _callee43);
            }));

            return function caller(_x61) {
              return _ref117.apply(this, arguments);
            };
          }();
        }

        var handler = function handler() {
          for (var _len18 = arguments.length, args = new Array(_len18), _key20 = 0; _key20 < _len18; _key20++) {
            args[_key20] = arguments[_key20];
          }

          return caller.apply(void 0, [{}].concat(args));
        };

        handler.withOptions = function (options) {
          return function () {
            for (var _len19 = arguments.length, args = new Array(_len19), _key21 = 0; _key21 < _len19; _key21++) {
              args[_key21] = arguments[_key21];
            }

            return caller.apply(void 0, [options].concat(args));
          };
        };

        return handler;
      }

      function getManagementCanister(config) {
        function transform(methodName, args) {
          if (config.effectiveCanisterId) {
            return {
              effectiveCanisterId: principal_1.Principal.from(config.effectiveCanisterId)
            };
          }

          var first = args[0];
          var effectiveCanisterId = principal_1.Principal.fromHex("");

          if (first && typeof first === "object" && first.target_canister && methodName === "install_chunked_code") {
            effectiveCanisterId = principal_1.Principal.from(first.target_canister);
          }

          if (first && typeof first === "object" && first.canister_id) {
            effectiveCanisterId = principal_1.Principal.from(first.canister_id);
          }

          return {
            effectiveCanisterId: effectiveCanisterId
          };
        }

        return Actor.createActor(management_idl_1["default"], Object.assign(Object.assign(Object.assign({}, config), {
          canisterId: principal_1.Principal.fromHex("")
        }), {
          callTransform: transform,
          queryTransform: transform
        }));
      }

      exports.getManagementCanister = getManagementCanister;

      var AdvancedActor = /*#__PURE__*/function (_Actor3) {
        _inheritsLoose(AdvancedActor, _Actor3);

        function AdvancedActor(metadata) {
          return _Actor3.call(this, metadata) || this;
        }

        return AdvancedActor;
      }(Actor);

      exports.AdvancedActor = AdvancedActor;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/canisters/asset_idl.js


  var require_asset_idl = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/canisters/asset_idl.js": function node_modulesDfinityAgentLibCjsCanistersAsset_idlJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports["default"] = function (_ref118) {
        var IDL = _ref118.IDL;
        return IDL.Service({
          retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ["query"]),
          store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], [])
        });
      };
    }
  }); // node_modules/@dfinity/agent/lib/cjs/canisters/asset.js


  var require_asset = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/canisters/asset.js": function node_modulesDfinityAgentLibCjsCanistersAssetJs(exports) {
      "use strict";

      var __importDefault = exports && exports.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAssetCanisterActor = void 0;
      var actor_1 = require_actor();

      var asset_idl_1 = __importDefault(require_asset_idl());

      function createAssetCanisterActor(config) {
        return actor_1.Actor.createActor(asset_idl_1["default"], config);
      }

      exports.createAssetCanisterActor = createAssetCanisterActor;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/fetch_candid.js


  var require_fetch_candid = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/fetch_candid.js": function node_modulesDfinityAgentLibCjsFetch_candidJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fetchCandid = void 0;
      var principal_1 = require_cjs();

      var CanisterStatus = __importStar(require_canisterStatus());

      var http_1 = require_http();
      var actor_1 = require_actor();

      function fetchCandid(_x62, _x63) {
        return _fetchCandid.apply(this, arguments);
      }

      function _fetchCandid() {
        _fetchCandid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(canisterId, agent) {
          var status, candid, tmpHackInterface, actor;
          return _regeneratorRuntime().wrap(function _callee44$(_context47) {
            while (1) {
              switch (_context47.prev = _context47.next) {
                case 0:
                  if (agent) {
                    _context47.next = 4;
                    break;
                  }

                  _context47.next = 3;
                  return http_1.HttpAgent.create();

                case 3:
                  agent = _context47.sent;

                case 4:
                  _context47.next = 6;
                  return CanisterStatus.request({
                    agent: agent,
                    canisterId: principal_1.Principal.fromText(canisterId),
                    paths: ["candid"]
                  });

                case 6:
                  status = _context47.sent;
                  candid = status.get("candid");

                  if (!candid) {
                    _context47.next = 10;
                    break;
                  }

                  return _context47.abrupt("return", candid);

                case 10:
                  tmpHackInterface = function tmpHackInterface(_ref119) {
                    var IDL = _ref119.IDL;
                    return IDL.Service({
                      __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ["query"])
                    });
                  };

                  actor = actor_1.Actor.createActor(tmpHackInterface, {
                    agent: agent,
                    canisterId: canisterId
                  });
                  _context47.next = 14;
                  return actor.__get_candid_interface_tmp_hack();

                case 14:
                  return _context47.abrupt("return", _context47.sent);

                case 15:
                case "end":
                  return _context47.stop();
              }
            }
          }, _callee44);
        }));
        return _fetchCandid.apply(this, arguments);
      }

      exports.fetchCandid = fetchCandid;
    }
  }); // node_modules/@dfinity/agent/lib/cjs/index.js


  var require_cjs3 = __commonJS({
    "node_modules/@dfinity/agent/lib/cjs/index.js": function node_modulesDfinityAgentLibCjsIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Cbor = exports.CanisterStatus = exports.polling = void 0;

      __exportStar(require_actor(), exports);

      __exportStar(require_agent(), exports);

      __exportStar(require_transforms(), exports);

      __exportStar(require_types2(), exports);

      __exportStar(require_auth(), exports);

      __exportStar(require_asset(), exports);

      __exportStar(require_certificate(), exports);

      __exportStar(require_der(), exports);

      __exportStar(require_fetch_candid(), exports);

      __exportStar(require_observable(), exports);

      __exportStar(require_public_key(), exports);

      __exportStar(require_request_id(), exports);

      __exportStar(require_bls2(), exports);

      __exportStar(require_buffer2(), exports);

      __exportStar(require_random(), exports);

      exports.polling = __importStar(require_polling());
      exports.CanisterStatus = __importStar(require_canisterStatus());
      exports.Cbor = __importStar(require_cbor());

      __exportStar(require_polling(), exports);
    }
  }); // node_modules/@dfinity/identity/lib/cjs/identity/ed25519.js


  var require_ed255192 = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/identity/ed25519.js": function node_modulesDfinityIdentityLibCjsIdentityEd25519Js(exports) {
      "use strict";

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _Ed25519PublicKey_rawKey;

      var _Ed25519PublicKey_derKey;

      var _Ed25519KeyIdentity_publicKey;

      var _Ed25519KeyIdentity_privateKey;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Ed25519KeyIdentity = exports.Ed25519PublicKey = void 0;
      var agent_1 = require_cjs3();
      var agent_2 = require_cjs3();
      var ed25519_1 = require_ed25519();

      function isObject(value) {
        return value !== null && typeof value === "object";
      }

      var Ed25519PublicKey = /*#__PURE__*/function () {
        // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
        function _Ed25519PublicKey(key) {
          _Ed25519PublicKey_rawKey.set(this, void 0);

          _Ed25519PublicKey_derKey.set(this, void 0);

          if (key.byteLength !== _Ed25519PublicKey.RAW_KEY_LENGTH) {
            throw new Error("An Ed25519 public key must be exactly 32bytes long");
          }

          __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, (0, agent_2.bufFromBufLike)(key), "f");

          __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, _Ed25519PublicKey.derEncode(key), "f");
        }
        /**
         * Construct Ed25519PublicKey from an existing PublicKey
         * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string
         * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey
         */


        _Ed25519PublicKey.from = function from(maybeKey) {
          if (typeof maybeKey === "string") {
            var key = (0, agent_2.fromHex)(maybeKey);
            return this.fromRaw(key);
          } else if (isObject(maybeKey)) {
            var _key22 = maybeKey;

            if (isObject(_key22) && Object.hasOwnProperty.call(_key22, "__derEncodedPublicKey__")) {
              return this.fromDer(_key22);
            } else if (ArrayBuffer.isView(_key22)) {
              var view = _key22;
              return this.fromRaw((0, agent_2.bufFromBufLike)(view.buffer));
            } else if (_key22 instanceof ArrayBuffer) {
              return this.fromRaw(_key22);
            } else if ("rawKey" in _key22) {
              return this.fromRaw(_key22.rawKey);
            } else if ("derKey" in _key22) {
              return this.fromDer(_key22.derKey);
            } else if ("toDer" in _key22) {
              return this.fromDer(_key22.toDer());
            }
          }

          throw new Error("Cannot construct Ed25519PublicKey from the provided key.");
        };

        _Ed25519PublicKey.fromRaw = function fromRaw(rawKey) {
          return new _Ed25519PublicKey(rawKey);
        };

        _Ed25519PublicKey.fromDer = function fromDer(derKey) {
          return new _Ed25519PublicKey(this.derDecode(derKey));
        };

        _Ed25519PublicKey.derEncode = function derEncode(publicKey) {
          var key = (0, agent_2.wrapDER)(publicKey, agent_2.ED25519_OID).buffer;
          key.__derEncodedPublicKey__ = void 0;
          return key;
        };

        _Ed25519PublicKey.derDecode = function derDecode(key) {
          var unwrapped = (0, agent_2.unwrapDER)(key, agent_2.ED25519_OID);

          if (unwrapped.length !== this.RAW_KEY_LENGTH) {
            throw new Error("An Ed25519 public key must be exactly 32bytes long");
          }

          return (0, agent_2.bufFromBufLike)(unwrapped);
        };

        var _proto79 = _Ed25519PublicKey.prototype;

        _proto79.toDer = function toDer() {
          return this.derKey;
        };

        _proto79.toRaw = function toRaw() {
          return this.rawKey;
        };

        _createClass(_Ed25519PublicKey, [{
          key: "rawKey",
          get: function get() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
          }
        }, {
          key: "derKey",
          get: function get() {
            return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
          }
        }]);

        return _Ed25519PublicKey;
      }();

      exports.Ed25519PublicKey = Ed25519PublicKey;
      _Ed25519PublicKey_rawKey = /* @__PURE__ */new WeakMap(), _Ed25519PublicKey_derKey = /* @__PURE__ */new WeakMap();
      Ed25519PublicKey.RAW_KEY_LENGTH = 32;

      var Ed25519KeyIdentity = /*#__PURE__*/function (_agent_2$SignIdentity) {
        _inheritsLoose(_Ed25519KeyIdentity, _agent_2$SignIdentity);

        // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
        function _Ed25519KeyIdentity(publicKey, privateKey) {
          var _this62;

          _this62 = _agent_2$SignIdentity.call(this) || this;

          _Ed25519KeyIdentity_publicKey.set(_assertThisInitialized(_this62), void 0);

          _Ed25519KeyIdentity_privateKey.set(_assertThisInitialized(_this62), void 0);

          __classPrivateFieldSet(_assertThisInitialized(_this62), _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), "f");

          __classPrivateFieldSet(_assertThisInitialized(_this62), _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), "f");

          return _this62;
        }
        /**
         * Generate a new Ed25519KeyIdentity.
         * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.
         * @returns Ed25519KeyIdentity
         */


        _Ed25519KeyIdentity.generate = function generate(seed) {
          if (seed && seed.length !== 32) {
            throw new Error("Ed25519 Seed needs to be 32 bytes long.");
          }

          if (!seed) seed = ed25519_1.ed25519.utils.randomPrivateKey();

          if ((0, agent_1.bufEquals)(seed, new Uint8Array(new Array(32).fill(0)))) {
            console.warn("Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.");
          }

          var sk = new Uint8Array(32);

          for (var i = 0; i < 32; i++) {
            sk[i] = new Uint8Array(seed)[i];
          }

          var pk = ed25519_1.ed25519.getPublicKey(sk);
          return _Ed25519KeyIdentity.fromKeyPair(pk, sk);
        };

        _Ed25519KeyIdentity.fromParsedJson = function fromParsedJson(obj) {
          var publicKeyDer = obj[0],
              privateKeyRaw = obj[1];
          return new _Ed25519KeyIdentity(Ed25519PublicKey.fromDer((0, agent_2.fromHex)(publicKeyDer)), (0, agent_2.fromHex)(privateKeyRaw));
        };

        _Ed25519KeyIdentity.fromJSON = function fromJSON(json) {
          var parsed = JSON.parse(json);

          if (Array.isArray(parsed)) {
            if (typeof parsed[0] === "string" && typeof parsed[1] === "string") {
              return this.fromParsedJson([parsed[0], parsed[1]]);
            } else {
              throw new Error("Deserialization error: JSON must have at least 2 items.");
            }
          }

          throw new Error("Deserialization error: Invalid JSON type for string: " + JSON.stringify(json));
        };

        _Ed25519KeyIdentity.fromKeyPair = function fromKeyPair(publicKey, privateKey) {
          return new _Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
        };

        _Ed25519KeyIdentity.fromSecretKey = function fromSecretKey(secretKey) {
          var publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          return _Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);
        }
        /**
         * Serialize this key to JSON.
         */
        ;

        var _proto80 = _Ed25519KeyIdentity.prototype;

        _proto80.toJSON = function toJSON() {
          return [(0, agent_2.toHex)(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f").toDer()), (0, agent_2.toHex)(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"))];
        }
        /**
         * Return a copy of the key pair.
         */
        ;

        _proto80.getKeyPair = function getKeyPair() {
          return {
            secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"),
            publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f")
          };
        }
        /**
         * Return the public key.
         */
        ;

        _proto80.getPublicKey = function getPublicKey() {
          return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f");
        }
        /**
         * Signs a blob of data, with this identity's private key.
         * @param challenge - challenge to sign with this identity's secretKey, producing a signature
         */
        ;

        _proto80.sign =
        /*#__PURE__*/
        function () {
          var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(challenge) {
            var blob, signature;
            return _regeneratorRuntime().wrap(function _callee45$(_context48) {
              while (1) {
                switch (_context48.prev = _context48.next) {
                  case 0:
                    blob = new Uint8Array(challenge);
                    signature = (0, agent_2.uint8ToBuf)(ed25519_1.ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f").slice(0, 32)));
                    Object.defineProperty(signature, "__signature__", {
                      enumerable: false,
                      value: void 0
                    });
                    return _context48.abrupt("return", signature);

                  case 4:
                  case "end":
                    return _context48.stop();
                }
              }
            }, _callee45, this);
          }));

          function sign(_x64) {
            return _sign.apply(this, arguments);
          }

          return sign;
        }()
        /**
         * Verify
         * @param sig - signature to verify
         * @param msg - message to verify
         * @param pk - public key
         * @returns - true if the signature is valid, false otherwise
         */
        ;

        _Ed25519KeyIdentity.verify = function verify(sig, msg, pk) {
          var _map = [sig, msg, pk].map(function (x) {
            if (typeof x === "string") {
              x = (0, agent_2.fromHex)(x);
            }

            if (x instanceof Uint8Array) {
              x = (0, agent_2.bufFromBufLike)(x.buffer);
            }

            return new Uint8Array(x);
          }),
              signature = _map[0],
              message = _map[1],
              publicKey = _map[2];

          return ed25519_1.ed25519.verify(signature, message, publicKey);
        };

        return _Ed25519KeyIdentity;
      }(agent_2.SignIdentity);

      exports.Ed25519KeyIdentity = Ed25519KeyIdentity;
      _Ed25519KeyIdentity_publicKey = /* @__PURE__ */new WeakMap(), _Ed25519KeyIdentity_privateKey = /* @__PURE__ */new WeakMap();
    }
  }); // node_modules/@dfinity/identity/lib/cjs/identity/ecdsa.js


  var require_ecdsa = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/identity/ecdsa.js": function node_modulesDfinityIdentityLibCjsIdentityEcdsaJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ECDSAKeyIdentity = exports.CryptoError = void 0;
      var agent_1 = require_cjs3();

      var CryptoError = /*#__PURE__*/function (_Error3) {
        _inheritsLoose(_CryptoError, _Error3);

        function _CryptoError(message) {
          var _this63;

          _this63 = _Error3.call(this, message) || this;
          _this63.message = message;
          Object.setPrototypeOf(_assertThisInitialized(_this63), _CryptoError.prototype);
          return _this63;
        }

        return _CryptoError;
      }( /*#__PURE__*/_wrapNativeSuper(Error));

      exports.CryptoError = CryptoError;

      function _getEffectiveCrypto(subtleCrypto) {
        if (typeof global !== "undefined" && global["crypto"] && global["crypto"]["subtle"]) {
          return global["crypto"]["subtle"];
        }

        if (subtleCrypto) {
          return subtleCrypto;
        } else if (typeof crypto !== "undefined" && crypto["subtle"]) {
          return crypto.subtle;
        } else {
          throw new CryptoError("Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto");
        }
      }

      var ECDSAKeyIdentity = /*#__PURE__*/function (_agent_1$SignIdentity) {
        _inheritsLoose(_ECDSAKeyIdentity, _agent_1$SignIdentity);

        // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.
        function _ECDSAKeyIdentity(keyPair, derKey, subtleCrypto) {
          var _this64;

          _this64 = _agent_1$SignIdentity.call(this) || this;
          _this64._keyPair = keyPair;
          _this64._derKey = derKey;
          _this64._subtleCrypto = subtleCrypto;
          return _this64;
        }
        /**
         * Generates a randomly generated identity for use in calls to the Internet Computer.
         * @param {CryptoKeyOptions} options optional settings
         * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.
         * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for
         * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface
         * @constructs ECDSAKeyIdentity
         * @returns a {@link ECDSAKeyIdentity}
         */


        _ECDSAKeyIdentity.generate =
        /*#__PURE__*/
        function () {
          var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(options) {
            var _ref120, _ref120$extractable, extractable, _ref120$keyUsages, keyUsages, subtleCrypto, effectiveCrypto, keyPair, derKey;

            return _regeneratorRuntime().wrap(function _callee46$(_context49) {
              while (1) {
                switch (_context49.prev = _context49.next) {
                  case 0:
                    _ref120 = options !== null && options !== void 0 ? options : {}, _ref120$extractable = _ref120.extractable, extractable = _ref120$extractable === void 0 ? false : _ref120$extractable, _ref120$keyUsages = _ref120.keyUsages, keyUsages = _ref120$keyUsages === void 0 ? ["sign", "verify"] : _ref120$keyUsages, subtleCrypto = _ref120.subtleCrypto;
                    effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
                    _context49.next = 4;
                    return effectiveCrypto.generateKey({
                      name: "ECDSA",
                      namedCurve: "P-256"
                    }, extractable, keyUsages);

                  case 4:
                    keyPair = _context49.sent;
                    _context49.next = 7;
                    return effectiveCrypto.exportKey("spki", keyPair.publicKey);

                  case 7:
                    derKey = _context49.sent;
                    return _context49.abrupt("return", new this(keyPair, derKey, effectiveCrypto));

                  case 9:
                  case "end":
                    return _context49.stop();
                }
              }
            }, _callee46, this);
          }));

          function generate(_x65) {
            return _generate.apply(this, arguments);
          }

          return generate;
        }()
        /**
         * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key
         * @param keyPair a CryptoKeyPair
         * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally
         * @returns an {@link ECDSAKeyIdentity}
         */
        ;

        _ECDSAKeyIdentity.fromKeyPair =
        /*#__PURE__*/
        function () {
          var _fromKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(keyPair, subtleCrypto) {
            var effectiveCrypto, derKey;
            return _regeneratorRuntime().wrap(function _callee47$(_context50) {
              while (1) {
                switch (_context50.prev = _context50.next) {
                  case 0:
                    effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
                    _context50.next = 3;
                    return effectiveCrypto.exportKey("spki", keyPair.publicKey);

                  case 3:
                    derKey = _context50.sent;
                    return _context50.abrupt("return", new _ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto));

                  case 5:
                  case "end":
                    return _context50.stop();
                }
              }
            }, _callee47);
          }));

          function fromKeyPair(_x66, _x67) {
            return _fromKeyPair.apply(this, arguments);
          }

          return fromKeyPair;
        }()
        /**
         * Return the internally-used key pair.
         * @returns a CryptoKeyPair
         */
        ;

        var _proto81 = _ECDSAKeyIdentity.prototype;

        _proto81.getKeyPair = function getKeyPair() {
          return this._keyPair;
        }
        /**
         * Return the public key.
         * @returns an {@link PublicKey & DerCryptoKey}
         */
        ;

        _proto81.getPublicKey = function getPublicKey() {
          var derKey = this._derKey;
          var key = Object.create(this._keyPair.publicKey);

          key.toDer = function () {
            return derKey;
          };

          return key;
        }
        /**
         * Signs a blob of data, with this identity's private key.
         * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature
         * @returns {Promise<Signature>} signature
         */
        ;

        _proto81.sign =
        /*#__PURE__*/
        function () {
          var _sign2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(challenge) {
            var params, signature;
            return _regeneratorRuntime().wrap(function _callee48$(_context51) {
              while (1) {
                switch (_context51.prev = _context51.next) {
                  case 0:
                    params = {
                      name: "ECDSA",
                      hash: {
                        name: "SHA-256"
                      }
                    };
                    _context51.next = 3;
                    return this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);

                  case 3:
                    signature = _context51.sent;
                    return _context51.abrupt("return", signature);

                  case 5:
                  case "end":
                    return _context51.stop();
                }
              }
            }, _callee48, this);
          }));

          function sign(_x68) {
            return _sign2.apply(this, arguments);
          }

          return sign;
        }();

        return _ECDSAKeyIdentity;
      }(agent_1.SignIdentity);

      exports.ECDSAKeyIdentity = ECDSAKeyIdentity;
      exports["default"] = ECDSAKeyIdentity;
    }
  }); // node_modules/@dfinity/identity/lib/cjs/identity/partial.js


  var require_partial = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/identity/partial.js": function node_modulesDfinityIdentityLibCjsIdentityPartialJs(exports) {
      "use strict";

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _PartialIdentity_inner;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PartialIdentity = void 0;
      var principal_1 = require_cjs();

      var PartialIdentity = /*#__PURE__*/function () {
        function PartialIdentity(inner) {
          _PartialIdentity_inner.set(this, void 0);

          __classPrivateFieldSet(this, _PartialIdentity_inner, inner, "f");
        }
        /**
         * The raw public key of this identity.
         */


        var _proto82 = PartialIdentity.prototype;

        /**
         * The DER-encoded public key of this identity.
         */
        _proto82.toDer = function toDer() {
          return __classPrivateFieldGet(this, _PartialIdentity_inner, "f").toDer();
        }
        /**
         * The inner {@link PublicKey} used by this identity.
         */
        ;

        _proto82.getPublicKey = function getPublicKey() {
          return __classPrivateFieldGet(this, _PartialIdentity_inner, "f");
        }
        /**
         * The {@link Principal} of this identity.
         */
        ;

        _proto82.getPrincipal = function getPrincipal() {
          if (!__classPrivateFieldGet(this, _PartialIdentity_inner, "f").rawKey) {
            throw new Error("Cannot get principal from a public key without a raw key.");
          }

          return principal_1.Principal.fromUint8Array(new Uint8Array(__classPrivateFieldGet(this, _PartialIdentity_inner, "f").rawKey));
        }
        /**
         * Required for the Identity interface, but cannot implemented for just a public key.
         */
        ;

        _proto82.transformRequest = function transformRequest() {
          return Promise.reject("Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.");
        };

        _createClass(PartialIdentity, [{
          key: "rawKey",
          get: function get() {
            return __classPrivateFieldGet(this, _PartialIdentity_inner, "f").rawKey;
          }
          /**
           * The DER-encoded public key of this identity.
           */

        }, {
          key: "derKey",
          get: function get() {
            return __classPrivateFieldGet(this, _PartialIdentity_inner, "f").derKey;
          }
        }]);

        return PartialIdentity;
      }();

      exports.PartialIdentity = PartialIdentity;
      _PartialIdentity_inner = /* @__PURE__ */new WeakMap();
    }
  }); // node_modules/@dfinity/identity/lib/cjs/identity/delegation.js


  var require_delegation = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/identity/delegation.js": function node_modulesDfinityIdentityLibCjsIdentityDelegationJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function (o, v) {
        Object.defineProperty(o, "default", {
          enumerable: true,
          value: v
        });
      } : function (o, v) {
        o["default"] = v;
      });

      var __importStar = exports && exports.__importStar || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};

        if (mod != null) {
          for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
        }

        __setModuleDefault(result, mod);

        return result;
      };

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var __rest = exports && exports.__rest || function (s, e) {
        var t = {};

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        }

        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
      };

      var _PartialDelegationIdentity_delegation;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDelegationValid = exports.PartialDelegationIdentity = exports.DelegationIdentity = exports.DelegationChain = exports.Delegation = void 0;
      var agent_1 = require_cjs3();
      var principal_1 = require_cjs();

      var cbor = __importStar(require_src2());

      var partial_1 = require_partial();
      var candid_1 = require_cjs2();
      var domainSeparator = new TextEncoder().encode("ic-request-auth-delegation");
      var requestDomainSeparator = new TextEncoder().encode("\nic-request");

      function _parseBlob(value) {
        if (typeof value !== "string" || value.length < 64) {
          throw new Error("Invalid public key.");
        }

        return (0, agent_1.fromHex)(value);
      }

      var Delegation = /*#__PURE__*/function () {
        function Delegation(pubkey, expiration, targets) {
          this.pubkey = pubkey;
          this.expiration = expiration;
          this.targets = targets;
        }

        var _proto83 = Delegation.prototype;

        _proto83.toCBOR = function toCBOR() {
          return cbor.value.map(Object.assign({
            pubkey: cbor.value.bytes(this.pubkey),
            expiration: cbor.value.u64(this.expiration.toString(16), 16)
          }, this.targets && {
            targets: cbor.value.array(this.targets.map(function (t) {
              return cbor.value.bytes((0, candid_1.bufFromBufLike)(t.toUint8Array()));
            }))
          }));
        };

        _proto83.toJSON = function toJSON() {
          return Object.assign({
            expiration: this.expiration.toString(16),
            pubkey: (0, agent_1.toHex)(this.pubkey)
          }, this.targets && {
            targets: this.targets.map(function (p) {
              return p.toHex();
            })
          });
        };

        return Delegation;
      }();

      exports.Delegation = Delegation;

      function _createSingleDelegation(_x69, _x70, _x71, _x72) {
        return _createSingleDelegation2.apply(this, arguments);
      }

      function _createSingleDelegation2() {
        _createSingleDelegation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51(from, to, expiration, targets) {
          var delegation, challenge, signature;
          return _regeneratorRuntime().wrap(function _callee51$(_context54) {
            while (1) {
              switch (_context54.prev = _context54.next) {
                case 0:
                  delegation = new Delegation(to.toDer(), BigInt(+expiration) * BigInt(1e6), // In nanoseconds.
                  targets);
                  challenge = new Uint8Array([].concat(domainSeparator, new Uint8Array((0, agent_1.requestIdOf)(Object.assign({}, delegation)))));
                  _context54.next = 4;
                  return from.sign((0, candid_1.bufFromBufLike)(challenge));

                case 4:
                  signature = _context54.sent;
                  return _context54.abrupt("return", {
                    delegation: delegation,
                    signature: signature
                  });

                case 6:
                case "end":
                  return _context54.stop();
              }
            }
          }, _callee51);
        }));
        return _createSingleDelegation2.apply(this, arguments);
      }

      var DelegationChain = /*#__PURE__*/function () {
        function _DelegationChain(delegations, publicKey) {
          this.delegations = delegations;
          this.publicKey = publicKey;
        }
        /**
         * Create a delegation chain between two (or more) keys. By default, the expiration time
         * will be very short (15 minutes).
         *
         * To build a chain of more than 2 identities, this function needs to be called multiple times,
         * passing the previous delegation chain into the options argument. For example:
         * @example
         * const rootKey = createKey();
         * const middleKey = createKey();
         * const bottomeKey = createKey();
         *
         * const rootToMiddle = await DelegationChain.create(
         *   root, middle.getPublicKey(), Date.parse('2100-01-01'),
         * );
         * const middleToBottom = await DelegationChain.create(
         *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },
         * );
         *
         * // We can now use a delegation identity that uses the delegation above:
         * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);
         * @param from The identity that will delegate.
         * @param to The identity that gets delegated. It can now sign messages as if it was the
         *           identity above.
         * @param expiration The length the delegation is valid. By default, 15 minutes from calling
         *                   this function.
         * @param options A set of options for this delegation. expiration and previous
         * @param options.previous - Another DelegationChain that this chain should start with.
         * @param options.targets - targets that scope the delegation (e.g. Canister Principals)
         */


        _DelegationChain.create =
        /*#__PURE__*/
        function () {
          var _create3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(from, to, expiration, options) {
            var _a, _b, delegation;

            return _regeneratorRuntime().wrap(function _callee49$(_context52) {
              while (1) {
                switch (_context52.prev = _context52.next) {
                  case 0:
                    if (expiration === void 0) {
                      expiration = new Date(Date.now() + 15 * 60 * 1e3);
                    }

                    if (options === void 0) {
                      options = {};
                    }

                    _context52.next = 4;
                    return _createSingleDelegation(from, to, expiration, options.targets);

                  case 4:
                    delegation = _context52.sent;
                    return _context52.abrupt("return", new _DelegationChain([].concat(((_a = options.previous) === null || _a === void 0 ? void 0 : _a.delegations) || [], [delegation]), ((_b = options.previous) === null || _b === void 0 ? void 0 : _b.publicKey) || from.getPublicKey().toDer()));

                  case 6:
                  case "end":
                    return _context52.stop();
                }
              }
            }, _callee49);
          }));

          function create(_x73, _x74, _x75, _x76) {
            return _create3.apply(this, arguments);
          }

          return create;
        }()
        /**
         * Creates a DelegationChain object from a JSON string.
         * @param json The JSON string to parse.
         */
        ;

        _DelegationChain.fromJSON = function fromJSON(json) {
          var _ref121 = typeof json === "string" ? JSON.parse(json) : json,
              publicKey = _ref121.publicKey,
              delegations = _ref121.delegations;

          if (!Array.isArray(delegations)) {
            throw new Error("Invalid delegations.");
          }

          var parsedDelegations = delegations.map(function (signedDelegation) {
            var delegation = signedDelegation.delegation,
                signature = signedDelegation.signature;
            var pubkey = delegation.pubkey,
                expiration = delegation.expiration,
                targets = delegation.targets;

            if (targets !== void 0 && !Array.isArray(targets)) {
              throw new Error("Invalid targets.");
            }

            return {
              delegation: new Delegation(_parseBlob(pubkey), BigInt("0x" + expiration), // expiration in JSON is an hexa string (See toJSON() below).
              targets && targets.map(function (t) {
                if (typeof t !== "string") {
                  throw new Error("Invalid target.");
                }

                return principal_1.Principal.fromHex(t);
              })),
              signature: _parseBlob(signature)
            };
          });
          return new this(parsedDelegations, _parseBlob(publicKey));
        }
        /**
         * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.
         * @param delegations The list of delegations.
         * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.
         */
        ;

        _DelegationChain.fromDelegations = function fromDelegations(delegations, publicKey) {
          return new this(delegations, publicKey);
        };

        var _proto84 = _DelegationChain.prototype;

        _proto84.toJSON = function toJSON() {
          return {
            delegations: this.delegations.map(function (signedDelegation) {
              var delegation = signedDelegation.delegation,
                  signature = signedDelegation.signature;
              var targets = delegation.targets;
              return {
                delegation: Object.assign({
                  expiration: delegation.expiration.toString(16),
                  pubkey: (0, agent_1.toHex)(delegation.pubkey)
                }, targets && {
                  targets: targets.map(function (t) {
                    return t.toHex();
                  })
                }),
                signature: (0, agent_1.toHex)(signature)
              };
            }),
            publicKey: (0, agent_1.toHex)(this.publicKey)
          };
        };

        return _DelegationChain;
      }();

      exports.DelegationChain = DelegationChain;

      var DelegationIdentity = /*#__PURE__*/function (_agent_1$SignIdentity2) {
        _inheritsLoose(DelegationIdentity, _agent_1$SignIdentity2);

        function DelegationIdentity(_inner, _delegation) {
          var _this65;

          _this65 = _agent_1$SignIdentity2.call(this) || this;
          _this65._inner = _inner;
          _this65._delegation = _delegation;
          return _this65;
        }
        /**
         * Create a delegation without having access to delegateKey.
         * @param key The key used to sign the requests.
         * @param delegation A delegation object created using `createDelegation`.
         */


        DelegationIdentity.fromDelegation = function fromDelegation(key, delegation) {
          return new this(key, delegation);
        };

        var _proto85 = DelegationIdentity.prototype;

        _proto85.getDelegation = function getDelegation() {
          return this._delegation;
        };

        _proto85.getPublicKey = function getPublicKey() {
          var _this66 = this;

          return {
            derKey: this._delegation.publicKey,
            toDer: function toDer() {
              return _this66._delegation.publicKey;
            }
          };
        };

        _proto85.sign = function sign(blob) {
          return this._inner.sign(blob);
        };

        _proto85.transformRequest = /*#__PURE__*/function () {
          var _transformRequest3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(request) {
            var body, fields, requestId;
            return _regeneratorRuntime().wrap(function _callee50$(_context53) {
              while (1) {
                switch (_context53.prev = _context53.next) {
                  case 0:
                    body = request.body, fields = __rest(request, ["body"]);
                    _context53.next = 3;
                    return (0, agent_1.requestIdOf)(body);

                  case 3:
                    requestId = _context53.sent;
                    _context53.t0 = Object;
                    _context53.t1 = Object.assign({}, fields);
                    _context53.t2 = body;
                    _context53.next = 9;
                    return this.sign((0, candid_1.bufFromBufLike)(function () {
                      var rid = new Uint8Array(requestId);
                      var arr = new Uint8Array(requestDomainSeparator.length + rid.length);
                      arr.set(requestDomainSeparator);
                      arr.set(rid, requestDomainSeparator.length);
                      return arr;
                    }()));

                  case 9:
                    _context53.t3 = _context53.sent;
                    _context53.t4 = this._delegation.delegations;
                    _context53.t5 = this._delegation.publicKey;
                    _context53.t6 = {
                      content: _context53.t2,
                      sender_sig: _context53.t3,
                      sender_delegation: _context53.t4,
                      sender_pubkey: _context53.t5
                    };
                    _context53.t7 = {
                      body: _context53.t6
                    };
                    return _context53.abrupt("return", _context53.t0.assign.call(_context53.t0, _context53.t1, _context53.t7));

                  case 15:
                  case "end":
                    return _context53.stop();
                }
              }
            }, _callee50, this);
          }));

          function transformRequest(_x77) {
            return _transformRequest3.apply(this, arguments);
          }

          return transformRequest;
        }();

        return DelegationIdentity;
      }(agent_1.SignIdentity);

      exports.DelegationIdentity = DelegationIdentity;

      var PartialDelegationIdentity = /*#__PURE__*/function (_partial_1$PartialIde) {
        _inheritsLoose(_PartialDelegationIdentity, _partial_1$PartialIde);

        function _PartialDelegationIdentity(inner, delegation) {
          var _this67;

          _this67 = _partial_1$PartialIde.call(this, inner) || this;

          _PartialDelegationIdentity_delegation.set(_assertThisInitialized(_this67), void 0);

          __classPrivateFieldSet(_assertThisInitialized(_this67), _PartialDelegationIdentity_delegation, delegation, "f");

          return _this67;
        }
        /**
         * The Delegation Chain of this identity.
         */


        /**
         * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.
         * @param key The {@link PublicKey} to delegate to.
         * @param delegation a {@link DelegationChain} targeting the inner key.
         * @constructs PartialDelegationIdentity
         */
        _PartialDelegationIdentity.fromDelegation = function fromDelegation(key, delegation) {
          return new _PartialDelegationIdentity(key, delegation);
        };

        _createClass(_PartialDelegationIdentity, [{
          key: "delegation",
          get: function get() {
            return __classPrivateFieldGet(this, _PartialDelegationIdentity_delegation, "f");
          }
        }]);

        return _PartialDelegationIdentity;
      }(partial_1.PartialIdentity);

      exports.PartialDelegationIdentity = PartialDelegationIdentity;
      _PartialDelegationIdentity_delegation = /* @__PURE__ */new WeakMap();

      function isDelegationValid(chain, checks) {
        for (var _iterator34 = _createForOfIteratorHelperLoose(chain.delegations), _step34; !(_step34 = _iterator34()).done;) {
          var _delegation2 = _step34.value.delegation;

          if (+new Date(Number(_delegation2.expiration / BigInt(1e6))) <= +Date.now()) {
            return false;
          }
        }

        var scopes = [];
        var maybeScope = checks === null || checks === void 0 ? void 0 : checks.scope;

        if (maybeScope) {
          if (Array.isArray(maybeScope)) {
            scopes.push.apply(scopes, maybeScope.map(function (s) {
              return typeof s === "string" ? principal_1.Principal.fromText(s) : s;
            }));
          } else {
            scopes.push(typeof maybeScope === "string" ? principal_1.Principal.fromText(maybeScope) : maybeScope);
          }
        }

        for (var _i18 = 0, _scopes = scopes; _i18 < _scopes.length; _i18++) {
          var s = _scopes[_i18];
          var scope = s.toText();

          for (var _iterator35 = _createForOfIteratorHelperLoose(chain.delegations), _step35; !(_step35 = _iterator35()).done;) {
            var delegation = _step35.value.delegation;

            if (delegation.targets === void 0) {
              continue;
            }

            var none = true;

            for (var _iterator36 = _createForOfIteratorHelperLoose(delegation.targets), _step36; !(_step36 = _iterator36()).done;) {
              var target = _step36.value;

              if (target.toText() === scope) {
                none = false;
                break;
              }
            }

            if (none) {
              return false;
            }
          }
        }

        return true;
      }

      exports.isDelegationValid = isDelegationValid;
    }
  }); // node_modules/@dfinity/identity/node_modules/buffer/index.js


  var require_buffer5 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/buffer/index.js": function node_modulesDfinityIdentityNode_modulesBufferIndexJs(exports) {
      "use strict";

      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();

      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }

      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = {
            foo: function foo() {
              return 42;
            }
          };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }

      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function get() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });

      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }

        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }

          return allocUnsafe(arg);
        }

        return from(arg, encodingOrOffset, length);
      }

      Buffer2.poolSize = 8192;

      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }

        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }

        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }

        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }

        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }

        var valueOf = value.valueOf && value.valueOf();

        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }

        var b = fromObject(value);
        if (b) return b;

        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }

        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }

      Buffer2.from = function (value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };

      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);

      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }

      function alloc(size, fill, encoding) {
        assertSize(size);

        if (size <= 0) {
          return createBuffer(size);
        }

        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }

        return createBuffer(size);
      }

      Buffer2.alloc = function (size, fill, encoding) {
        return alloc(size, fill, encoding);
      };

      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }

      Buffer2.allocUnsafe = function (size) {
        return allocUnsafe(size);
      };

      Buffer2.allocUnsafeSlow = function (size) {
        return allocUnsafe(size);
      };

      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }

        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }

        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);

        if (actual !== length) {
          buf = buf.slice(0, actual);
        }

        return buf;
      }

      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);

        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }

        return buf;
      }

      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }

        return fromArrayLike(arrayView);
      }

      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }

        var buf;

        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }

        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }

      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);

          if (buf.length === 0) {
            return buf;
          }

          obj.copy(buf, 0, 0, len);
          return buf;
        }

        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }

          return fromArrayLike(obj);
        }

        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }

      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }

        return length | 0;
      }

      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }

        return Buffer2.alloc(+length);
      }

      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };

      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);

        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }

        if (a === b) return 0;
        var x = a.length;
        var y = b.length;

        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;

          default:
            return false;
        }
      };

      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        if (list.length === 0) {
          return Buffer2.alloc(0);
        }

        var i;

        if (length === void 0) {
          length = 0;

          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }

        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;

        for (i = 0; i < list.length; ++i) {
          var buf = list[i];

          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer2.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }

          pos += buf.length;
        }

        return buffer;
      };

      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }

        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }

        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }

        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;

            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;

            case "hex":
              return len >>> 1;

            case "base64":
              return base64ToBytes(string).length;

            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }

              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.byteLength = byteLength;

      function slowToString(encoding, start, end) {
        var loweredCase = false;

        if (start === void 0 || start < 0) {
          start = 0;
        }

        if (start > this.length) {
          return "";
        }

        if (end === void 0 || end > this.length) {
          end = this.length;
        }

        if (end <= 0) {
          return "";
        }

        end >>>= 0;
        start >>>= 0;

        if (end <= start) {
          return "";
        }

        if (!encoding) encoding = "utf8";

        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);

            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);

            case "ascii":
              return asciiSlice(this, start, end);

            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);

            case "base64":
              return base64Slice(this, start, end);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }

      Buffer2.prototype._isBuffer = true;

      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }

      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;

        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }

        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }

        return this;
      };

      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;

        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }

        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }

        return this;
      };

      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;

        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }

        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }

        return this;
      };

      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };

      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;

      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };

      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };

      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }

      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }

        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }

        if (start === void 0) {
          start = 0;
        }

        if (end === void 0) {
          end = target ? target.length : 0;
        }

        if (thisStart === void 0) {
          thisStart = 0;
        }

        if (thisEnd === void 0) {
          thisEnd = this.length;
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }

        if (thisStart >= thisEnd) {
          return -1;
        }

        if (start >= end) {
          return 1;
        }

        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);

        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }

        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };

      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;

        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }

        byteOffset = +byteOffset;

        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }

        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

        if (byteOffset >= buffer.length) {
          if (dir) return -1;else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;else return -1;
        }

        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }

        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }

          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;

          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }

          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }

        throw new TypeError("val must be string, number or Buffer");
      }

      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;

        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();

          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }

            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }

        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }

        var i;

        if (dir) {
          var foundIndex = -1;

          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

          for (i = byteOffset; i >= 0; i--) {
            var found = true;

            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }

            if (found) return i;
          }
        }

        return -1;
      }

      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };

      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };

      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };

      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;

        if (!length) {
          length = remaining;
        } else {
          length = Number(length);

          if (length > remaining) {
            length = remaining;
          }
        }

        var strLen = string.length;

        if (length > strLen / 2) {
          length = strLen / 2;
        }

        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }

        return i;
      }

      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }

      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }

      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }

      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }

      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;

          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }

        var remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;

        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }

        if (!encoding) encoding = "utf8";
        var loweredCase = false;

        for (;;) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);

            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);

            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);

            case "base64":
              return base64Write(this, string, offset, length);

            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);

            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };

      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };

      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }

      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;

        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;

          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }

                break;

              case 2:
                secondByte = buf[i + 1];

                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;

                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;

                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }

                break;

              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];

                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;

                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }

            }
          }

          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }

          res.push(codePoint);
          i += bytesPerSequence;
        }

        return decodeCodePointsArray(res);
      }

      var MAX_ARGUMENTS_LENGTH = 4096;

      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;

        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }

        var res = "";
        var i = 0;

        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }

        return res;
      }

      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }

        return ret;
      }

      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }

        return ret;
      }

      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        var out = "";

        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }

        return out;
      }

      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";

        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }

        return res;
      }

      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;

        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }

        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }

        if (end < start) end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };

      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }

      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }

        var val = this[offset + --byteLength2];
        var mul = 1;

        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }

        return val;
      };

      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };

      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };

      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };

      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };

      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };

      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;

        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];

        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }

        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };

      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };

      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };

      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };

      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };

      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };

      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };

      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };

      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };

      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }

      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var mul = 1;
        var i = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;

        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;

        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }

        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;

        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }

          this[offset + i] = (value / mul >> 0) - sub & 255;
        }

        return offset + byteLength2;
      };

      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };

      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };

      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };

      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };

      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };

      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }

      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }

        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }

      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };

      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;

        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }

        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }

      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };

      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };

      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;

        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }

        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;

        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }

        var len = end - start;

        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }

        return len;
      };

      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }

          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }

          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }

          if (val.length === 1) {
            var code = val.charCodeAt(0);

            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }

        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }

        if (end <= start) {
          return this;
        }

        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        var i;

        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          var len = bytes.length;

          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }

          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }

        return this;
      };

      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";

        while (str.length % 4 !== 0) {
          str = str + "=";
        }

        return str;
      }

      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];

        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);

          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }

              leadSurrogate = codePoint;
              continue;
            }

            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }

            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }

          leadSurrogate = null;

          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }

        return bytes;
      }

      function asciiToBytes(str) {
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }

        return byteArray;
      }

      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];

        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }

        return byteArray;
      }

      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }

      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }

        return i;
      }

      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }

      function numberIsNaN(obj) {
        return obj !== obj;
      }

      var hexSliceLookupTable = function () {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);

        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;

          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }

        return table;
      }();
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/decoder.asm.js


  var require_decoder_asm2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/decoder.asm.js": function node_modulesDfinityIdentityNode_modulesBorcSrcDecoderAsmJs(exports, module) {
      module.exports = function decodeAsm(stdlib, foreign, buffer) {
        ;
        var heap = new stdlib.Uint8Array(buffer);
        var pushInt = foreign.pushInt;
        var pushInt32 = foreign.pushInt32;
        var pushInt32Neg = foreign.pushInt32Neg;
        var pushInt64 = foreign.pushInt64;
        var pushInt64Neg = foreign.pushInt64Neg;
        var pushFloat = foreign.pushFloat;
        var pushFloatSingle = foreign.pushFloatSingle;
        var pushFloatDouble = foreign.pushFloatDouble;
        var pushTrue = foreign.pushTrue;
        var pushFalse = foreign.pushFalse;
        var pushUndefined = foreign.pushUndefined;
        var pushNull = foreign.pushNull;
        var pushInfinity = foreign.pushInfinity;
        var pushInfinityNeg = foreign.pushInfinityNeg;
        var pushNaN = foreign.pushNaN;
        var pushNaNNeg = foreign.pushNaNNeg;
        var pushArrayStart = foreign.pushArrayStart;
        var pushArrayStartFixed = foreign.pushArrayStartFixed;
        var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
        var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
        var pushObjectStart = foreign.pushObjectStart;
        var pushObjectStartFixed = foreign.pushObjectStartFixed;
        var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
        var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
        var pushByteString = foreign.pushByteString;
        var pushByteStringStart = foreign.pushByteStringStart;
        var pushUtf8String = foreign.pushUtf8String;
        var pushUtf8StringStart = foreign.pushUtf8StringStart;
        var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
        var pushTagStart = foreign.pushTagStart;
        var pushTagStart4 = foreign.pushTagStart4;
        var pushTagStart8 = foreign.pushTagStart8;
        var pushTagUnassigned = foreign.pushTagUnassigned;
        var pushBreak = foreign.pushBreak;
        var pow = stdlib.Math.pow;
        var offset = 0;
        var inputLength = 0;
        var code = 0;

        function parse(input) {
          input = input | 0;
          offset = 0;
          inputLength = input;

          while ((offset | 0) < (inputLength | 0)) {
            code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;

            if ((code | 0) > 0) {
              break;
            }
          }

          return code | 0;
        }

        function checkOffset(n) {
          n = n | 0;

          if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
            return 0;
          }

          return 1;
        }

        function readUInt16(n) {
          n = n | 0;
          return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
        }

        function readUInt32(n) {
          n = n | 0;
          return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
        }

        function INT_P(octet) {
          octet = octet | 0;
          pushInt(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function UINT_P_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushInt(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function UINT_P_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushInt(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function UINT_P_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushInt32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function UINT_P_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushInt64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function INT_N(octet) {
          octet = octet | 0;
          pushInt(-1 - (octet - 32 | 0) | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function UINT_N_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushInt(-1 - (heap[offset + 1 | 0] | 0) | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function UINT_N_16(octet) {
          octet = octet | 0;
          var val = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          val = readUInt16(offset + 1 | 0) | 0;
          pushInt(-1 - (val | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function UINT_N_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushInt32Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function UINT_N_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushInt64Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function BYTE_STRING(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var step = 0;
          step = octet - 64 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          start = offset + 1 | 0;
          end = (offset + 1 | 0) + (step | 0) | 0;
          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_8(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          length = heap[offset + 1 | 0] | 0;
          start = offset + 2 | 0;
          end = (offset + 2 | 0) + (length | 0) | 0;

          if (checkOffset(length + 1 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_16(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          length = readUInt16(offset + 1 | 0) | 0;
          start = offset + 3 | 0;
          end = (offset + 3 | 0) + (length | 0) | 0;

          if (checkOffset(length + 2 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_32(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          length = readUInt32(offset + 1 | 0) | 0;
          start = offset + 5 | 0;
          end = (offset + 5 | 0) + (length | 0) | 0;

          if (checkOffset(length + 4 | 0) | 0) {
            return 1;
          }

          pushByteString(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function BYTE_STRING_64(octet) {
          octet = octet | 0;
          return 1;
        }

        function BYTE_STRING_BREAK(octet) {
          octet = octet | 0;
          pushByteStringStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function UTF8_STRING(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var step = 0;
          step = octet - 96 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          start = offset + 1 | 0;
          end = (offset + 1 | 0) + (step | 0) | 0;
          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_8(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          length = heap[offset + 1 | 0] | 0;
          start = offset + 2 | 0;
          end = (offset + 2 | 0) + (length | 0) | 0;

          if (checkOffset(length + 1 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_16(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          length = readUInt16(offset + 1 | 0) | 0;
          start = offset + 3 | 0;
          end = (offset + 3 | 0) + (length | 0) | 0;

          if (checkOffset(length + 2 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_32(octet) {
          octet = octet | 0;
          var start = 0;
          var end = 0;
          var length = 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          length = readUInt32(offset + 1 | 0) | 0;
          start = offset + 5 | 0;
          end = (offset + 5 | 0) + (length | 0) | 0;

          if (checkOffset(length + 4 | 0) | 0) {
            return 1;
          }

          pushUtf8String(start | 0, end | 0);
          offset = end | 0;
          return 0;
        }

        function UTF8_STRING_64(octet) {
          octet = octet | 0;
          return 1;
        }

        function UTF8_STRING_BREAK(octet) {
          octet = octet | 0;
          pushUtf8StringStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function ARRAY(octet) {
          octet = octet | 0;
          pushArrayStartFixed(octet - 128 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function ARRAY_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushArrayStartFixed(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function ARRAY_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushArrayStartFixed(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function ARRAY_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushArrayStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function ARRAY_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushArrayStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function ARRAY_BREAK(octet) {
          octet = octet | 0;
          pushArrayStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function MAP(octet) {
          octet = octet | 0;
          var step = 0;
          step = octet - 160 | 0;

          if (checkOffset(step | 0) | 0) {
            return 1;
          }

          pushObjectStartFixed(step | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function MAP_8(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushObjectStartFixed(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function MAP_16(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushObjectStartFixed(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function MAP_32(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushObjectStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function MAP_64(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushObjectStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function MAP_BREAK(octet) {
          octet = octet | 0;
          pushObjectStart();
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_KNOWN(octet) {
          octet = octet | 0;
          pushTagStart(octet - 192 | 0 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_POS(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_NEG(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_FRAC(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BIGNUM_FLOAT(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_UNASSIGNED(octet) {
          octet = octet | 0;
          pushTagStart(octet - 192 | 0 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE64_URL(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE64(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_BASE16(octet) {
          octet = octet | 0;
          pushTagStart(octet | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function TAG_MORE_1(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushTagStart(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function TAG_MORE_2(octet) {
          octet = octet | 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          pushTagStart(readUInt16(offset + 1 | 0) | 0);
          offset = offset + 3 | 0;
          return 0;
        }

        function TAG_MORE_4(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushTagStart4(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function TAG_MORE_8(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushTagStart8(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function SIMPLE_UNASSIGNED(octet) {
          octet = octet | 0;
          pushSimpleUnassigned((octet | 0) - 224 | 0);
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_FALSE(octet) {
          octet = octet | 0;
          pushFalse();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_TRUE(octet) {
          octet = octet | 0;
          pushTrue();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_NULL(octet) {
          octet = octet | 0;
          pushNull();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_UNDEFINED(octet) {
          octet = octet | 0;
          pushUndefined();
          offset = offset + 1 | 0;
          return 0;
        }

        function SIMPLE_BYTE(octet) {
          octet = octet | 0;

          if (checkOffset(1) | 0) {
            return 1;
          }

          pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
          offset = offset + 2 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_HALF(octet) {
          octet = octet | 0;
          var f = 0;
          var g = 0;
          var sign = 1;
          var exp = 0;
          var mant = 0;
          var r = 0;

          if (checkOffset(2) | 0) {
            return 1;
          }

          f = heap[offset + 1 | 0] | 0;
          g = heap[offset + 2 | 0] | 0;

          if ((f | 0) & 128) {
            sign = -1;
          }

          exp = +(((f | 0) & 124) >> 2);
          mant = +(((f | 0) & 3) << 8 | g);

          if (+exp == 0) {
            pushFloat(+(+sign * 5960464477539063e-23 * +mant));
          } else if (+exp == 31) {
            if (+sign == 1) {
              if (+mant > 0) {
                pushNaN();
              } else {
                pushInfinity();
              }
            } else {
              if (+mant > 0) {
                pushNaNNeg();
              } else {
                pushInfinityNeg();
              }
            }
          } else {
            pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
          }

          offset = offset + 3 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_SINGLE(octet) {
          octet = octet | 0;

          if (checkOffset(4) | 0) {
            return 1;
          }

          pushFloatSingle(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0);
          offset = offset + 5 | 0;
          return 0;
        }

        function SIMPLE_FLOAT_DOUBLE(octet) {
          octet = octet | 0;

          if (checkOffset(8) | 0) {
            return 1;
          }

          pushFloatDouble(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0, heap[offset + 5 | 0] | 0, heap[offset + 6 | 0] | 0, heap[offset + 7 | 0] | 0, heap[offset + 8 | 0] | 0);
          offset = offset + 9 | 0;
          return 0;
        }

        function ERROR(octet) {
          octet = octet | 0;
          return 1;
        }

        function BREAK(octet) {
          octet = octet | 0;
          pushBreak();
          offset = offset + 1 | 0;
          return 0;
        }

        var jumpTable = [// Integer 0x00..0x17 (0..23)
        INT_P, // 0x00
        INT_P, // 0x01
        INT_P, // 0x02
        INT_P, // 0x03
        INT_P, // 0x04
        INT_P, // 0x05
        INT_P, // 0x06
        INT_P, // 0x07
        INT_P, // 0x08
        INT_P, // 0x09
        INT_P, // 0x0A
        INT_P, // 0x0B
        INT_P, // 0x0C
        INT_P, // 0x0D
        INT_P, // 0x0E
        INT_P, // 0x0F
        INT_P, // 0x10
        INT_P, // 0x11
        INT_P, // 0x12
        INT_P, // 0x13
        INT_P, // 0x14
        INT_P, // 0x15
        INT_P, // 0x16
        INT_P, // 0x17
        // Unsigned integer (one-byte uint8_t follows)
        UINT_P_8, // 0x18
        // Unsigned integer (two-byte uint16_t follows)
        UINT_P_16, // 0x19
        // Unsigned integer (four-byte uint32_t follows)
        UINT_P_32, // 0x1a
        // Unsigned integer (eight-byte uint64_t follows)
        UINT_P_64, // 0x1b
        ERROR, // 0x1c
        ERROR, // 0x1d
        ERROR, // 0x1e
        ERROR, // 0x1f
        // Negative integer -1-0x00..-1-0x17 (-1..-24)
        INT_N, // 0x20
        INT_N, // 0x21
        INT_N, // 0x22
        INT_N, // 0x23
        INT_N, // 0x24
        INT_N, // 0x25
        INT_N, // 0x26
        INT_N, // 0x27
        INT_N, // 0x28
        INT_N, // 0x29
        INT_N, // 0x2A
        INT_N, // 0x2B
        INT_N, // 0x2C
        INT_N, // 0x2D
        INT_N, // 0x2E
        INT_N, // 0x2F
        INT_N, // 0x30
        INT_N, // 0x31
        INT_N, // 0x32
        INT_N, // 0x33
        INT_N, // 0x34
        INT_N, // 0x35
        INT_N, // 0x36
        INT_N, // 0x37
        // Negative integer -1-n (one-byte uint8_t for n follows)
        UINT_N_8, // 0x38
        // Negative integer -1-n (two-byte uint16_t for n follows)
        UINT_N_16, // 0x39
        // Negative integer -1-n (four-byte uint32_t for nfollows)
        UINT_N_32, // 0x3a
        // Negative integer -1-n (eight-byte uint64_t for n follows)
        UINT_N_64, // 0x3b
        ERROR, // 0x3c
        ERROR, // 0x3d
        ERROR, // 0x3e
        ERROR, // 0x3f
        // byte string (0x00..0x17 bytes follow)
        BYTE_STRING, // 0x40
        BYTE_STRING, // 0x41
        BYTE_STRING, // 0x42
        BYTE_STRING, // 0x43
        BYTE_STRING, // 0x44
        BYTE_STRING, // 0x45
        BYTE_STRING, // 0x46
        BYTE_STRING, // 0x47
        BYTE_STRING, // 0x48
        BYTE_STRING, // 0x49
        BYTE_STRING, // 0x4A
        BYTE_STRING, // 0x4B
        BYTE_STRING, // 0x4C
        BYTE_STRING, // 0x4D
        BYTE_STRING, // 0x4E
        BYTE_STRING, // 0x4F
        BYTE_STRING, // 0x50
        BYTE_STRING, // 0x51
        BYTE_STRING, // 0x52
        BYTE_STRING, // 0x53
        BYTE_STRING, // 0x54
        BYTE_STRING, // 0x55
        BYTE_STRING, // 0x56
        BYTE_STRING, // 0x57
        // byte string (one-byte uint8_t for n, and then n bytes follow)
        BYTE_STRING_8, // 0x58
        // byte string (two-byte uint16_t for n, and then n bytes follow)
        BYTE_STRING_16, // 0x59
        // byte string (four-byte uint32_t for n, and then n bytes follow)
        BYTE_STRING_32, // 0x5a
        // byte string (eight-byte uint64_t for n, and then n bytes follow)
        BYTE_STRING_64, // 0x5b
        ERROR, // 0x5c
        ERROR, // 0x5d
        ERROR, // 0x5e
        // byte string, byte strings follow, terminated by "break"
        BYTE_STRING_BREAK, // 0x5f
        // UTF-8 string (0x00..0x17 bytes follow)
        UTF8_STRING, // 0x60
        UTF8_STRING, // 0x61
        UTF8_STRING, // 0x62
        UTF8_STRING, // 0x63
        UTF8_STRING, // 0x64
        UTF8_STRING, // 0x65
        UTF8_STRING, // 0x66
        UTF8_STRING, // 0x67
        UTF8_STRING, // 0x68
        UTF8_STRING, // 0x69
        UTF8_STRING, // 0x6A
        UTF8_STRING, // 0x6B
        UTF8_STRING, // 0x6C
        UTF8_STRING, // 0x6D
        UTF8_STRING, // 0x6E
        UTF8_STRING, // 0x6F
        UTF8_STRING, // 0x70
        UTF8_STRING, // 0x71
        UTF8_STRING, // 0x72
        UTF8_STRING, // 0x73
        UTF8_STRING, // 0x74
        UTF8_STRING, // 0x75
        UTF8_STRING, // 0x76
        UTF8_STRING, // 0x77
        // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
        UTF8_STRING_8, // 0x78
        // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
        UTF8_STRING_16, // 0x79
        // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
        UTF8_STRING_32, // 0x7a
        // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
        UTF8_STRING_64, // 0x7b
        // UTF-8 string, UTF-8 strings follow, terminated by "break"
        ERROR, // 0x7c
        ERROR, // 0x7d
        ERROR, // 0x7e
        UTF8_STRING_BREAK, // 0x7f
        // array (0x00..0x17 data items follow)
        ARRAY, // 0x80
        ARRAY, // 0x81
        ARRAY, // 0x82
        ARRAY, // 0x83
        ARRAY, // 0x84
        ARRAY, // 0x85
        ARRAY, // 0x86
        ARRAY, // 0x87
        ARRAY, // 0x88
        ARRAY, // 0x89
        ARRAY, // 0x8A
        ARRAY, // 0x8B
        ARRAY, // 0x8C
        ARRAY, // 0x8D
        ARRAY, // 0x8E
        ARRAY, // 0x8F
        ARRAY, // 0x90
        ARRAY, // 0x91
        ARRAY, // 0x92
        ARRAY, // 0x93
        ARRAY, // 0x94
        ARRAY, // 0x95
        ARRAY, // 0x96
        ARRAY, // 0x97
        // array (one-byte uint8_t fo, and then n data items follow)
        ARRAY_8, // 0x98
        // array (two-byte uint16_t for n, and then n data items follow)
        ARRAY_16, // 0x99
        // array (four-byte uint32_t for n, and then n data items follow)
        ARRAY_32, // 0x9a
        // array (eight-byte uint64_t for n, and then n data items follow)
        ARRAY_64, // 0x9b
        // array, data items follow, terminated by "break"
        ERROR, // 0x9c
        ERROR, // 0x9d
        ERROR, // 0x9e
        ARRAY_BREAK, // 0x9f
        // map (0x00..0x17 pairs of data items follow)
        MAP, // 0xa0
        MAP, // 0xa1
        MAP, // 0xa2
        MAP, // 0xa3
        MAP, // 0xa4
        MAP, // 0xa5
        MAP, // 0xa6
        MAP, // 0xa7
        MAP, // 0xa8
        MAP, // 0xa9
        MAP, // 0xaA
        MAP, // 0xaB
        MAP, // 0xaC
        MAP, // 0xaD
        MAP, // 0xaE
        MAP, // 0xaF
        MAP, // 0xb0
        MAP, // 0xb1
        MAP, // 0xb2
        MAP, // 0xb3
        MAP, // 0xb4
        MAP, // 0xb5
        MAP, // 0xb6
        MAP, // 0xb7
        // map (one-byte uint8_t for n, and then n pairs of data items follow)
        MAP_8, // 0xb8
        // map (two-byte uint16_t for n, and then n pairs of data items follow)
        MAP_16, // 0xb9
        // map (four-byte uint32_t for n, and then n pairs of data items follow)
        MAP_32, // 0xba
        // map (eight-byte uint64_t for n, and then n pairs of data items follow)
        MAP_64, // 0xbb
        ERROR, // 0xbc
        ERROR, // 0xbd
        ERROR, // 0xbe
        // map, pairs of data items follow, terminated by "break"
        MAP_BREAK, // 0xbf
        // Text-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc0
        // Epoch-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN, // 0xc1
        // Positive bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc2
        // Negative bignum (data item "byte string" follows)
        TAG_KNOWN, // 0xc3
        // Decimal Fraction (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc4
        // Bigfloat (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN, // 0xc5
        // (tagged item)
        TAG_UNASSIGNED, // 0xc6
        TAG_UNASSIGNED, // 0xc7
        TAG_UNASSIGNED, // 0xc8
        TAG_UNASSIGNED, // 0xc9
        TAG_UNASSIGNED, // 0xca
        TAG_UNASSIGNED, // 0xcb
        TAG_UNASSIGNED, // 0xcc
        TAG_UNASSIGNED, // 0xcd
        TAG_UNASSIGNED, // 0xce
        TAG_UNASSIGNED, // 0xcf
        TAG_UNASSIGNED, // 0xd0
        TAG_UNASSIGNED, // 0xd1
        TAG_UNASSIGNED, // 0xd2
        TAG_UNASSIGNED, // 0xd3
        TAG_UNASSIGNED, // 0xd4
        // Expected Conversion (data item follows; see Section 2.4.4.2)
        TAG_UNASSIGNED, // 0xd5
        TAG_UNASSIGNED, // 0xd6
        TAG_UNASSIGNED, // 0xd7
        // (more tagged items, 1/2/4/8 bytes and then a data item follow)
        TAG_MORE_1, // 0xd8
        TAG_MORE_2, // 0xd9
        TAG_MORE_4, // 0xda
        TAG_MORE_8, // 0xdb
        ERROR, // 0xdc
        ERROR, // 0xdd
        ERROR, // 0xde
        ERROR, // 0xdf
        // (simple value)
        SIMPLE_UNASSIGNED, // 0xe0
        SIMPLE_UNASSIGNED, // 0xe1
        SIMPLE_UNASSIGNED, // 0xe2
        SIMPLE_UNASSIGNED, // 0xe3
        SIMPLE_UNASSIGNED, // 0xe4
        SIMPLE_UNASSIGNED, // 0xe5
        SIMPLE_UNASSIGNED, // 0xe6
        SIMPLE_UNASSIGNED, // 0xe7
        SIMPLE_UNASSIGNED, // 0xe8
        SIMPLE_UNASSIGNED, // 0xe9
        SIMPLE_UNASSIGNED, // 0xea
        SIMPLE_UNASSIGNED, // 0xeb
        SIMPLE_UNASSIGNED, // 0xec
        SIMPLE_UNASSIGNED, // 0xed
        SIMPLE_UNASSIGNED, // 0xee
        SIMPLE_UNASSIGNED, // 0xef
        SIMPLE_UNASSIGNED, // 0xf0
        SIMPLE_UNASSIGNED, // 0xf1
        SIMPLE_UNASSIGNED, // 0xf2
        SIMPLE_UNASSIGNED, // 0xf3
        // False
        SIMPLE_FALSE, // 0xf4
        // True
        SIMPLE_TRUE, // 0xf5
        // Null
        SIMPLE_NULL, // 0xf6
        // Undefined
        SIMPLE_UNDEFINED, // 0xf7
        // (simple value, one byte follows)
        SIMPLE_BYTE, // 0xf8
        // Half-Precision Float (two-byte IEEE 754)
        SIMPLE_FLOAT_HALF, // 0xf9
        // Single-Precision Float (four-byte IEEE 754)
        SIMPLE_FLOAT_SINGLE, // 0xfa
        // Double-Precision Float (eight-byte IEEE 754)
        SIMPLE_FLOAT_DOUBLE, // 0xfb
        ERROR, // 0xfc
        ERROR, // 0xfd
        ERROR, // 0xfe
        // "break" stop code
        BREAK // 0xff
        ];
        return {
          parse: parse
        };
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/constants.js


  var require_constants2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/constants.js": function node_modulesDfinityIdentityNode_modulesBorcSrcConstantsJs(exports) {
      "use strict";

      var Bignumber = require_bignumber().BigNumber;
      exports.MT = {
        POS_INT: 0,
        NEG_INT: 1,
        BYTE_STRING: 2,
        UTF8_STRING: 3,
        ARRAY: 4,
        MAP: 5,
        TAG: 6,
        SIMPLE_FLOAT: 7
      };
      exports.TAG = {
        DATE_STRING: 0,
        DATE_EPOCH: 1,
        POS_BIGINT: 2,
        NEG_BIGINT: 3,
        DECIMAL_FRAC: 4,
        BIGFLOAT: 5,
        BASE64URL_EXPECTED: 21,
        BASE64_EXPECTED: 22,
        BASE16_EXPECTED: 23,
        CBOR: 24,
        URI: 32,
        BASE64URL: 33,
        BASE64: 34,
        REGEXP: 35,
        MIME: 36
      };
      exports.NUMBYTES = {
        ZERO: 0,
        ONE: 24,
        TWO: 25,
        FOUR: 26,
        EIGHT: 27,
        INDEFINITE: 31
      };
      exports.SIMPLE = {
        FALSE: 20,
        TRUE: 21,
        NULL: 22,
        UNDEFINED: 23
      };
      exports.SYMS = {
        NULL: Symbol("null"),
        UNDEFINED: Symbol("undef"),
        PARENT: Symbol("parent"),
        BREAK: Symbol("break"),
        STREAM: Symbol("stream")
      };
      exports.SHIFT32 = Math.pow(2, 32);
      exports.SHIFT16 = Math.pow(2, 16);
      exports.MAX_SAFE_HIGH = 2097151;
      exports.NEG_ONE = new Bignumber(-1);
      exports.TEN = new Bignumber(10);
      exports.TWO = new Bignumber(2);
      exports.PARENT = {
        ARRAY: 0,
        OBJECT: 1,
        MAP: 2,
        TAG: 3,
        BYTE_STRING: 4,
        UTF8_STRING: 5
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/utils.js


  var require_utils4 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/utils.js": function node_modulesDfinityIdentityNode_modulesBorcSrcUtilsJs(exports) {
      "use strict";

      var _require_buffer5 = require_buffer5(),
          Buffer2 = _require_buffer5.Buffer;

      var Bignumber = require_bignumber().BigNumber;
      var constants = require_constants2();
      var SHIFT32 = constants.SHIFT32;
      var SHIFT16 = constants.SHIFT16;
      var MAX_SAFE_HIGH = 2097151;

      exports.parseHalf = function parseHalf(buf) {
        var exp, mant, sign;
        sign = buf[0] & 128 ? -1 : 1;
        exp = (buf[0] & 124) >> 2;
        mant = (buf[0] & 3) << 8 | buf[1];

        if (!exp) {
          return sign * 5960464477539063e-23 * mant;
        } else if (exp === 31) {
          return sign * (mant ? 0 / 0 : Infinity);
        } else {
          return sign * Math.pow(2, exp - 25) * (1024 + mant);
        }
      };

      function toHex(n) {
        if (n < 16) {
          return "0" + n.toString(16);
        }

        return n.toString(16);
      }

      exports.arrayBufferToBignumber = function (buf) {
        var len = buf.byteLength;
        var res = "";

        for (var i = 0; i < len; i++) {
          res += toHex(buf[i]);
        }

        return new Bignumber(res, 16);
      };

      exports.buildMap = function (obj) {
        var res = /* @__PURE__ */new Map();
        var keys = Object.keys(obj);
        var length = keys.length;

        for (var i = 0; i < length; i++) {
          res.set(keys[i], obj[keys[i]]);
        }

        return res;
      };

      exports.buildInt32 = function (f, g) {
        return f * SHIFT16 + g;
      };

      exports.buildInt64 = function (f1, f2, g1, g2) {
        var f = exports.buildInt32(f1, f2);
        var g = exports.buildInt32(g1, g2);

        if (f > MAX_SAFE_HIGH) {
          return new Bignumber(f).times(SHIFT32).plus(g);
        } else {
          return f * SHIFT32 + g;
        }
      };

      exports.writeHalf = function writeHalf(buf, half) {
        var u32 = Buffer2.allocUnsafe(4);
        u32.writeFloatBE(half, 0);
        var u = u32.readUInt32BE(0);

        if ((u & 8191) !== 0) {
          return false;
        }

        var s16 = u >> 16 & 32768;
        var exp = u >> 23 & 255;
        var mant = u & 8388607;

        if (exp >= 113 && exp <= 142) {
          s16 += (exp - 112 << 10) + (mant >> 13);
        } else if (exp >= 103 && exp < 113) {
          if (mant & (1 << 126 - exp) - 1) {
            return false;
          }

          s16 += mant + 8388608 >> 126 - exp;
        } else {
          return false;
        }

        buf.writeUInt16BE(s16, 0);
        return true;
      };

      exports.keySorter = function (a, b) {
        var lenA = a[0].byteLength;
        var lenB = b[0].byteLength;

        if (lenA > lenB) {
          return 1;
        }

        if (lenB > lenA) {
          return -1;
        }

        return a[0].compare(b[0]);
      };

      exports.isNegativeZero = function (x) {
        return x === 0 && 1 / x < 0;
      };

      exports.nextPowerOf2 = function (n) {
        var count = 0;

        if (n && !(n & n - 1)) {
          return n;
        }

        while (n !== 0) {
          n >>= 1;
          count += 1;
        }

        return 1 << count;
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/simple.js


  var require_simple2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/simple.js": function node_modulesDfinityIdentityNode_modulesBorcSrcSimpleJs(exports, module) {
      "use strict";

      var constants = require_constants2();
      var MT = constants.MT;
      var SIMPLE = constants.SIMPLE;
      var SYMS = constants.SYMS;

      var Simple = /*#__PURE__*/function () {
        /**
         * Creates an instance of Simple.
         *
         * @param {integer} value - the simple value's integer value
         */
        function _Simple(value) {
          if (typeof value !== "number") {
            throw new Error("Invalid Simple type: " + typeof value);
          }

          if (value < 0 || value > 255 || (value | 0) !== value) {
            throw new Error("value must be a small positive integer: " + value);
          }

          this.value = value;
        }
        /**
         * Debug string for simple value
         *
         * @returns {string} simple(value)
         */


        var _proto86 = _Simple.prototype;

        _proto86.toString = function toString() {
          return "simple(" + this.value + ")";
        }
        /**
         * Debug string for simple value
         *
         * @returns {string} simple(value)
         */
        ;

        _proto86.inspect = function inspect() {
          return "simple(" + this.value + ")";
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {cbor.Encoder} gen The generator to push onto
         * @returns {number}
         */
        ;

        _proto86.encodeCBOR = function encodeCBOR(gen) {
          return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
        }
        /**
         * Is the given object a Simple?
         *
         * @param {any} obj - object to test
         * @returns {bool} - is it Simple?
         */
        ;

        _Simple.isSimple = function isSimple(obj) {
          return obj instanceof _Simple;
        }
        /**
         * Decode from the CBOR additional information into a JavaScript value.
         * If the CBOR item has no parent, return a "safe" symbol instead of
         * `null` or `undefined`, so that the value can be passed through a
         * stream in object mode.
         *
         * @param {Number} val - the CBOR additional info to convert
         * @param {bool} hasParent - Does the CBOR item have a parent?
         * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
         */
        ;

        _Simple.decode = function decode(val, hasParent) {
          if (hasParent == null) {
            hasParent = true;
          }

          switch (val) {
            case SIMPLE.FALSE:
              return false;

            case SIMPLE.TRUE:
              return true;

            case SIMPLE.NULL:
              if (hasParent) {
                return null;
              } else {
                return SYMS.NULL;
              }

            case SIMPLE.UNDEFINED:
              if (hasParent) {
                return void 0;
              } else {
                return SYMS.UNDEFINED;
              }

            case -1:
              if (!hasParent) {
                throw new Error("Invalid BREAK");
              }

              return SYMS.BREAK;

            default:
              return new _Simple(val);
          }
        };

        return _Simple;
      }();

      module.exports = Simple;
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/tagged.js


  var require_tagged2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/tagged.js": function node_modulesDfinityIdentityNode_modulesBorcSrcTaggedJs(exports, module) {
      "use strict";

      var Tagged = /*#__PURE__*/function () {
        /**
         * Creates an instance of Tagged.
         *
         * @param {Number} tag - the number of the tag
         * @param {any} value - the value inside the tag
         * @param {Error} err - the error that was thrown parsing the tag, or null
         */
        function _Tagged(tag, value, err) {
          this.tag = tag;
          this.value = value;
          this.err = err;

          if (typeof this.tag !== "number") {
            throw new Error("Invalid tag type (" + typeof this.tag + ")");
          }

          if (this.tag < 0 || (this.tag | 0) !== this.tag) {
            throw new Error("Tag must be a positive integer: " + this.tag);
          }
        }
        /**
         * Convert to a String
         *
         * @returns {String} string of the form '1(2)'
         */


        var _proto87 = _Tagged.prototype;

        _proto87.toString = function toString() {
          return this.tag + "(" + JSON.stringify(this.value) + ")";
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {cbor.Encoder} gen The generator to push onto
         * @returns {number}
         */
        ;

        _proto87.encodeCBOR = function encodeCBOR(gen) {
          gen._pushTag(this.tag);

          return gen.pushAny(this.value);
        }
        /**
         * If we have a converter for this type, do the conversion.  Some converters
         * are built-in.  Additional ones can be passed in.  If you want to remove
         * a built-in converter, pass a converter in whose value is 'null' instead
         * of a function.
         *
         * @param {Object} converters - keys in the object are a tag number, the value
         *   is a function that takes the decoded CBOR and returns a JavaScript value
         *   of the appropriate type.  Throw an exception in the function on errors.
         * @returns {any} - the converted item
         */
        ;

        _proto87.convert = function convert(converters) {
          var er, f;
          f = converters != null ? converters[this.tag] : void 0;

          if (typeof f !== "function") {
            f = _Tagged["_tag" + this.tag];

            if (typeof f !== "function") {
              return this;
            }
          }

          try {
            return f.call(_Tagged, this.value);
          } catch (error) {
            er = error;
            this.err = er;
            return this;
          }
        };

        return _Tagged;
      }();

      module.exports = Tagged;
    }
  }); // node_modules/@dfinity/identity/node_modules/iso-url/src/url-browser.js


  var require_url_browser2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/iso-url/src/url-browser.js": function node_modulesDfinityIdentityNode_modulesIsoUrlSrcUrlBrowserJs(exports, module) {
      "use strict";

      var defaultBase = self.location ? self.location.protocol + "//" + self.location.host : "";
      var URL2 = self.URL;

      var URLWithLegacySupport = /*#__PURE__*/function () {
        function URLWithLegacySupport(url, base) {
          if (url === void 0) {
            url = "";
          }

          if (base === void 0) {
            base = defaultBase;
          }

          this["super"] = new URL2(url, base);
          this.path = this.pathname + this.search;
          this.auth = this.username && this.password ? this.username + ":" + this.password : null;
          this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
        }

        var _proto88 = URLWithLegacySupport.prototype;

        _proto88.createObjectURL = function createObjectURL(o) {
          return this["super"].createObjectURL(o);
        };

        _proto88.revokeObjectURL = function revokeObjectURL(o) {
          this["super"].revokeObjectURL(o);
        };

        _proto88.toJSON = function toJSON() {
          return this["super"].toJSON();
        };

        _proto88.toString = function toString() {
          return this["super"].toString();
        };

        _proto88.format = function format() {
          return this.toString();
        };

        _createClass(URLWithLegacySupport, [{
          key: "hash",
          get: function get() {
            return this["super"].hash;
          },
          set: function set(hash) {
            this["super"].hash = hash;
          }
        }, {
          key: "host",
          get: function get() {
            return this["super"].host;
          },
          set: function set(host) {
            this["super"].host = host;
          }
        }, {
          key: "hostname",
          get: function get() {
            return this["super"].hostname;
          },
          set: function set(hostname) {
            this["super"].hostname = hostname;
          }
        }, {
          key: "href",
          get: function get() {
            return this["super"].href;
          },
          set: function set(href) {
            this["super"].href = href;
          }
        }, {
          key: "origin",
          get: function get() {
            return this["super"].origin;
          },
          set: function set(origin) {
            this["super"].origin = origin;
          }
        }, {
          key: "password",
          get: function get() {
            return this["super"].password;
          },
          set: function set(password) {
            this["super"].password = password;
          }
        }, {
          key: "pathname",
          get: function get() {
            return this["super"].pathname;
          },
          set: function set(pathname) {
            this["super"].pathname = pathname;
          }
        }, {
          key: "port",
          get: function get() {
            return this["super"].port;
          },
          set: function set(port) {
            this["super"].port = port;
          }
        }, {
          key: "protocol",
          get: function get() {
            return this["super"].protocol;
          },
          set: function set(protocol) {
            this["super"].protocol = protocol;
          }
        }, {
          key: "search",
          get: function get() {
            return this["super"].search;
          },
          set: function set(search) {
            this["super"].search = search;
          }
        }, {
          key: "searchParams",
          get: function get() {
            return this["super"].searchParams;
          },
          set: function set(searchParams) {
            this["super"].searchParams = searchParams;
          }
        }, {
          key: "username",
          get: function get() {
            return this["super"].username;
          },
          set: function set(username) {
            this["super"].username = username;
          }
        }]);

        return URLWithLegacySupport;
      }();

      function format(obj) {
        if (typeof obj === "string") {
          var url = new URL2(obj);
          return url.toString();
        }

        if (!(obj instanceof URL2)) {
          var userPass = obj.username && obj.password ? obj.username + ":" + obj.password + "@" : "";
          var auth = obj.auth ? obj.auth + "@" : "";
          var port = obj.port ? ":" + obj.port : "";
          var protocol = obj.protocol ? obj.protocol + "//" : "";
          var host = obj.host || "";
          var hostname = obj.hostname || "";
          var search = obj.search || (obj.query ? "?" + obj.query : "");
          var hash = obj.hash || "";
          var pathname = obj.pathname || "";
          var path = obj.path || pathname + search;
          return "" + protocol + (userPass || auth) + (host || hostname + port) + path + hash;
        }
      }

      module.exports = {
        URLWithLegacySupport: URLWithLegacySupport,
        URLSearchParams: self.URLSearchParams,
        defaultBase: defaultBase,
        format: format
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/iso-url/src/relative.js


  var require_relative2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/iso-url/src/relative.js": function node_modulesDfinityIdentityNode_modulesIsoUrlSrcRelativeJs(exports, module) {
      "use strict";

      var _require_url_browser3 = require_url_browser2(),
          URLWithLegacySupport = _require_url_browser3.URLWithLegacySupport,
          format = _require_url_browser3.format;

      module.exports = function (url, location2, protocolMap, defaultProtocol) {
        if (location2 === void 0) {
          location2 = {};
        }

        if (protocolMap === void 0) {
          protocolMap = {};
        }

        var protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
        protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
        var urlParsed;

        try {
          urlParsed = new URLWithLegacySupport(url);
        } catch (err) {
          urlParsed = {};
        }

        var base = Object.assign({}, location2, {
          protocol: protocol || urlParsed.protocol,
          host: location2.host || urlParsed.host
        });
        return new URLWithLegacySupport(url, format(base)).toString();
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/iso-url/index.js


  var require_iso_url2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/iso-url/index.js": function node_modulesDfinityIdentityNode_modulesIsoUrlIndexJs(exports, module) {
      "use strict";

      var _require_url_browser4 = require_url_browser2(),
          URLWithLegacySupport = _require_url_browser4.URLWithLegacySupport,
          format = _require_url_browser4.format,
          URLSearchParams = _require_url_browser4.URLSearchParams,
          defaultBase = _require_url_browser4.defaultBase;

      var relative = require_relative2();
      module.exports = {
        URL: URLWithLegacySupport,
        URLSearchParams: URLSearchParams,
        format: format,
        relative: relative,
        defaultBase: defaultBase
      };
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/decoder.js


  var require_decoder2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/decoder.js": function node_modulesDfinityIdentityNode_modulesBorcSrcDecoderJs(exports, module) {
      "use strict";

      var _require_buffer6 = require_buffer5(),
          Buffer2 = _require_buffer6.Buffer;

      var ieee754 = require_ieee754();
      var Bignumber = require_bignumber().BigNumber;
      var parser = require_decoder_asm2();
      var utils = require_utils4();
      var c = require_constants2();
      var Simple = require_simple2();
      var Tagged = require_tagged2();

      var _require_iso_url3 = require_iso_url2(),
          URL2 = _require_iso_url3.URL;

      var Decoder = /*#__PURE__*/function () {
        /**
         * @param {Object} [opts={}]
         * @param {number} [opts.size=65536] - Size of the allocated heap.
         */
        function _Decoder(opts) {
          opts = opts || {};

          if (!opts.size || opts.size < 65536) {
            opts.size = 65536;
          } else {
            opts.size = utils.nextPowerOf2(opts.size);
          }

          this._heap = new ArrayBuffer(opts.size);
          this._heap8 = new Uint8Array(this._heap);
          this._buffer = Buffer2.from(this._heap);

          this._reset();

          this._knownTags = Object.assign({
            0: function _(val) {
              return new Date(val);
            },
            1: function _(val) {
              return new Date(val * 1e3);
            },
            2: function _(val) {
              return utils.arrayBufferToBignumber(val);
            },
            3: function _(val) {
              return c.NEG_ONE.minus(utils.arrayBufferToBignumber(val));
            },
            4: function _(v) {
              return c.TEN.pow(v[0]).times(v[1]);
            },
            5: function _(v) {
              return c.TWO.pow(v[0]).times(v[1]);
            },
            32: function _(val) {
              return new URL2(val);
            },
            35: function _(val) {
              return new RegExp(val);
            }
          }, opts.tags);
          this.parser = parser(global, {
            // eslint-disable-next-line no-console
            log: console.log.bind(console),
            pushInt: this.pushInt.bind(this),
            pushInt32: this.pushInt32.bind(this),
            pushInt32Neg: this.pushInt32Neg.bind(this),
            pushInt64: this.pushInt64.bind(this),
            pushInt64Neg: this.pushInt64Neg.bind(this),
            pushFloat: this.pushFloat.bind(this),
            pushFloatSingle: this.pushFloatSingle.bind(this),
            pushFloatDouble: this.pushFloatDouble.bind(this),
            pushTrue: this.pushTrue.bind(this),
            pushFalse: this.pushFalse.bind(this),
            pushUndefined: this.pushUndefined.bind(this),
            pushNull: this.pushNull.bind(this),
            pushInfinity: this.pushInfinity.bind(this),
            pushInfinityNeg: this.pushInfinityNeg.bind(this),
            pushNaN: this.pushNaN.bind(this),
            pushNaNNeg: this.pushNaNNeg.bind(this),
            pushArrayStart: this.pushArrayStart.bind(this),
            pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
            pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
            pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
            pushObjectStart: this.pushObjectStart.bind(this),
            pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
            pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
            pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
            pushByteString: this.pushByteString.bind(this),
            pushByteStringStart: this.pushByteStringStart.bind(this),
            pushUtf8String: this.pushUtf8String.bind(this),
            pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
            pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
            pushTagUnassigned: this.pushTagUnassigned.bind(this),
            pushTagStart: this.pushTagStart.bind(this),
            pushTagStart4: this.pushTagStart4.bind(this),
            pushTagStart8: this.pushTagStart8.bind(this),
            pushBreak: this.pushBreak.bind(this)
          }, this._heap);
        }

        var _proto89 = _Decoder.prototype;

        // Finish the current parent
        _proto89._closeParent = function _closeParent() {
          var p = this._parents.pop();

          if (p.length > 0) {
            throw new Error("Missing " + p.length + " elements");
          }

          switch (p.type) {
            case c.PARENT.TAG:
              this._push(this.createTag(p.ref[0], p.ref[1]));

              break;

            case c.PARENT.BYTE_STRING:
              this._push(this.createByteString(p.ref, p.length));

              break;

            case c.PARENT.UTF8_STRING:
              this._push(this.createUtf8String(p.ref, p.length));

              break;

            case c.PARENT.MAP:
              if (p.values % 2 > 0) {
                throw new Error("Odd number of elements in the map");
              }

              this._push(this.createMap(p.ref, p.length));

              break;

            case c.PARENT.OBJECT:
              if (p.values % 2 > 0) {
                throw new Error("Odd number of elements in the map");
              }

              this._push(this.createObject(p.ref, p.length));

              break;

            case c.PARENT.ARRAY:
              this._push(this.createArray(p.ref, p.length));

              break;

            default:
              break;
          }

          if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
            this._dec();
          }
        } // Reduce the expected length of the current parent by one
        ;

        _proto89._dec = function _dec() {
          var p = this._currentParent;

          if (p.length < 0) {
            return;
          }

          p.length--;

          if (p.length === 0) {
            this._closeParent();
          }
        } // Push any value to the current parent
        ;

        _proto89._push = function _push(val, hasChildren) {
          var p = this._currentParent;
          p.values++;

          switch (p.type) {
            case c.PARENT.ARRAY:
            case c.PARENT.BYTE_STRING:
            case c.PARENT.UTF8_STRING:
              if (p.length > -1) {
                this._ref[this._ref.length - p.length] = val;
              } else {
                this._ref.push(val);
              }

              this._dec();

              break;

            case c.PARENT.OBJECT:
              if (p.tmpKey != null) {
                this._ref[p.tmpKey] = val;
                p.tmpKey = null;

                this._dec();
              } else {
                p.tmpKey = val;

                if (typeof p.tmpKey !== "string") {
                  p.type = c.PARENT.MAP;
                  p.ref = utils.buildMap(p.ref);
                }
              }

              break;

            case c.PARENT.MAP:
              if (p.tmpKey != null) {
                this._ref.set(p.tmpKey, val);

                p.tmpKey = null;

                this._dec();
              } else {
                p.tmpKey = val;
              }

              break;

            case c.PARENT.TAG:
              this._ref.push(val);

              if (!hasChildren) {
                this._dec();
              }

              break;

            default:
              throw new Error("Unknown parent type");
          }
        } // Create a new parent in the parents list
        ;

        _proto89._createParent = function _createParent(obj, type, len) {
          this._parents[this._depth] = {
            type: type,
            length: len,
            ref: obj,
            values: 0,
            tmpKey: null
          };
        } // Reset all state back to the beginning, also used for initiatlization
        ;

        _proto89._reset = function _reset() {
          this._res = [];
          this._parents = [{
            type: c.PARENT.ARRAY,
            length: -1,
            ref: this._res,
            values: 0,
            tmpKey: null
          }];
        } // -- Interface to customize deoding behaviour
        ;

        _proto89.createTag = function createTag(tagNumber, value) {
          var typ = this._knownTags[tagNumber];

          if (!typ) {
            return new Tagged(tagNumber, value);
          }

          return typ(value);
        };

        _proto89.createMap = function createMap(obj, len) {
          return obj;
        };

        _proto89.createObject = function createObject(obj, len) {
          return obj;
        };

        _proto89.createArray = function createArray(arr, len) {
          return arr;
        };

        _proto89.createByteString = function createByteString(raw, len) {
          return Buffer2.concat(raw);
        };

        _proto89.createByteStringFromHeap = function createByteStringFromHeap(start, end) {
          if (start === end) {
            return Buffer2.alloc(0);
          }

          return Buffer2.from(this._heap.slice(start, end));
        };

        _proto89.createInt = function createInt(val) {
          return val;
        };

        _proto89.createInt32 = function createInt32(f, g) {
          return utils.buildInt32(f, g);
        };

        _proto89.createInt64 = function createInt64(f1, f2, g1, g2) {
          return utils.buildInt64(f1, f2, g1, g2);
        };

        _proto89.createFloat = function createFloat(val) {
          return val;
        };

        _proto89.createFloatSingle = function createFloatSingle(a, b, c2, d) {
          return ieee754.read([a, b, c2, d], 0, false, 23, 4);
        };

        _proto89.createFloatDouble = function createFloatDouble(a, b, c2, d, e, f, g, h) {
          return ieee754.read([a, b, c2, d, e, f, g, h], 0, false, 52, 8);
        };

        _proto89.createInt32Neg = function createInt32Neg(f, g) {
          return -1 - utils.buildInt32(f, g);
        };

        _proto89.createInt64Neg = function createInt64Neg(f1, f2, g1, g2) {
          var f = utils.buildInt32(f1, f2);
          var g = utils.buildInt32(g1, g2);

          if (f > c.MAX_SAFE_HIGH) {
            return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
          }

          return -1 - (f * c.SHIFT32 + g);
        };

        _proto89.createTrue = function createTrue() {
          return true;
        };

        _proto89.createFalse = function createFalse() {
          return false;
        };

        _proto89.createNull = function createNull() {
          return null;
        };

        _proto89.createUndefined = function createUndefined() {
          return void 0;
        };

        _proto89.createInfinity = function createInfinity() {
          return Infinity;
        };

        _proto89.createInfinityNeg = function createInfinityNeg() {
          return -Infinity;
        };

        _proto89.createNaN = function createNaN() {
          return NaN;
        };

        _proto89.createNaNNeg = function createNaNNeg() {
          return NaN;
        };

        _proto89.createUtf8String = function createUtf8String(raw, len) {
          return raw.join("");
        };

        _proto89.createUtf8StringFromHeap = function createUtf8StringFromHeap(start, end) {
          if (start === end) {
            return "";
          }

          return this._buffer.toString("utf8", start, end);
        };

        _proto89.createSimpleUnassigned = function createSimpleUnassigned(val) {
          return new Simple(val);
        } // -- Interface for decoder.asm.js
        ;

        _proto89.pushInt = function pushInt(val) {
          this._push(this.createInt(val));
        };

        _proto89.pushInt32 = function pushInt32(f, g) {
          this._push(this.createInt32(f, g));
        };

        _proto89.pushInt64 = function pushInt64(f1, f2, g1, g2) {
          this._push(this.createInt64(f1, f2, g1, g2));
        };

        _proto89.pushFloat = function pushFloat(val) {
          this._push(this.createFloat(val));
        };

        _proto89.pushFloatSingle = function pushFloatSingle(a, b, c2, d) {
          this._push(this.createFloatSingle(a, b, c2, d));
        };

        _proto89.pushFloatDouble = function pushFloatDouble(a, b, c2, d, e, f, g, h) {
          this._push(this.createFloatDouble(a, b, c2, d, e, f, g, h));
        };

        _proto89.pushInt32Neg = function pushInt32Neg(f, g) {
          this._push(this.createInt32Neg(f, g));
        };

        _proto89.pushInt64Neg = function pushInt64Neg(f1, f2, g1, g2) {
          this._push(this.createInt64Neg(f1, f2, g1, g2));
        };

        _proto89.pushTrue = function pushTrue() {
          this._push(this.createTrue());
        };

        _proto89.pushFalse = function pushFalse() {
          this._push(this.createFalse());
        };

        _proto89.pushNull = function pushNull() {
          this._push(this.createNull());
        };

        _proto89.pushUndefined = function pushUndefined() {
          this._push(this.createUndefined());
        };

        _proto89.pushInfinity = function pushInfinity() {
          this._push(this.createInfinity());
        };

        _proto89.pushInfinityNeg = function pushInfinityNeg() {
          this._push(this.createInfinityNeg());
        };

        _proto89.pushNaN = function pushNaN() {
          this._push(this.createNaN());
        };

        _proto89.pushNaNNeg = function pushNaNNeg() {
          this._push(this.createNaNNeg());
        };

        _proto89.pushArrayStart = function pushArrayStart() {
          this._createParent([], c.PARENT.ARRAY, -1);
        };

        _proto89.pushArrayStartFixed = function pushArrayStartFixed(len) {
          this._createArrayStartFixed(len);
        };

        _proto89.pushArrayStartFixed32 = function pushArrayStartFixed32(len1, len2) {
          var len = utils.buildInt32(len1, len2);

          this._createArrayStartFixed(len);
        };

        _proto89.pushArrayStartFixed64 = function pushArrayStartFixed64(len1, len2, len3, len4) {
          var len = utils.buildInt64(len1, len2, len3, len4);

          this._createArrayStartFixed(len);
        };

        _proto89.pushObjectStart = function pushObjectStart() {
          this._createObjectStartFixed(-1);
        };

        _proto89.pushObjectStartFixed = function pushObjectStartFixed(len) {
          this._createObjectStartFixed(len);
        };

        _proto89.pushObjectStartFixed32 = function pushObjectStartFixed32(len1, len2) {
          var len = utils.buildInt32(len1, len2);

          this._createObjectStartFixed(len);
        };

        _proto89.pushObjectStartFixed64 = function pushObjectStartFixed64(len1, len2, len3, len4) {
          var len = utils.buildInt64(len1, len2, len3, len4);

          this._createObjectStartFixed(len);
        };

        _proto89.pushByteStringStart = function pushByteStringStart() {
          this._parents[this._depth] = {
            type: c.PARENT.BYTE_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          };
        };

        _proto89.pushByteString = function pushByteString(start, end) {
          this._push(this.createByteStringFromHeap(start, end));
        };

        _proto89.pushUtf8StringStart = function pushUtf8StringStart() {
          this._parents[this._depth] = {
            type: c.PARENT.UTF8_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          };
        };

        _proto89.pushUtf8String = function pushUtf8String(start, end) {
          this._push(this.createUtf8StringFromHeap(start, end));
        };

        _proto89.pushSimpleUnassigned = function pushSimpleUnassigned(val) {
          this._push(this.createSimpleUnassigned(val));
        };

        _proto89.pushTagStart = function pushTagStart(tag) {
          this._parents[this._depth] = {
            type: c.PARENT.TAG,
            length: 1,
            ref: [tag]
          };
        };

        _proto89.pushTagStart4 = function pushTagStart4(f, g) {
          this.pushTagStart(utils.buildInt32(f, g));
        };

        _proto89.pushTagStart8 = function pushTagStart8(f1, f2, g1, g2) {
          this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
        };

        _proto89.pushTagUnassigned = function pushTagUnassigned(tagNumber) {
          this._push(this.createTag(tagNumber));
        };

        _proto89.pushBreak = function pushBreak() {
          if (this._currentParent.length > -1) {
            throw new Error("Unexpected break");
          }

          this._closeParent();
        };

        _proto89._createObjectStartFixed = function _createObjectStartFixed(len) {
          if (len === 0) {
            this._push(this.createObject({}));

            return;
          }

          this._createParent({}, c.PARENT.OBJECT, len);
        };

        _proto89._createArrayStartFixed = function _createArrayStartFixed(len) {
          if (len === 0) {
            this._push(this.createArray([]));

            return;
          }

          this._createParent(new Array(len), c.PARENT.ARRAY, len);
        };

        _proto89._decode = function _decode(input) {
          if (input.byteLength === 0) {
            throw new Error("Input too short");
          }

          this._reset();

          this._heap8.set(input);

          var code = this.parser.parse(input.byteLength);

          if (this._depth > 1) {
            while (this._currentParent.length === 0) {
              this._closeParent();
            }

            if (this._depth > 1) {
              throw new Error("Undeterminated nesting");
            }
          }

          if (code > 0) {
            throw new Error("Failed to parse");
          }

          if (this._res.length === 0) {
            throw new Error("No valid result");
          }
        } // -- Public Interface
        ;

        _proto89.decodeFirst = function decodeFirst(input) {
          this._decode(input);

          return this._res[0];
        };

        _proto89.decodeAll = function decodeAll(input) {
          this._decode(input);

          return this._res;
        }
        /**
         * Decode the first cbor object.
         *
         * @param {Buffer|string} input
         * @param {string} [enc='hex'] - Encoding used if a string is passed.
         * @returns {*}
         */
        ;

        _Decoder.decode = function decode(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Decoder({
            size: input.length
          });
          return dec.decodeFirst(input);
        }
        /**
         * Decode all cbor objects.
         *
         * @param {Buffer|string} input
         * @param {string} [enc='hex'] - Encoding used if a string is passed.
         * @returns {Array<*>}
         */
        ;

        _Decoder.decodeAll = function decodeAll(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Decoder({
            size: input.length
          });
          return dec.decodeAll(input);
        };

        _createClass(_Decoder, [{
          key: "_depth",
          get: function get() {
            return this._parents.length;
          }
        }, {
          key: "_currentParent",
          get: function get() {
            return this._parents[this._depth - 1];
          }
        }, {
          key: "_ref",
          get: function get() {
            return this._currentParent.ref;
          }
        }]);

        return _Decoder;
      }();

      Decoder.decodeFirst = Decoder.decode;
      module.exports = Decoder;
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/diagnose.js


  var require_diagnose2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/diagnose.js": function node_modulesDfinityIdentityNode_modulesBorcSrcDiagnoseJs(exports, module) {
      "use strict";

      var _require_buffer7 = require_buffer5(),
          Buffer2 = _require_buffer7.Buffer;

      var Decoder = require_decoder2();
      var utils = require_utils4();

      var Diagnose = /*#__PURE__*/function (_Decoder3) {
        _inheritsLoose(_Diagnose, _Decoder3);

        function _Diagnose() {
          return _Decoder3.apply(this, arguments) || this;
        }

        var _proto90 = _Diagnose.prototype;

        _proto90.createTag = function createTag(tagNumber, value) {
          return tagNumber + "(" + value + ")";
        };

        _proto90.createInt = function createInt(val) {
          return _Decoder3.prototype.createInt.call(this, val).toString();
        };

        _proto90.createInt32 = function createInt32(f, g) {
          return _Decoder3.prototype.createInt32.call(this, f, g).toString();
        };

        _proto90.createInt64 = function createInt64(f1, f2, g1, g2) {
          return _Decoder3.prototype.createInt64.call(this, f1, f2, g1, g2).toString();
        };

        _proto90.createInt32Neg = function createInt32Neg(f, g) {
          return _Decoder3.prototype.createInt32Neg.call(this, f, g).toString();
        };

        _proto90.createInt64Neg = function createInt64Neg(f1, f2, g1, g2) {
          return _Decoder3.prototype.createInt64Neg.call(this, f1, f2, g1, g2).toString();
        };

        _proto90.createTrue = function createTrue() {
          return "true";
        };

        _proto90.createFalse = function createFalse() {
          return "false";
        };

        _proto90.createFloat = function createFloat(val) {
          var fl = _Decoder3.prototype.createFloat.call(this, val);

          if (utils.isNegativeZero(val)) {
            return "-0_1";
          }

          return fl + "_1";
        };

        _proto90.createFloatSingle = function createFloatSingle(a, b, c, d) {
          var fl = _Decoder3.prototype.createFloatSingle.call(this, a, b, c, d);

          return fl + "_2";
        };

        _proto90.createFloatDouble = function createFloatDouble(a, b, c, d, e, f, g, h) {
          var fl = _Decoder3.prototype.createFloatDouble.call(this, a, b, c, d, e, f, g, h);

          return fl + "_3";
        };

        _proto90.createByteString = function createByteString(raw, len) {
          var val = raw.join(", ");

          if (len === -1) {
            return "(_ " + val + ")";
          }

          return "h'" + val;
        };

        _proto90.createByteStringFromHeap = function createByteStringFromHeap(start, end) {
          var val = Buffer2.from(_Decoder3.prototype.createByteStringFromHeap.call(this, start, end)).toString("hex");
          return "h'" + val + "'";
        };

        _proto90.createInfinity = function createInfinity() {
          return "Infinity_1";
        };

        _proto90.createInfinityNeg = function createInfinityNeg() {
          return "-Infinity_1";
        };

        _proto90.createNaN = function createNaN() {
          return "NaN_1";
        };

        _proto90.createNaNNeg = function createNaNNeg() {
          return "-NaN_1";
        };

        _proto90.createNull = function createNull() {
          return "null";
        };

        _proto90.createUndefined = function createUndefined() {
          return "undefined";
        };

        _proto90.createSimpleUnassigned = function createSimpleUnassigned(val) {
          return "simple(" + val + ")";
        };

        _proto90.createArray = function createArray(arr, len) {
          var val = _Decoder3.prototype.createArray.call(this, arr, len);

          if (len === -1) {
            return "[_ " + val.join(", ") + "]";
          }

          return "[" + val.join(", ") + "]";
        };

        _proto90.createMap = function createMap(map, len) {
          var val = _Decoder3.prototype.createMap.call(this, map);

          var list = Array.from(val.keys()).reduce(collectObject(val), "");

          if (len === -1) {
            return "{_ " + list + "}";
          }

          return "{" + list + "}";
        };

        _proto90.createObject = function createObject(obj, len) {
          var val = _Decoder3.prototype.createObject.call(this, obj);

          var map = Object.keys(val).reduce(collectObject(val), "");

          if (len === -1) {
            return "{_ " + map + "}";
          }

          return "{" + map + "}";
        };

        _proto90.createUtf8String = function createUtf8String(raw, len) {
          var val = raw.join(", ");

          if (len === -1) {
            return "(_ " + val + ")";
          }

          return "\"" + val + "\"";
        };

        _proto90.createUtf8StringFromHeap = function createUtf8StringFromHeap(start, end) {
          var val = Buffer2.from(_Decoder3.prototype.createUtf8StringFromHeap.call(this, start, end)).toString("utf8");
          return "\"" + val + "\"";
        };

        _Diagnose.diagnose = function diagnose(input, enc) {
          if (typeof input === "string") {
            input = Buffer2.from(input, enc || "hex");
          }

          var dec = new _Diagnose();
          return dec.decodeFirst(input);
        };

        return _Diagnose;
      }(Decoder);

      module.exports = Diagnose;

      function collectObject(val) {
        return function (acc, key) {
          if (acc) {
            return acc + ", " + key + ": " + val[key];
          }

          return key + ": " + val[key];
        };
      }
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/encoder.js


  var require_encoder2 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/encoder.js": function node_modulesDfinityIdentityNode_modulesBorcSrcEncoderJs(exports, module) {
      "use strict";

      var _require_buffer8 = require_buffer5(),
          Buffer2 = _require_buffer8.Buffer;

      var _require_iso_url4 = require_iso_url2(),
          URL2 = _require_iso_url4.URL;

      var Bignumber = require_bignumber().BigNumber;
      var utils = require_utils4();
      var constants = require_constants2();
      var MT = constants.MT;
      var NUMBYTES = constants.NUMBYTES;
      var SHIFT32 = constants.SHIFT32;
      var SYMS = constants.SYMS;
      var TAG = constants.TAG;
      var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
      var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
      var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
      var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
      var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
      var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
      var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
      var MAXINT_BN = new Bignumber("0x20000000000000");
      var BUF_NAN = Buffer2.from("f97e00", "hex");
      var BUF_INF_NEG = Buffer2.from("f9fc00", "hex");
      var BUF_INF_POS = Buffer2.from("f97c00", "hex");

      function toType(obj) {
        return {}.toString.call(obj).slice(8, -1);
      }

      var Encoder = /*#__PURE__*/function () {
        /**
         * @param {Object} [options={}]
         * @param {function(Buffer)} options.stream
         */
        function _Encoder(options) {
          options = options || {};
          this.streaming = typeof options.stream === "function";
          this.onData = options.stream;
          this.semanticTypes = [[URL2, this._pushUrl], [Bignumber, this._pushBigNumber]];
          var addTypes = options.genTypes || [];
          var len = addTypes.length;

          for (var i = 0; i < len; i++) {
            this.addSemanticType(addTypes[i][0], addTypes[i][1]);
          }

          this._reset();
        }

        var _proto91 = _Encoder.prototype;

        _proto91.addSemanticType = function addSemanticType(type, fun) {
          var len = this.semanticTypes.length;

          for (var i = 0; i < len; i++) {
            var typ = this.semanticTypes[i][0];

            if (typ === type) {
              var old = this.semanticTypes[i][1];
              this.semanticTypes[i][1] = fun;
              return old;
            }
          }

          this.semanticTypes.push([type, fun]);
          return null;
        };

        _proto91.push = function push(val) {
          if (!val) {
            return true;
          }

          this.result[this.offset] = val;
          this.resultMethod[this.offset] = 0;
          this.resultLength[this.offset] = val.length;
          this.offset++;

          if (this.streaming) {
            this.onData(this.finalize());
          }

          return true;
        };

        _proto91.pushWrite = function pushWrite(val, method, len) {
          this.result[this.offset] = val;
          this.resultMethod[this.offset] = method;
          this.resultLength[this.offset] = len;
          this.offset++;

          if (this.streaming) {
            this.onData(this.finalize());
          }

          return true;
        };

        _proto91._pushUInt8 = function _pushUInt8(val) {
          return this.pushWrite(val, 1, 1);
        };

        _proto91._pushUInt16BE = function _pushUInt16BE(val) {
          return this.pushWrite(val, 2, 2);
        };

        _proto91._pushUInt32BE = function _pushUInt32BE(val) {
          return this.pushWrite(val, 3, 4);
        };

        _proto91._pushDoubleBE = function _pushDoubleBE(val) {
          return this.pushWrite(val, 4, 8);
        };

        _proto91._pushNaN = function _pushNaN() {
          return this.push(BUF_NAN);
        };

        _proto91._pushInfinity = function _pushInfinity(obj) {
          var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
          return this.push(half);
        };

        _proto91._pushFloat = function _pushFloat(obj) {
          var b2 = Buffer2.allocUnsafe(2);

          if (utils.writeHalf(b2, obj)) {
            if (utils.parseHalf(b2) === obj) {
              return this._pushUInt8(HALF) && this.push(b2);
            }
          }

          var b4 = Buffer2.allocUnsafe(4);
          b4.writeFloatBE(obj, 0);

          if (b4.readFloatBE(0) === obj) {
            return this._pushUInt8(FLOAT) && this.push(b4);
          }

          return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
        };

        _proto91._pushInt = function _pushInt(obj, mt, orig) {
          var m = mt << 5;

          if (obj < 24) {
            return this._pushUInt8(m | obj);
          }

          if (obj <= 255) {
            return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
          }

          if (obj <= 65535) {
            return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
          }

          if (obj <= 4294967295) {
            return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
          }

          if (obj <= Number.MAX_SAFE_INTEGER) {
            return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
          }

          if (mt === MT.NEG_INT) {
            return this._pushFloat(orig);
          }

          return this._pushFloat(obj);
        };

        _proto91._pushIntNum = function _pushIntNum(obj) {
          if (obj < 0) {
            return this._pushInt(-obj - 1, MT.NEG_INT, obj);
          } else {
            return this._pushInt(obj, MT.POS_INT);
          }
        };

        _proto91._pushNumber = function _pushNumber(obj) {
          switch (false) {
            case obj === obj:
              return this._pushNaN(obj);

            case isFinite(obj):
              return this._pushInfinity(obj);

            case obj % 1 !== 0:
              return this._pushIntNum(obj);

            default:
              return this._pushFloat(obj);
          }
        };

        _proto91._pushString = function _pushString(obj) {
          var len = Buffer2.byteLength(obj, "utf8");
          return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
        };

        _proto91._pushBoolean = function _pushBoolean(obj) {
          return this._pushUInt8(obj ? TRUE : FALSE);
        };

        _proto91._pushUndefined = function _pushUndefined(obj) {
          return this._pushUInt8(UNDEFINED);
        };

        _proto91._pushArray = function _pushArray(gen, obj) {
          var len = obj.length;

          if (!gen._pushInt(len, MT.ARRAY)) {
            return false;
          }

          for (var j = 0; j < len; j++) {
            if (!gen.pushAny(obj[j])) {
              return false;
            }
          }

          return true;
        };

        _proto91._pushTag = function _pushTag(tag) {
          return this._pushInt(tag, MT.TAG);
        };

        _proto91._pushDate = function _pushDate(gen, obj) {
          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
        };

        _proto91._pushBuffer = function _pushBuffer(gen, obj) {
          return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
        };

        _proto91._pushNoFilter = function _pushNoFilter(gen, obj) {
          return gen._pushBuffer(gen, obj.slice());
        };

        _proto91._pushRegexp = function _pushRegexp(gen, obj) {
          return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
        };

        _proto91._pushSet = function _pushSet(gen, obj) {
          if (!gen._pushInt(obj.size, MT.ARRAY)) {
            return false;
          }

          for (var _iterator37 = _createForOfIteratorHelperLoose(obj), _step37; !(_step37 = _iterator37()).done;) {
            var x = _step37.value;

            if (!gen.pushAny(x)) {
              return false;
            }
          }

          return true;
        };

        _proto91._pushUrl = function _pushUrl(gen, obj) {
          return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
        };

        _proto91._pushBigint = function _pushBigint(obj) {
          var tag = TAG.POS_BIGINT;

          if (obj.isNegative()) {
            obj = obj.negated().minus(1);
            tag = TAG.NEG_BIGINT;
          }

          var str = obj.toString(16);

          if (str.length % 2) {
            str = "0" + str;
          }

          var buf = Buffer2.from(str, "hex");
          return this._pushTag(tag) && this._pushBuffer(this, buf);
        };

        _proto91._pushBigNumber = function _pushBigNumber(gen, obj) {
          if (obj.isNaN()) {
            return gen._pushNaN();
          }

          if (!obj.isFinite()) {
            return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
          }

          if (obj.isInteger()) {
            return gen._pushBigint(obj);
          }

          if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
            return false;
          }

          var dec = obj.decimalPlaces();
          var slide = obj.multipliedBy(new Bignumber(10).pow(dec));

          if (!gen._pushIntNum(-dec)) {
            return false;
          }

          if (slide.abs().isLessThan(MAXINT_BN)) {
            return gen._pushIntNum(slide.toNumber());
          } else {
            return gen._pushBigint(slide);
          }
        };

        _proto91._pushMap = function _pushMap(gen, obj) {
          if (!gen._pushInt(obj.size, MT.MAP)) {
            return false;
          }

          return this._pushRawMap(obj.size, Array.from(obj));
        };

        _proto91._pushObject = function _pushObject(obj) {
          if (!obj) {
            return this._pushUInt8(NULL);
          }

          var len = this.semanticTypes.length;

          for (var i = 0; i < len; i++) {
            if (obj instanceof this.semanticTypes[i][0]) {
              return this.semanticTypes[i][1].call(obj, this, obj);
            }
          }

          var f = obj.encodeCBOR;

          if (typeof f === "function") {
            return f.call(obj, this);
          }

          var keys = Object.keys(obj);
          var keyLength = keys.length;

          if (!this._pushInt(keyLength, MT.MAP)) {
            return false;
          }

          return this._pushRawMap(keyLength, keys.map(function (k) {
            return [k, obj[k]];
          }));
        };

        _proto91._pushRawMap = function _pushRawMap(len, map) {
          map = map.map(function (a) {
            a[0] = _Encoder.encode(a[0]);
            return a;
          }).sort(utils.keySorter);

          for (var j = 0; j < len; j++) {
            if (!this.push(map[j][0])) {
              return false;
            }

            if (!this.pushAny(map[j][1])) {
              return false;
            }
          }

          return true;
        }
        /**
         * Alias for `.pushAny`
         *
         * @param {*} obj
         * @returns {boolean} true on success
         */
        ;

        _proto91.write = function write(obj) {
          return this.pushAny(obj);
        }
        /**
         * Push any supported type onto the encoded stream
         *
         * @param {any} obj
         * @returns {boolean} true on success
         */
        ;

        _proto91.pushAny = function pushAny(obj) {
          var typ = toType(obj);

          switch (typ) {
            case "Number":
              return this._pushNumber(obj);

            case "String":
              return this._pushString(obj);

            case "Boolean":
              return this._pushBoolean(obj);

            case "Object":
              return this._pushObject(obj);

            case "Array":
              return this._pushArray(this, obj);

            case "Uint8Array":
              return this._pushBuffer(this, Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj));

            case "Null":
              return this._pushUInt8(NULL);

            case "Undefined":
              return this._pushUndefined(obj);

            case "Map":
              return this._pushMap(this, obj);

            case "Set":
              return this._pushSet(this, obj);

            case "URL":
              return this._pushUrl(this, obj);

            case "BigNumber":
              return this._pushBigNumber(this, obj);

            case "Date":
              return this._pushDate(this, obj);

            case "RegExp":
              return this._pushRegexp(this, obj);

            case "Symbol":
              switch (obj) {
                case SYMS.NULL:
                  return this._pushObject(null);

                case SYMS.UNDEFINED:
                  return this._pushUndefined(void 0);

                default:
                  throw new Error("Unknown symbol: " + obj.toString());
              }

            default:
              throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
          }
        };

        _proto91.finalize = function finalize() {
          if (this.offset === 0) {
            return null;
          }

          var result = this.result;
          var resultLength = this.resultLength;
          var resultMethod = this.resultMethod;
          var offset = this.offset;
          var size = 0;
          var i = 0;

          for (; i < offset; i++) {
            size += resultLength[i];
          }

          var res = Buffer2.allocUnsafe(size);
          var index = 0;
          var length = 0;

          for (i = 0; i < offset; i++) {
            length = resultLength[i];

            switch (resultMethod[i]) {
              case 0:
                result[i].copy(res, index);
                break;

              case 1:
                res.writeUInt8(result[i], index, true);
                break;

              case 2:
                res.writeUInt16BE(result[i], index, true);
                break;

              case 3:
                res.writeUInt32BE(result[i], index, true);
                break;

              case 4:
                res.writeDoubleBE(result[i], index, true);
                break;

              case 5:
                res.write(result[i], index, length, "utf8");
                break;

              default:
                throw new Error("unkown method");
            }

            index += length;
          }

          var tmp = res;

          this._reset();

          return tmp;
        };

        _proto91._reset = function _reset() {
          this.result = [];
          this.resultMethod = [];
          this.resultLength = [];
          this.offset = 0;
        }
        /**
         * Encode the given value
         * @param {*} o
         * @returns {Buffer}
         */
        ;

        _Encoder.encode = function encode(o) {
          var enc = new _Encoder();
          var ret = enc.pushAny(o);

          if (!ret) {
            throw new Error("Failed to encode input");
          }

          return enc.finalize();
        };

        return _Encoder;
      }();

      module.exports = Encoder;
    }
  }); // node_modules/@dfinity/identity/node_modules/borc/src/index.js


  var require_src3 = __commonJS({
    "node_modules/@dfinity/identity/node_modules/borc/src/index.js": function node_modulesDfinityIdentityNode_modulesBorcSrcIndexJs(exports) {
      "use strict";

      exports.Diagnose = require_diagnose2();
      exports.Decoder = require_decoder2();
      exports.Encoder = require_encoder2();
      exports.Simple = require_simple2();
      exports.Tagged = require_tagged2();
      exports.decodeAll = exports.Decoder.decodeAll;
      exports.decodeFirst = exports.Decoder.decodeFirst;
      exports.diagnose = exports.Diagnose.diagnose;
      exports.encode = exports.Encoder.encode;
      exports.decode = exports.Decoder.decode;
      exports.leveldb = {
        decode: exports.Decoder.decodeAll,
        encode: exports.Encoder.encode,
        buffer: true,
        name: "cbor"
      };
    }
  }); // node_modules/@dfinity/identity/lib/cjs/identity/webauthn.js


  var require_webauthn = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/identity/webauthn.js": function node_modulesDfinityIdentityLibCjsIdentityWebauthnJs(exports) {
      "use strict";

      var __importDefault = exports && exports.__importDefault || function (mod) {
        return mod && mod.__esModule ? mod : {
          "default": mod
        };
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WebAuthnIdentity = exports.CosePublicKey = void 0;
      var agent_1 = require_cjs3();

      var borc_1 = __importDefault(require_src3());

      var utils_1 = require_utils();
      var candid_1 = require_cjs2();

      function _coseToDerEncodedBlob(cose) {
        return (0, agent_1.wrapDER)(cose, agent_1.DER_COSE_OID).buffer;
      }

      function _authDataToCose(authData) {
        var dataView = new DataView(new ArrayBuffer(2));
        var idLenBytes = authData.slice(53, 55);
        [].concat(new Uint8Array(idLenBytes)).forEach(function (v, i) {
          return dataView.setUint8(i, v);
        });
        var credentialIdLength = dataView.getUint16(0);
        return authData.slice(55 + credentialIdLength);
      }

      var CosePublicKey = /*#__PURE__*/function () {
        function CosePublicKey(_cose) {
          this._cose = _cose;
          this._encodedKey = _coseToDerEncodedBlob(_cose);
        }

        var _proto92 = CosePublicKey.prototype;

        _proto92.toDer = function toDer() {
          return this._encodedKey;
        };

        _proto92.getCose = function getCose() {
          return this._cose;
        };

        return CosePublicKey;
      }();

      exports.CosePublicKey = CosePublicKey;

      function _createChallengeBuffer(challenge) {
        if (challenge === void 0) {
          challenge = "<ic0.app>";
        }

        if (typeof challenge === "string") {
          return Uint8Array.from(challenge, function (c) {
            return c.charCodeAt(0);
          });
        } else {
          return challenge;
        }
      }

      function _createCredential(_x78) {
        return _createCredential2.apply(this, arguments);
      }

      function _createCredential2() {
        _createCredential2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(credentialCreationOptions) {
          var creds;
          return _regeneratorRuntime().wrap(function _callee54$(_context57) {
            while (1) {
              switch (_context57.prev = _context57.next) {
                case 0:
                  _context57.next = 2;
                  return navigator.credentials.create(credentialCreationOptions !== null && credentialCreationOptions !== void 0 ? credentialCreationOptions : {
                    publicKey: {
                      authenticatorSelection: {
                        userVerification: "preferred"
                      },
                      attestation: "direct",
                      challenge: _createChallengeBuffer(),
                      pubKeyCredParams: [{
                        type: "public-key",
                        alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256
                      }],
                      rp: {
                        name: "Internet Identity Service"
                      },
                      user: {
                        id: (0, utils_1.randomBytes)(16),
                        name: "Internet Identity",
                        displayName: "Internet Identity"
                      }
                    }
                  });

                case 2:
                  creds = _context57.sent;

                  if (!(creds === null)) {
                    _context57.next = 5;
                    break;
                  }

                  return _context57.abrupt("return", null);

                case 5:
                  return _context57.abrupt("return", {
                    // do _not_ use ...creds here, as creds is not enumerable in all cases
                    id: creds.id,
                    response: creds.response,
                    type: creds.type,
                    authenticatorAttachment: creds.authenticatorAttachment,
                    getClientExtensionResults: creds.getClientExtensionResults,
                    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.
                    rawId: (0, candid_1.bufFromBufLike)(creds.rawId)
                  });

                case 6:
                case "end":
                  return _context57.stop();
              }
            }
          }, _callee54);
        }));
        return _createCredential2.apply(this, arguments);
      }

      var PubKeyCoseAlgo;

      (function (PubKeyCoseAlgo2) {
        PubKeyCoseAlgo2[PubKeyCoseAlgo2["ECDSA_WITH_SHA256"] = -7] = "ECDSA_WITH_SHA256";
      })(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));

      var WebAuthnIdentity = /*#__PURE__*/function (_agent_1$SignIdentity3) {
        _inheritsLoose(WebAuthnIdentity, _agent_1$SignIdentity3);

        function WebAuthnIdentity(rawId, cose, authenticatorAttachment) {
          var _this68;

          _this68 = _agent_1$SignIdentity3.call(this) || this;
          _this68.rawId = rawId;
          _this68.authenticatorAttachment = authenticatorAttachment;
          _this68._publicKey = new CosePublicKey(cose);
          return _this68;
        }
        /**
         * Create an identity from a JSON serialization.
         * @param json - json to parse
         */


        WebAuthnIdentity.fromJSON = function fromJSON(json) {
          var _JSON$parse = JSON.parse(json),
              publicKey = _JSON$parse.publicKey,
              rawId = _JSON$parse.rawId;

          if (typeof publicKey !== "string" || typeof rawId !== "string") {
            throw new Error("Invalid JSON string.");
          }

          return new this((0, agent_1.fromHex)(rawId), (0, agent_1.fromHex)(publicKey), void 0);
        }
        /**
         * Create an identity.
         * @param credentialCreationOptions an optional CredentialCreationOptions Challenge
         */
        ;

        WebAuthnIdentity.create =
        /*#__PURE__*/
        function () {
          var _create4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(credentialCreationOptions) {
            var _a, creds, response, attObject;

            return _regeneratorRuntime().wrap(function _callee52$(_context55) {
              while (1) {
                switch (_context55.prev = _context55.next) {
                  case 0:
                    _context55.next = 2;
                    return _createCredential(credentialCreationOptions);

                  case 2:
                    creds = _context55.sent;

                    if (!(!creds || creds.type !== "public-key")) {
                      _context55.next = 5;
                      break;
                    }

                    throw new Error("Could not create credentials.");

                  case 5:
                    response = creds.response;

                    if (!(response.attestationObject === void 0)) {
                      _context55.next = 8;
                      break;
                    }

                    throw new Error("Was expecting an attestation response.");

                  case 8:
                    attObject = borc_1["default"].decodeFirst(new Uint8Array(response.attestationObject));
                    return _context55.abrupt("return", new this(creds.rawId, _authDataToCose(attObject.authData), (_a = creds.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0));

                  case 10:
                  case "end":
                    return _context55.stop();
                }
              }
            }, _callee52, this);
          }));

          function create(_x79) {
            return _create4.apply(this, arguments);
          }

          return create;
        }();

        var _proto93 = WebAuthnIdentity.prototype;

        _proto93.getPublicKey = function getPublicKey() {
          return this._publicKey;
        }
        /**
         * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,
         * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.
         * This attribute is already implemented for Chrome, Safari and Edge.
         *
         * Given the attribute is only available after a successful interaction, the information is
         * provided opportunistically and might also be `undefined`.
         */
        ;

        _proto93.getAuthenticatorAttachment = function getAuthenticatorAttachment() {
          return this.authenticatorAttachment;
        };

        _proto93.sign = /*#__PURE__*/function () {
          var _sign3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(blob) {
            var result, response, cbor;
            return _regeneratorRuntime().wrap(function _callee53$(_context56) {
              while (1) {
                switch (_context56.prev = _context56.next) {
                  case 0:
                    _context56.next = 2;
                    return navigator.credentials.get({
                      publicKey: {
                        allowCredentials: [{
                          type: "public-key",
                          id: this.rawId
                        }],
                        challenge: blob,
                        userVerification: "preferred"
                      }
                    });

                  case 2:
                    result = _context56.sent;

                    if (result.authenticatorAttachment !== null) {
                      this.authenticatorAttachment = result.authenticatorAttachment;
                    }

                    response = result.response;
                    cbor = borc_1["default"].encode(new borc_1["default"].Tagged(55799, {
                      authenticator_data: new Uint8Array(response.authenticatorData),
                      client_data_json: new TextDecoder().decode(response.clientDataJSON),
                      signature: new Uint8Array(response.signature)
                    }));

                    if (cbor) {
                      _context56.next = 8;
                      break;
                    }

                    throw new Error("failed to encode cbor");

                  case 8:
                    return _context56.abrupt("return", cbor.buffer);

                  case 9:
                  case "end":
                    return _context56.stop();
                }
              }
            }, _callee53, this);
          }));

          function sign(_x80) {
            return _sign3.apply(this, arguments);
          }

          return sign;
        }()
        /**
         * Allow for JSON serialization of all information needed to reuse this identity.
         */
        ;

        _proto93.toJSON = function toJSON() {
          return {
            publicKey: (0, agent_1.toHex)(this._publicKey.getCose()),
            rawId: (0, agent_1.toHex)(this.rawId)
          };
        };

        return WebAuthnIdentity;
      }(agent_1.SignIdentity);

      exports.WebAuthnIdentity = WebAuthnIdentity;
    }
  }); // node_modules/@dfinity/identity/lib/cjs/index.js


  var require_cjs4 = __commonJS({
    "node_modules/@dfinity/identity/lib/cjs/index.js": function node_modulesDfinityIdentityLibCjsIndexJs(exports) {
      "use strict";

      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Secp256k1KeyIdentity = exports.ED25519_OID = exports.DER_COSE_OID = exports.unwrapDER = exports.wrapDER = exports.WebAuthnIdentity = exports.Ed25519PublicKey = exports.Ed25519KeyIdentity = void 0;
      var ed25519_1 = require_ed255192();
      Object.defineProperty(exports, "Ed25519KeyIdentity", {
        enumerable: true,
        get: function get() {
          return ed25519_1.Ed25519KeyIdentity;
        }
      });
      Object.defineProperty(exports, "Ed25519PublicKey", {
        enumerable: true,
        get: function get() {
          return ed25519_1.Ed25519PublicKey;
        }
      });

      __exportStar(require_ecdsa(), exports);

      __exportStar(require_delegation(), exports);

      __exportStar(require_partial(), exports);

      var webauthn_1 = require_webauthn();
      Object.defineProperty(exports, "WebAuthnIdentity", {
        enumerable: true,
        get: function get() {
          return webauthn_1.WebAuthnIdentity;
        }
      });
      var agent_1 = require_cjs3();
      Object.defineProperty(exports, "wrapDER", {
        enumerable: true,
        get: function get() {
          return agent_1.wrapDER;
        }
      });
      Object.defineProperty(exports, "unwrapDER", {
        enumerable: true,
        get: function get() {
          return agent_1.unwrapDER;
        }
      });
      Object.defineProperty(exports, "DER_COSE_OID", {
        enumerable: true,
        get: function get() {
          return agent_1.DER_COSE_OID;
        }
      });
      Object.defineProperty(exports, "ED25519_OID", {
        enumerable: true,
        get: function get() {
          return agent_1.ED25519_OID;
        }
      });

      var Secp256k1KeyIdentity = function Secp256k1KeyIdentity() {
        throw new Error("Secp256k1KeyIdentity has been moved to a new repo: @dfinity/identity-secp256k1");
      };

      exports.Secp256k1KeyIdentity = Secp256k1KeyIdentity;
    }
  }); // node_modules/@dfinity/auth-client/lib/cjs/idleManager.js


  var require_idleManager = __commonJS({
    "node_modules/@dfinity/auth-client/lib/cjs/idleManager.js": function node_modulesDfinityAuthClientLibCjsIdleManagerJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IdleManager = void 0;
      var events = ["mousedown", "mousemove", "keydown", "touchstart", "wheel"];

      var IdleManager = /*#__PURE__*/function () {
        /**
         * @protected
         * @param options {@link IdleManagerOptions}
         */
        function IdleManager(options) {
          var _this69 = this;

          if (options === void 0) {
            options = {};
          }

          var _a;

          this.callbacks = [];
          this.idleTimeout = 10 * 60 * 1e3;
          this.timeoutID = void 0;

          var _ref122 = options || {},
              onIdle = _ref122.onIdle,
              _ref122$idleTimeout = _ref122.idleTimeout,
              idleTimeout = _ref122$idleTimeout === void 0 ? 10 * 60 * 1e3 : _ref122$idleTimeout;

          this.callbacks = onIdle ? [onIdle] : [];
          this.idleTimeout = idleTimeout;

          var _resetTimer = this._resetTimer.bind(this);

          window.addEventListener("load", _resetTimer, true);
          events.forEach(function (name) {
            document.addEventListener(name, _resetTimer, true);
          });

          var debounce = function debounce(func, wait) {
            var timeout;
            return function () {
              for (var _len20 = arguments.length, args = new Array(_len20), _key23 = 0; _key23 < _len20; _key23++) {
                args[_key23] = arguments[_key23];
              }

              var context = _this69;

              var later = function later() {
                timeout = void 0;
                func.apply(context, args);
              };

              clearTimeout(timeout);
              timeout = window.setTimeout(later, wait);
            };
          };

          if (options === null || options === void 0 ? void 0 : options.captureScroll) {
            var scroll = debounce(_resetTimer, (_a = options === null || options === void 0 ? void 0 : options.scrollDebounce) !== null && _a !== void 0 ? _a : 100);
            window.addEventListener("scroll", scroll, true);
          }

          _resetTimer();
        }
        /**
         * Creates an {@link IdleManager}
         * @param {IdleManagerOptions} options Optional configuration
         * @see {@link IdleManagerOptions}
         * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user
         * @param options.idleTimeout timeout in ms
         * @param options.captureScroll capture scroll events
         * @param options.scrollDebounce scroll debounce time in ms
         */


        IdleManager.create = function create(options) {
          if (options === void 0) {
            options = {};
          }

          return new this(options);
        }
        /**
         * @param {IdleCB} callback function to be called when user goes idle
         */
        ;

        var _proto94 = IdleManager.prototype;

        _proto94.registerCallback = function registerCallback(callback) {
          this.callbacks.push(callback);
        }
        /**
         * Cleans up the idle manager and its listeners
         */
        ;

        _proto94.exit = function exit() {
          clearTimeout(this.timeoutID);
          window.removeEventListener("load", this._resetTimer, true);

          var _resetTimer = this._resetTimer.bind(this);

          events.forEach(function (name) {
            document.removeEventListener(name, _resetTimer, true);
          });
          this.callbacks.forEach(function (cb) {
            return cb();
          });
        }
        /**
         * Resets the timeouts during cleanup
         */
        ;

        _proto94._resetTimer = function _resetTimer() {
          var exit = this.exit.bind(this);
          window.clearTimeout(this.timeoutID);
          this.timeoutID = window.setTimeout(exit, this.idleTimeout);
        };

        return IdleManager;
      }();

      exports.IdleManager = IdleManager;
    }
  }); // node_modules/idb/build/wrap-idb-value.js


  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
  }

  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype["continue"], IDBCursor.prototype.continuePrimaryKey]);
  }

  function promisifyRequest(request) {
    var promise = new Promise(function (resolve, reject) {
      var unlisten = function unlisten() {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };

      var success = function success() {
        resolve(_wrap(request.result));
        unlisten();
      };

      var error = function error() {
        reject(request.error);
        unlisten();
      };

      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    promise.then(function (value) {
      if (value instanceof IDBCursor) {
        cursorRequestMap.set(value, request);
      }
    })["catch"](function () {});
    reverseTransformCache.set(promise, request);
    return promise;
  }

  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx)) return;
    var done = new Promise(function (resolve, reject) {
      var unlisten = function unlisten() {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };

      var complete = function complete() {
        resolve();
        unlisten();
      };

      var error = function error() {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };

      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }

  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }

  function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
      return function (storeNames) {
        for (var _len21 = arguments.length, args = new Array(_len21 > 1 ? _len21 - 1 : 0), _key24 = 1; _key24 < _len21; _key24++) {
          args[_key24 - 1] = arguments[_key24];
        }

        var tx = func.call.apply(func, [_unwrap(this), storeNames].concat(args));
        transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
        return _wrap(tx);
      };
    }

    if (getCursorAdvanceMethods().includes(func)) {
      return function () {
        for (var _len22 = arguments.length, args = new Array(_len22), _key25 = 0; _key25 < _len22; _key25++) {
          args[_key25] = arguments[_key25];
        }

        func.apply(_unwrap(this), args);
        return _wrap(cursorRequestMap.get(this));
      };
    }

    return function () {
      for (var _len23 = arguments.length, args = new Array(_len23), _key26 = 0; _key26 < _len23; _key26++) {
        args[_key26] = arguments[_key26];
      }

      return _wrap(func.apply(_unwrap(this), args));
    };
  }

  function transformCachableValue(value) {
    if (typeof value === "function") return wrapFunction(value);
    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
    return value;
  }

  function _wrap(value) {
    if (value instanceof IDBRequest) return promisifyRequest(value);
    if (transformCache.has(value)) return transformCache.get(value);
    var newValue = transformCachableValue(value);

    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }

    return newValue;
  }

  var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, cursorRequestMap, transactionDoneMap, transactionStoreNamesMap, transformCache, reverseTransformCache, idbProxyTraps, _unwrap;

  var init_wrap_idb_value = __esm({
    "node_modules/idb/build/wrap-idb-value.js": function node_modulesIdbBuildWrapIdbValueJs() {
      instanceOfAny = function instanceOfAny(object, constructors) {
        return constructors.some(function (c) {
          return object instanceof c;
        });
      };

      cursorRequestMap = /* @__PURE__ */new WeakMap();
      transactionDoneMap = /* @__PURE__ */new WeakMap();
      transactionStoreNamesMap = /* @__PURE__ */new WeakMap();
      transformCache = /* @__PURE__ */new WeakMap();
      reverseTransformCache = /* @__PURE__ */new WeakMap();
      idbProxyTraps = {
        get: function get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done") return transactionDoneMap.get(target);

            if (prop === "objectStoreNames") {
              return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }

            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }

          return _wrap(target[prop]);
        },
        set: function set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has: function has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }

          return prop in target;
        }
      };

      _unwrap = function unwrap(value) {
        return reverseTransformCache.get(value);
      };
    }
  }); // node_modules/idb/build/index.js


  var build_exports = {};

  __export(build_exports, {
    deleteDB: function deleteDB() {
      return _deleteDB;
    },
    openDB: function openDB() {
      return _openDB;
    },
    unwrap: function unwrap() {
      return _unwrap;
    },
    wrap: function wrap() {
      return _wrap;
    }
  });

  function _openDB(name, version, _temp) {
    var _ref123 = _temp === void 0 ? {} : _temp,
        blocked = _ref123.blocked,
        upgrade = _ref123.upgrade,
        blocking = _ref123.blocking,
        terminated = _ref123.terminated;

    var request = indexedDB.open(name, version);

    var openPromise = _wrap(request);

    if (upgrade) {
      request.addEventListener("upgradeneeded", function (event) {
        upgrade(_wrap(request.result), event.oldVersion, event.newVersion, _wrap(request.transaction), event);
      });
    }

    if (blocked) {
      request.addEventListener("blocked", function (event) {
        return blocked( // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event.newVersion, event);
      });
    }

    openPromise.then(function (db) {
      if (terminated) db.addEventListener("close", function () {
        return terminated();
      });

      if (blocking) {
        db.addEventListener("versionchange", function (event) {
          return blocking(event.oldVersion, event.newVersion, event);
        });
      }
    })["catch"](function () {});
    return openPromise;
  }

  function _deleteDB(name, _temp2) {
    var _ref124 = _temp2 === void 0 ? {} : _temp2,
        blocked = _ref124.blocked;

    var request = indexedDB.deleteDatabase(name);

    if (blocked) {
      request.addEventListener("blocked", function (event) {
        return blocked( // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event);
      });
    }

    return _wrap(request).then(function () {
      return void 0;
    });
  }

  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }

    if (cachedMethods.get(prop)) return cachedMethods.get(prop);
    var targetFuncName = prop.replace(/FromIndex$/, "");
    var useIndex = prop !== targetFuncName;
    var isWrite = writeMethods.includes(targetFuncName);

    if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
      return;
    }

    var method = /*#__PURE__*/function () {
      var _ref125 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(storeName) {
        var _target;

        var tx,
            target2,
            _len24,
            args,
            _key27,
            _args59 = arguments;

        return _regeneratorRuntime().wrap(function _callee55$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
                target2 = tx.store;

                for (_len24 = _args59.length, args = new Array(_len24 > 1 ? _len24 - 1 : 0), _key27 = 1; _key27 < _len24; _key27++) {
                  args[_key27 - 1] = _args59[_key27];
                }

                if (useIndex) target2 = target2.index(args.shift());
                _context58.next = 6;
                return Promise.all([(_target = target2)[targetFuncName].apply(_target, args), isWrite && tx.done]);

              case 6:
                return _context58.abrupt("return", _context58.sent[0]);

              case 7:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee55, this);
      }));

      return function method(_x81) {
        return _ref125.apply(this, arguments);
      };
    }();

    cachedMethods.set(prop, method);
    return method;
  }

  var readMethods, writeMethods, cachedMethods;

  var init_build = __esm({
    "node_modules/idb/build/index.js": function node_modulesIdbBuildIndexJs() {
      init_wrap_idb_value();
      init_wrap_idb_value();
      readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      writeMethods = ["put", "add", "delete", "clear"];
      cachedMethods = /* @__PURE__ */new Map();
      replaceTraps(function (oldTraps) {
        return _extends({}, oldTraps, {
          get: function get(target, prop, receiver) {
            return getMethod(target, prop) || oldTraps.get(target, prop, receiver);
          },
          has: function has(target, prop) {
            return !!getMethod(target, prop) || oldTraps.has(target, prop);
          }
        });
      });
    }
  }); // node_modules/@dfinity/auth-client/lib/cjs/db.js


  var require_db = __commonJS({
    "node_modules/@dfinity/auth-client/lib/cjs/db.js": function node_modulesDfinityAuthClientLibCjsDbJs(exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IdbKeyVal = void 0;
      var idb_1 = (init_build(), __toCommonJS(build_exports));
      var storage_1 = require_storage();
      var AUTH_DB_NAME = "auth-client-db";
      var OBJECT_STORE_NAME = "ic-keyval";

      var _openDbStore = /*#__PURE__*/function () {
        var _ref126 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(dbName, storeName, version) {
          return _regeneratorRuntime().wrap(function _callee56$(_context59) {
            while (1) {
              switch (_context59.prev = _context59.next) {
                case 0:
                  if (dbName === void 0) {
                    dbName = AUTH_DB_NAME;
                  }

                  if (storeName === void 0) {
                    storeName = OBJECT_STORE_NAME;
                  }

                  if (storage_1.isBrowser && (localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem(storage_1.KEY_STORAGE_DELEGATION))) {
                    localStorage.removeItem(storage_1.KEY_STORAGE_DELEGATION);
                    localStorage.removeItem(storage_1.KEY_STORAGE_KEY);
                  }

                  _context59.next = 5;
                  return (0, idb_1.openDB)(dbName, version, {
                    upgrade: function upgrade(database) {
                      if (database.objectStoreNames.contains(storeName)) {
                        database.clear(storeName);
                      }

                      database.createObjectStore(storeName);
                    }
                  });

                case 5:
                  return _context59.abrupt("return", _context59.sent);

                case 6:
                case "end":
                  return _context59.stop();
              }
            }
          }, _callee56);
        }));

        return function _openDbStore(_x82, _x83, _x84) {
          return _ref126.apply(this, arguments);
        };
      }();

      function _getValue(_x85, _x86, _x87) {
        return _getValue2.apply(this, arguments);
      }

      function _getValue2() {
        _getValue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61(db, storeName, key) {
          return _regeneratorRuntime().wrap(function _callee61$(_context64) {
            while (1) {
              switch (_context64.prev = _context64.next) {
                case 0:
                  _context64.next = 2;
                  return db.get(storeName, key);

                case 2:
                  return _context64.abrupt("return", _context64.sent);

                case 3:
                case "end":
                  return _context64.stop();
              }
            }
          }, _callee61);
        }));
        return _getValue2.apply(this, arguments);
      }

      function _setValue(_x88, _x89, _x90, _x91) {
        return _setValue2.apply(this, arguments);
      }

      function _setValue2() {
        _setValue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62(db, storeName, key, value) {
          return _regeneratorRuntime().wrap(function _callee62$(_context65) {
            while (1) {
              switch (_context65.prev = _context65.next) {
                case 0:
                  _context65.next = 2;
                  return db.put(storeName, value, key);

                case 2:
                  return _context65.abrupt("return", _context65.sent);

                case 3:
                case "end":
                  return _context65.stop();
              }
            }
          }, _callee62);
        }));
        return _setValue2.apply(this, arguments);
      }

      function _removeValue(_x92, _x93, _x94) {
        return _removeValue2.apply(this, arguments);
      }

      function _removeValue2() {
        _removeValue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63(db, storeName, key) {
          return _regeneratorRuntime().wrap(function _callee63$(_context66) {
            while (1) {
              switch (_context66.prev = _context66.next) {
                case 0:
                  _context66.next = 2;
                  return db["delete"](storeName, key);

                case 2:
                  return _context66.abrupt("return", _context66.sent);

                case 3:
                case "end":
                  return _context66.stop();
              }
            }
          }, _callee63);
        }));
        return _removeValue2.apply(this, arguments);
      }

      var IdbKeyVal = /*#__PURE__*/function () {
        // Do not use - instead prefer create
        function _IdbKeyVal(_db, _storeName) {
          this._db = _db;
          this._storeName = _storeName;
        }
        /**
         * @param {DBCreateOptions} options - DBCreateOptions
         * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database
         * @default
         * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store
         * @default
         * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade
         * @constructs an {@link IdbKeyVal}
         */


        _IdbKeyVal.create =
        /*#__PURE__*/
        function () {
          var _create5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(options) {
            var _ref127, _ref127$dbName, dbName, _ref127$storeName, storeName, _ref127$version, version, db;

            return _regeneratorRuntime().wrap(function _callee57$(_context60) {
              while (1) {
                switch (_context60.prev = _context60.next) {
                  case 0:
                    _ref127 = options !== null && options !== void 0 ? options : {}, _ref127$dbName = _ref127.dbName, dbName = _ref127$dbName === void 0 ? AUTH_DB_NAME : _ref127$dbName, _ref127$storeName = _ref127.storeName, storeName = _ref127$storeName === void 0 ? OBJECT_STORE_NAME : _ref127$storeName, _ref127$version = _ref127.version, version = _ref127$version === void 0 ? storage_1.DB_VERSION : _ref127$version;
                    _context60.next = 3;
                    return _openDbStore(dbName, storeName, version);

                  case 3:
                    db = _context60.sent;
                    return _context60.abrupt("return", new _IdbKeyVal(db, storeName));

                  case 5:
                  case "end":
                    return _context60.stop();
                }
              }
            }, _callee57);
          }));

          function create(_x95) {
            return _create5.apply(this, arguments);
          }

          return create;
        }()
        /**
         * Basic setter
         * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
         * @param value value to set
         * @returns void
         */
        ;

        var _proto95 = _IdbKeyVal.prototype;

        _proto95.set =
        /*#__PURE__*/
        function () {
          var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58(key, value) {
            return _regeneratorRuntime().wrap(function _callee58$(_context61) {
              while (1) {
                switch (_context61.prev = _context61.next) {
                  case 0:
                    _context61.next = 2;
                    return _setValue(this._db, this._storeName, key, value);

                  case 2:
                    return _context61.abrupt("return", _context61.sent);

                  case 3:
                  case "end":
                    return _context61.stop();
                }
              }
            }, _callee58, this);
          }));

          function set(_x96, _x97) {
            return _set.apply(this, arguments);
          }

          return set;
        }()
        /**
         * Basic getter
         * Pass in a type T for type safety if you know the type the value will have if it is found
         * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
         * @returns `Promise<T | null>`
         * @example
         * await get<string>('exampleKey') -> 'exampleValue'
         */
        ;

        _proto95.get =
        /*#__PURE__*/
        function () {
          var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59(key) {
            var _a;

            return _regeneratorRuntime().wrap(function _callee59$(_context62) {
              while (1) {
                switch (_context62.prev = _context62.next) {
                  case 0:
                    _context62.next = 2;
                    return _getValue(this._db, this._storeName, key);

                  case 2:
                    _context62.t1 = _a = _context62.sent;
                    _context62.t0 = _context62.t1 !== null;

                    if (!_context62.t0) {
                      _context62.next = 6;
                      break;
                    }

                    _context62.t0 = _a !== void 0;

                  case 6:
                    if (!_context62.t0) {
                      _context62.next = 10;
                      break;
                    }

                    _context62.t2 = _a;
                    _context62.next = 11;
                    break;

                  case 10:
                    _context62.t2 = null;

                  case 11:
                    return _context62.abrupt("return", _context62.t2);

                  case 12:
                  case "end":
                    return _context62.stop();
                }
              }
            }, _callee59, this);
          }));

          function get(_x98) {
            return _get.apply(this, arguments);
          }

          return get;
        }()
        /**
         * Remove a key
         * @param key {@link IDBValidKey}
         * @returns void
         */
        ;

        _proto95.remove =
        /*#__PURE__*/
        function () {
          var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(key) {
            return _regeneratorRuntime().wrap(function _callee60$(_context63) {
              while (1) {
                switch (_context63.prev = _context63.next) {
                  case 0:
                    _context63.next = 2;
                    return _removeValue(this._db, this._storeName, key);

                  case 2:
                    return _context63.abrupt("return", _context63.sent);

                  case 3:
                  case "end":
                    return _context63.stop();
                }
              }
            }, _callee60, this);
          }));

          function remove(_x99) {
            return _remove.apply(this, arguments);
          }

          return remove;
        }();

        return _IdbKeyVal;
      }();

      exports.IdbKeyVal = IdbKeyVal;
    }
  }); // node_modules/@dfinity/auth-client/lib/cjs/storage.js


  var require_storage = __commonJS({
    "node_modules/@dfinity/auth-client/lib/cjs/storage.js": function node_modulesDfinityAuthClientLibCjsStorageJs(exports) {
      "use strict";

      var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };

      var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };

      var _IdbStorage_options;

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IdbStorage = exports.LocalStorage = exports.isBrowser = exports.DB_VERSION = exports.KEY_VECTOR = exports.KEY_STORAGE_DELEGATION = exports.KEY_STORAGE_KEY = void 0;
      var db_1 = require_db();
      exports.KEY_STORAGE_KEY = "identity";
      exports.KEY_STORAGE_DELEGATION = "delegation";
      exports.KEY_VECTOR = "iv";
      exports.DB_VERSION = 1;
      exports.isBrowser = typeof window !== "undefined";

      var LocalStorage = /*#__PURE__*/function () {
        function LocalStorage(prefix, _localStorage) {
          if (prefix === void 0) {
            prefix = "ic-";
          }

          this.prefix = prefix;
          this._localStorage = _localStorage;
        }

        var _proto96 = LocalStorage.prototype;

        _proto96.get = function get(key) {
          return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));
        };

        _proto96.set = function set(key, value) {
          this._getLocalStorage().setItem(this.prefix + key, value);

          return Promise.resolve();
        };

        _proto96.remove = function remove(key) {
          this._getLocalStorage().removeItem(this.prefix + key);

          return Promise.resolve();
        };

        _proto96._getLocalStorage = function _getLocalStorage() {
          if (this._localStorage) {
            return this._localStorage;
          }

          var ls = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? void 0 : self.localStorage : global.localStorage : window.localStorage;

          if (!ls) {
            throw new Error("Could not find local storage.");
          }

          return ls;
        };

        return LocalStorage;
      }();

      exports.LocalStorage = LocalStorage;

      var IdbStorage = /*#__PURE__*/function () {
        /**
         * @param options - DBCreateOptions
         * @param options.dbName - name for the indexeddb database
         * @param options.storeName - name for the indexeddb Data Store
         * @param options.version - version of the database. Increment to safely upgrade
         * @constructs an {@link IdbStorage}
         * @example
         * ```typescript
         * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });
         * ```
         */
        function IdbStorage(options) {
          _IdbStorage_options.set(this, void 0);

          __classPrivateFieldSet(this, _IdbStorage_options, options !== null && options !== void 0 ? options : {}, "f");
        }

        var _proto97 = IdbStorage.prototype;

        _proto97.get = /*#__PURE__*/function () {
          var _get2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64(key) {
            var db;
            return _regeneratorRuntime().wrap(function _callee64$(_context67) {
              while (1) {
                switch (_context67.prev = _context67.next) {
                  case 0:
                    _context67.next = 2;
                    return this._db;

                  case 2:
                    db = _context67.sent;
                    _context67.next = 5;
                    return db.get(key);

                  case 5:
                    return _context67.abrupt("return", _context67.sent);

                  case 6:
                  case "end":
                    return _context67.stop();
                }
              }
            }, _callee64, this);
          }));

          function get(_x100) {
            return _get2.apply(this, arguments);
          }

          return get;
        }();

        _proto97.set = /*#__PURE__*/function () {
          var _set2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65(key, value) {
            var db;
            return _regeneratorRuntime().wrap(function _callee65$(_context68) {
              while (1) {
                switch (_context68.prev = _context68.next) {
                  case 0:
                    _context68.next = 2;
                    return this._db;

                  case 2:
                    db = _context68.sent;
                    _context68.next = 5;
                    return db.set(key, value);

                  case 5:
                  case "end":
                    return _context68.stop();
                }
              }
            }, _callee65, this);
          }));

          function set(_x101, _x102) {
            return _set2.apply(this, arguments);
          }

          return set;
        }();

        _proto97.remove = /*#__PURE__*/function () {
          var _remove2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee66(key) {
            var db;
            return _regeneratorRuntime().wrap(function _callee66$(_context69) {
              while (1) {
                switch (_context69.prev = _context69.next) {
                  case 0:
                    _context69.next = 2;
                    return this._db;

                  case 2:
                    db = _context69.sent;
                    _context69.next = 5;
                    return db.remove(key);

                  case 5:
                  case "end":
                    return _context69.stop();
                }
              }
            }, _callee66, this);
          }));

          function remove(_x103) {
            return _remove2.apply(this, arguments);
          }

          return remove;
        }();

        _createClass(IdbStorage, [{
          key: "_db",
          get: function get() {
            var _this70 = this;

            return new Promise(function (resolve) {
              if (_this70.initializedDb) {
                resolve(_this70.initializedDb);
                return;
              }

              db_1.IdbKeyVal.create(__classPrivateFieldGet(_this70, _IdbStorage_options, "f")).then(function (db) {
                _this70.initializedDb = db;
                resolve(db);
              });
            });
          }
        }]);

        return IdbStorage;
      }();

      exports.IdbStorage = IdbStorage;
      _IdbStorage_options = /* @__PURE__ */new WeakMap();
    }
  }); // node_modules/@dfinity/auth-client/lib/cjs/index.js


  var require_cjs5 = __commonJS({
    "node_modules/@dfinity/auth-client/lib/cjs/index.js": function node_modulesDfinityAuthClientLibCjsIndexJs(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);

        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function get() {
              return m[k];
            }
          };
        }

        Object.defineProperty(o, k2, desc);
      } : function (o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });

      var __exportStar = exports && exports.__exportStar || function (m, exports2) {
        for (var p in m) {
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
        }
      };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AuthClient = exports.ERROR_USER_INTERRUPT = exports.IdbKeyVal = exports.KEY_STORAGE_KEY = exports.KEY_STORAGE_DELEGATION = exports.LocalStorage = exports.IdbStorage = void 0;
      var agent_1 = require_cjs3();
      var identity_1 = require_cjs4();
      var idleManager_1 = require_idleManager();
      var storage_1 = require_storage();
      var storage_2 = require_storage();
      Object.defineProperty(exports, "IdbStorage", {
        enumerable: true,
        get: function get() {
          return storage_2.IdbStorage;
        }
      });
      Object.defineProperty(exports, "LocalStorage", {
        enumerable: true,
        get: function get() {
          return storage_2.LocalStorage;
        }
      });
      Object.defineProperty(exports, "KEY_STORAGE_DELEGATION", {
        enumerable: true,
        get: function get() {
          return storage_2.KEY_STORAGE_DELEGATION;
        }
      });
      Object.defineProperty(exports, "KEY_STORAGE_KEY", {
        enumerable: true,
        get: function get() {
          return storage_2.KEY_STORAGE_KEY;
        }
      });
      var db_1 = require_db();
      Object.defineProperty(exports, "IdbKeyVal", {
        enumerable: true,
        get: function get() {
          return db_1.IdbKeyVal;
        }
      });
      var IDENTITY_PROVIDER_DEFAULT = "https://identity.internetcomputer.org";
      var IDENTITY_PROVIDER_ENDPOINT = "#authorize";
      var ECDSA_KEY_LABEL = "ECDSA";
      var ED25519_KEY_LABEL = "Ed25519";
      var INTERRUPT_CHECK_INTERVAL = 500;
      exports.ERROR_USER_INTERRUPT = "UserInterrupt";

      __exportStar(require_idleManager(), exports);

      var AuthClient = /*#__PURE__*/function () {
        function AuthClient(_identity, _key, _chain, _storage, idleManager, _createOptions, _idpWindow, _eventHandler) {
          this._identity = _identity;
          this._key = _key;
          this._chain = _chain;
          this._storage = _storage;
          this.idleManager = idleManager;
          this._createOptions = _createOptions;
          this._idpWindow = _idpWindow;
          this._eventHandler = _eventHandler;

          this._registerDefaultIdleCallback();
        }
        /**
         * Create an AuthClient to manage authentication and identity
         * @constructs
         * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}
         * @see {@link AuthClientCreateOptions}
         * @param options.identity Optional Identity to use as the base
         * @see {@link SignIdentity}
         * @param options.storage Storage mechanism for delegration credentials
         * @see {@link AuthClientStorage}
         * @param options.keyType Type of key to use for the base key
         * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}
         * @see {@link IdleOptions}
         * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.
         * @example
         * const authClient = await AuthClient.create({
         *   idleOptions: {
         *     disableIdle: true
         *   }
         * })
         */


        AuthClient.create =
        /*#__PURE__*/
        function () {
          var _create6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee67(options) {
            var _a, _b, _c, storage, keyType, key, maybeIdentityStorage, fallbackLocalStorage, localChain, localKey, identity, chain, chainStorage, idleManager;

            return _regeneratorRuntime().wrap(function _callee67$(_context70) {
              while (1) {
                switch (_context70.prev = _context70.next) {
                  case 0:
                    if (options === void 0) {
                      options = {};
                    }

                    storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new storage_1.IdbStorage();
                    keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;
                    key = null;

                    if (!options.identity) {
                      _context70.next = 8;
                      break;
                    }

                    key = options.identity;
                    _context70.next = 55;
                    break;

                  case 8:
                    _context70.next = 10;
                    return storage.get(storage_1.KEY_STORAGE_KEY);

                  case 10:
                    maybeIdentityStorage = _context70.sent;

                    if (!(!maybeIdentityStorage && storage_1.isBrowser)) {
                      _context70.next = 36;
                      break;
                    }

                    _context70.prev = 12;
                    fallbackLocalStorage = new storage_1.LocalStorage();
                    _context70.next = 16;
                    return fallbackLocalStorage.get(storage_1.KEY_STORAGE_DELEGATION);

                  case 16:
                    localChain = _context70.sent;
                    _context70.next = 19;
                    return fallbackLocalStorage.get(storage_1.KEY_STORAGE_KEY);

                  case 19:
                    localKey = _context70.sent;

                    if (!(localChain && localKey && keyType === ECDSA_KEY_LABEL)) {
                      _context70.next = 31;
                      break;
                    }

                    console.log("Discovered an identity stored in localstorage. Migrating to IndexedDB");
                    _context70.next = 24;
                    return storage.set(storage_1.KEY_STORAGE_DELEGATION, localChain);

                  case 24:
                    _context70.next = 26;
                    return storage.set(storage_1.KEY_STORAGE_KEY, localKey);

                  case 26:
                    maybeIdentityStorage = localChain;
                    _context70.next = 29;
                    return fallbackLocalStorage.remove(storage_1.KEY_STORAGE_DELEGATION);

                  case 29:
                    _context70.next = 31;
                    return fallbackLocalStorage.remove(storage_1.KEY_STORAGE_KEY);

                  case 31:
                    _context70.next = 36;
                    break;

                  case 33:
                    _context70.prev = 33;
                    _context70.t0 = _context70["catch"](12);
                    console.error("error while attempting to recover localstorage: " + _context70.t0);

                  case 36:
                    if (!maybeIdentityStorage) {
                      _context70.next = 55;
                      break;
                    }

                    _context70.prev = 37;

                    if (!(typeof maybeIdentityStorage === "object")) {
                      _context70.next = 50;
                      break;
                    }

                    if (!(keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === "string")) {
                      _context70.next = 45;
                      break;
                    }

                    _context70.next = 42;
                    return identity_1.Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);

                  case 42:
                    key = _context70.sent;
                    _context70.next = 48;
                    break;

                  case 45:
                    _context70.next = 47;
                    return identity_1.ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);

                  case 47:
                    key = _context70.sent;

                  case 48:
                    _context70.next = 51;
                    break;

                  case 50:
                    if (typeof maybeIdentityStorage === "string") {
                      key = identity_1.Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
                    }

                  case 51:
                    _context70.next = 55;
                    break;

                  case 53:
                    _context70.prev = 53;
                    _context70.t1 = _context70["catch"](37);

                  case 55:
                    identity = new agent_1.AnonymousIdentity();
                    chain = null;

                    if (!key) {
                      _context70.next = 85;
                      break;
                    }

                    _context70.prev = 58;
                    _context70.next = 61;
                    return storage.get(storage_1.KEY_STORAGE_DELEGATION);

                  case 61:
                    chainStorage = _context70.sent;

                    if (!(typeof chainStorage === "object" && chainStorage !== null)) {
                      _context70.next = 64;
                      break;
                    }

                    throw new Error("Delegation chain is incorrectly stored. A delegation chain should be stored as a string.");

                  case 64:
                    if (!options.identity) {
                      _context70.next = 68;
                      break;
                    }

                    identity = options.identity;
                    _context70.next = 77;
                    break;

                  case 68:
                    if (!chainStorage) {
                      _context70.next = 77;
                      break;
                    }

                    chain = identity_1.DelegationChain.fromJSON(chainStorage);

                    if ((0, identity_1.isDelegationValid)(chain)) {
                      _context70.next = 76;
                      break;
                    }

                    _context70.next = 73;
                    return _deleteStorage(storage);

                  case 73:
                    key = null;
                    _context70.next = 77;
                    break;

                  case 76:
                    if ("toDer" in key) {
                      identity = identity_1.PartialDelegationIdentity.fromDelegation(key, chain);
                    } else {
                      identity = identity_1.DelegationIdentity.fromDelegation(key, chain);
                    }

                  case 77:
                    _context70.next = 85;
                    break;

                  case 79:
                    _context70.prev = 79;
                    _context70.t2 = _context70["catch"](58);
                    console.error(_context70.t2);
                    _context70.next = 84;
                    return _deleteStorage(storage);

                  case 84:
                    key = null;

                  case 85:
                    idleManager = void 0;

                    if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {
                      idleManager = void 0;
                    } else if (chain || options.identity) {
                      idleManager = idleManager_1.IdleManager.create(options.idleOptions);
                    }

                    if (key) {
                      _context70.next = 102;
                      break;
                    }

                    if (!(keyType === ED25519_KEY_LABEL)) {
                      _context70.next = 96;
                      break;
                    }

                    _context70.next = 91;
                    return identity_1.Ed25519KeyIdentity.generate();

                  case 91:
                    key = _context70.sent;
                    _context70.next = 94;
                    return storage.set(storage_1.KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));

                  case 94:
                    _context70.next = 102;
                    break;

                  case 96:
                    if (options.storage && keyType === ECDSA_KEY_LABEL) {
                      console.warn("You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '" + ED25519_KEY_LABEL + "' as the key type, as it can serialize to a string");
                    }

                    _context70.next = 99;
                    return identity_1.ECDSAKeyIdentity.generate();

                  case 99:
                    key = _context70.sent;
                    _context70.next = 102;
                    return storage.set(storage_1.KEY_STORAGE_KEY, key.getKeyPair());

                  case 102:
                    return _context70.abrupt("return", new this(identity, key, chain, storage, idleManager, options));

                  case 103:
                  case "end":
                    return _context70.stop();
                }
              }
            }, _callee67, this, [[12, 33], [37, 53], [58, 79]]);
          }));

          function create(_x104) {
            return _create6.apply(this, arguments);
          }

          return create;
        }();

        var _proto98 = AuthClient.prototype;

        _proto98._registerDefaultIdleCallback = function _registerDefaultIdleCallback() {
          var _this71 = this;

          var _a, _b;

          var idleOptions = (_a = this._createOptions) === null || _a === void 0 ? void 0 : _a.idleOptions;

          if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {
            (_b = this.idleManager) === null || _b === void 0 ? void 0 : _b.registerCallback(function () {
              _this71.logout();

              location.reload();
            });
          }
        };

        _proto98._handleSuccess = /*#__PURE__*/function () {
          var _handleSuccess2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee68(message, onSuccess) {
            var _a, _b, delegations, delegationChain, key, idleOptions;

            return _regeneratorRuntime().wrap(function _callee68$(_context71) {
              while (1) {
                switch (_context71.prev = _context71.next) {
                  case 0:
                    delegations = message.delegations.map(function (signedDelegation) {
                      return {
                        delegation: new identity_1.Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
                        signature: signedDelegation.signature.buffer
                      };
                    });
                    delegationChain = identity_1.DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
                    key = this._key;

                    if (key) {
                      _context71.next = 5;
                      break;
                    }

                    return _context71.abrupt("return");

                  case 5:
                    this._chain = delegationChain;

                    if ("toDer" in key) {
                      this._identity = identity_1.PartialDelegationIdentity.fromDelegation(key, this._chain);
                    } else {
                      this._identity = identity_1.DelegationIdentity.fromDelegation(key, this._chain);
                    }

                    (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();
                    idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;

                    if (!this.idleManager && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableIdle)) {
                      this.idleManager = idleManager_1.IdleManager.create(idleOptions);

                      this._registerDefaultIdleCallback();
                    }

                    this._removeEventListener();

                    delete this._idpWindow;

                    if (!this._chain) {
                      _context71.next = 15;
                      break;
                    }

                    _context71.next = 15;
                    return this._storage.set(storage_1.KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));

                  case 15:
                    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(message);

                  case 16:
                  case "end":
                    return _context71.stop();
                }
              }
            }, _callee68, this);
          }));

          function _handleSuccess(_x105, _x106) {
            return _handleSuccess2.apply(this, arguments);
          }

          return _handleSuccess;
        }();

        _proto98.getIdentity = function getIdentity() {
          return this._identity;
        };

        _proto98.isAuthenticated = /*#__PURE__*/function () {
          var _isAuthenticated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee69() {
            return _regeneratorRuntime().wrap(function _callee69$(_context72) {
              while (1) {
                switch (_context72.prev = _context72.next) {
                  case 0:
                    return _context72.abrupt("return", !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null);

                  case 1:
                  case "end":
                    return _context72.stop();
                }
              }
            }, _callee69, this);
          }));

          function isAuthenticated() {
            return _isAuthenticated.apply(this, arguments);
          }

          return isAuthenticated;
        }()
        /**
         * AuthClient Login -
         * Opens up a new window to authenticate with Internet Identity
         * @param {AuthClientLoginOptions} options - Options for logging in
         * @param options.identityProvider Identity provider
         * @param options.maxTimeToLive Expiration of the authentication in nanoseconds
         * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).
         * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity
         * @param options.windowOpenerFeatures Configures the opened authentication window
         * @param options.onSuccess Callback once login has completed
         * @param options.onError Callback in case authentication fails
         * @example
         * const authClient = await AuthClient.create();
         * authClient.login({
         *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',
         *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week
         *  windowOpenerFeatures: "toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100",
         *  onSuccess: () => {
         *    console.log('Login Successful!');
         *  },
         *  onError: (error) => {
         *    console.error('Login Failed: ', error);
         *  }
         * });
         */
        ;

        _proto98.login =
        /*#__PURE__*/
        function () {
          var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee70(options) {
            var _this72 = this;

            var _a, _b, _c, _d, defaultTimeToLive, identityProviderUrl, checkInterruption;

            return _regeneratorRuntime().wrap(function _callee70$(_context73) {
              while (1) {
                switch (_context73.prev = _context73.next) {
                  case 0:
                    defaultTimeToLive =
                    /* hours */
                    BigInt(8) *
                    /* nanoseconds */
                    BigInt(36e11);
                    identityProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a === void 0 ? void 0 : _a.toString()) || IDENTITY_PROVIDER_DEFAULT);
                    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;
                    (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();

                    this._removeEventListener();

                    this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({
                      maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive
                    }, options));
                    window.addEventListener("message", this._eventHandler);
                    this._idpWindow = (_d = window.open(identityProviderUrl.toString(), "idpWindow", options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : void 0;

                    checkInterruption = function checkInterruption() {
                      if (_this72._idpWindow) {
                        if (_this72._idpWindow.closed) {
                          _this72._handleFailure(exports.ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);
                        } else {
                          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);
                        }
                      }
                    };

                    checkInterruption();

                  case 10:
                  case "end":
                    return _context73.stop();
                }
              }
            }, _callee70, this);
          }));

          function login(_x107) {
            return _login.apply(this, arguments);
          }

          return login;
        }();

        _proto98._getEventHandler = function _getEventHandler(identityProviderUrl, options) {
          var _this73 = this;

          return /*#__PURE__*/function () {
            var _ref128 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee71(event) {
              var _a, _b, _c, message, request;

              return _regeneratorRuntime().wrap(function _callee71$(_context74) {
                while (1) {
                  switch (_context74.prev = _context74.next) {
                    case 0:
                      if (!(event.origin !== identityProviderUrl.origin)) {
                        _context74.next = 2;
                        break;
                      }

                      return _context74.abrupt("return");

                    case 2:
                      message = event.data;
                      _context74.t0 = message.kind;
                      _context74.next = _context74.t0 === "authorize-ready" ? 6 : _context74.t0 === "authorize-client-success" ? 9 : _context74.t0 === "authorize-client-failure" ? 18 : 20;
                      break;

                    case 6:
                      request = Object.assign({
                        kind: "authorize-client",
                        sessionPublicKey: new Uint8Array((_a = _this73._key) === null || _a === void 0 ? void 0 : _a.getPublicKey().toDer()),
                        maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive,
                        allowPinAuthentication: options === null || options === void 0 ? void 0 : options.allowPinAuthentication,
                        derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString()
                      }, options === null || options === void 0 ? void 0 : options.customValues);
                      (_c = _this73._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);
                      return _context74.abrupt("break", 21);

                    case 9:
                      _context74.prev = 9;
                      _context74.next = 12;
                      return _this73._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);

                    case 12:
                      _context74.next = 17;
                      break;

                    case 14:
                      _context74.prev = 14;
                      _context74.t1 = _context74["catch"](9);

                      _this73._handleFailure(_context74.t1.message, options === null || options === void 0 ? void 0 : options.onError);

                    case 17:
                      return _context74.abrupt("break", 21);

                    case 18:
                      _this73._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);

                      return _context74.abrupt("break", 21);

                    case 20:
                      return _context74.abrupt("break", 21);

                    case 21:
                    case "end":
                      return _context74.stop();
                  }
                }
              }, _callee71, null, [[9, 14]]);
            }));

            return function (_x108) {
              return _ref128.apply(this, arguments);
            };
          }();
        };

        _proto98._handleFailure = function _handleFailure(errorMessage, onError) {
          var _a;

          (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();
          onError === null || onError === void 0 ? void 0 : onError(errorMessage);

          this._removeEventListener();

          delete this._idpWindow;
        };

        _proto98._removeEventListener = function _removeEventListener() {
          if (this._eventHandler) {
            window.removeEventListener("message", this._eventHandler);
          }

          this._eventHandler = void 0;
        };

        _proto98.logout = /*#__PURE__*/function () {
          var _logout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72(options) {
            return _regeneratorRuntime().wrap(function _callee72$(_context75) {
              while (1) {
                switch (_context75.prev = _context75.next) {
                  case 0:
                    if (options === void 0) {
                      options = {};
                    }

                    _context75.next = 3;
                    return _deleteStorage(this._storage);

                  case 3:
                    this._identity = new agent_1.AnonymousIdentity();
                    this._chain = null;

                    if (options.returnTo) {
                      try {
                        window.history.pushState({}, "", options.returnTo);
                      } catch (_a) {
                        window.location.href = options.returnTo;
                      }
                    }

                  case 6:
                  case "end":
                    return _context75.stop();
                }
              }
            }, _callee72, this);
          }));

          function logout(_x109) {
            return _logout.apply(this, arguments);
          }

          return logout;
        }();

        return AuthClient;
      }();

      exports.AuthClient = AuthClient;

      function _deleteStorage(_x110) {
        return _deleteStorage2.apply(this, arguments);
      }

      function _deleteStorage2() {
        _deleteStorage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(storage) {
          return _regeneratorRuntime().wrap(function _callee73$(_context76) {
            while (1) {
              switch (_context76.prev = _context76.next) {
                case 0:
                  _context76.next = 2;
                  return storage.remove(storage_1.KEY_STORAGE_KEY);

                case 2:
                  _context76.next = 4;
                  return storage.remove(storage_1.KEY_STORAGE_DELEGATION);

                case 4:
                  _context76.next = 6;
                  return storage.remove(storage_1.KEY_VECTOR);

                case 6:
                case "end":
                  return _context76.stop();
              }
            }
          }, _callee73);
        }));
        return _deleteStorage2.apply(this, arguments);
      }
    }
  });

  return require_cjs5();
}();

if (typeof module !== "undefined" && module.exports) {
  module.exports = DfinityAuthClient;
}

if (typeof window !== "undefined") {
  window.DfinityAuthClient = DfinityAuthClient;
}
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

cc._RF.pop();